const BaseBuilder = require('./BaseBuilder')

const sqlFunctions = [
  'exists', 'contains'
]

/**
 * ReferenceBuilder is used to take a part of a CQN object as an input and to build an object representing a reference
 * with SQL string and empty values.
 *
 * Currently only support the simple references like below:
 *
 * @example <caption>Simple ref part of CQN </caption>
 * {ref: ['x']}
 */
class ReferenceBuilder extends BaseBuilder {
  get SelectBuilder () {
    const SelectBuilder = require('./SelectBuilder')
    Object.defineProperty(this, 'SelectBuilder', {value: SelectBuilder})
    return SelectBuilder
  }

  /**
   * Builds an Object based on the properties of the input object in the constructor.
   * @example <caption>Example output</caption>
   * {
   *    sql: '"X"',
   *    values: []
   * }
   *
   * @throws InvalidCqnObjectError
   * @returns {{sql: string, values: Array}} Object with two properties.
   * SQL string for prepared statement and an empty array of values.
   */
  build () {
    this._outputObj = {
      sql: [],
      values: []
    }

    if (this._obj.ref.length > 1 && this._obj.ref[1].args) {
      if (sqlFunctions.some((sqlFunction) => this._obj.ref[0].toLowerCase().includes(sqlFunction))) { // sql functions (exists,...)
        this._sqlFunction()
      } else { // unsupported function
        this._aggregatedFunction()
      }
    } else { // reference
      this._parseReference(this._obj.ref)
    }

    this._outputObj.sql = this._outputObj.sql.join(' ')
    return this._outputObj
  }

  _parseReference (refArray) {
    if (this._options.entityNames && refArray.length > 1 && this._options.entityNames.includes(refArray[0])) {
      this._outputObj.sql.push(this._quoteElement(refArray[0]) + '.' + this._quoteElement(refArray.slice(1).join('_')))
    } else {
      this._outputObj.sql.push(this._quoteElement(refArray.join('_')))
    }
  }

  _aggregatedFunction () {
    this._outputObj.sql.push(this._obj.ref[0], '(')
    if (typeof this._obj.ref[1].args === 'string') {
      this._outputObj.sql.push(this._obj.ref[1].args, ')')
    } else {
      this._outputObj.sql.push(this._obj.ref[1].args.map(e => (new ReferenceBuilder(e, this._options)).build().sql).join(', '), ')')
    }
  }

  _sqlFunction () {
    if (this._obj.ref[0].toLowerCase().includes('exists')) {
      this._outputObj.sql.push(this._obj.ref[0].toUpperCase(), '(')
      const select = new this.SelectBuilder(this._obj.ref[1].args[0], this._options).build()
      this._outputObj.sql.push(select.sql)
      this._outputObj.values = this._outputObj.values.concat(select.values)
      this._outputObj.sql.push(')')
    } else { // this._obj.ref[0] === contains
      this._handleContains()
    }
  }

  _createLikeComparison (contains, columns, searchText) {
    const length = columns.length
    for (let i = 0; i < length; i++) {
      this._outputObj.sql.push(`LOWER(${columns[i]})`, contains ? 'LIKE' : 'NOT LIKE', this._options.placeholder)
      this._outputObj.values.push(`%${searchText.replace(/(_|%)/g, '\\$1')}%`)
      if (i !== length - 1) {
        this._outputObj.sql.push(contains ? 'OR' : 'AND')
      }
    }
  }

  _handleContains () {
    const contains = !this._obj.ref[0].toLowerCase().includes('not')
    const columns = this._columnsFromContains(this._obj.ref[1].args)
    const params = this._obj.ref[1].args.slice(1)

    for (const param of params) {
      if (param === 'or' || param === 'and' || param === 'not') {
        this._outputObj.sql.push(param)
      } else {
        const searchText = param.val.toLowerCase()
        this._outputObj.sql.push('(')
        this._createLikeComparison(contains, columns, searchText)
        this._outputObj.sql.push(')')
      }
    }
  }

  _columnsFromContains (args) {
    if (args[0].xpr) {
      return [new ReferenceBuilder(args[0].xpr[1], this._options).build().sql]
    } else {
      return args[0].list.map((element) => new ReferenceBuilder(element, this._options).build().sql)
    }
  }
}

module.exports = ReferenceBuilder
