const BaseBuilder = require('./BaseBuilder')
const {getAnnotatedColumns} = require('../util/annotations')

/**
 * UpdateBuilder is used to take a CQN object as an input and to build an object representing an update operation
 * with SQL string and values to be used with a prepared statement.
 * The SQL object can only be built if properties 'entity' and 'with' are available.
 * The property 'where' is optional.
 * @example <caption>Example of CQN </caption>
 * {
 *  UPDATE = {UPDATE:{
 *  entity: entity | string,
 *  data: { ...column:any },
 *  where: _xpr,
 *  }}
 * }
 */
class UpdateBuilder extends BaseBuilder {
  constructor (obj, options, csn) {
    super(obj, options)
    this._options.typeConversion = this._options.typeConversion || new Map()
    this._csn = csn
  }

  get ExpressionBuilder () {
    const ExpressionBuilder = require('./ExpressionBuilder')
    Object.defineProperty(this, 'ExpressionBuilder', {value: ExpressionBuilder})
    return ExpressionBuilder
  }

  get ReferenceBuilder () {
    const ReferenceBuilder = require('./ReferenceBuilder')
    Object.defineProperty(this, 'ReferenceBuilder', {value: ReferenceBuilder})
    return ReferenceBuilder
  }

  /**
   * Builds an Object based on the properties of the CQN object.
   * @example <caption>Example output</caption>
   * {
   *    sql: 'UPDATE "T" SET "a" = ?, "b" = ?, "c" = ? WHERE "x" < ? ',
   *    values: [1, 2, "'asd'", 9]
   * }
   *
   * @returns {{sql: string, values: Array}} Object with two properties.
   * SQL string for prepared statement and array of values to replace the placeholders.
   */
  build () {
    this._outputObj = {
      sql: ['UPDATE'],
      values: []
    }
    this._options.entityNames.push(this._obj.UPDATE.entity.name || this._obj.UPDATE.entity)

    const entityName = this._entity()

    this._data(getAnnotatedColumns(entityName, this._csn, this._options))
    if (this._obj.UPDATE.hasOwnProperty('where')) {
      this._where()
    }

    this._outputObj.sql = this._outputObj.sql.join(' ')
    return this._outputObj
  }

  _entity () {
    if (typeof this._obj.UPDATE.entity === 'string') {
      this._outputObj.sql.push(this._quoteElement(this._obj.UPDATE.entity))
      return this._obj.UPDATE.entity
    } else {
      this._outputObj.sql.push(this._quoteElement(this._obj.UPDATE.entity.name))
      return this._obj.UPDATE.entity.name
    }
  }

  _data (annotatedColumns) {
    const sql = []
    const annotatedAllColumnNames = this._getAnnotatedColumnNames(annotatedColumns)
    const resMap = this._getFlattenColumnValues(this._obj.UPDATE.data, annotatedAllColumnNames)
    this._addAnnotatedUpdateColumns(resMap, annotatedColumns)
    resMap.forEach((value, key, map) => {
      if (value && value.sql) {
        sql.push(`${this._quoteElement(key)} = ${value.sql}`)
        this._outputObj.values.push(...value.values)
      } else {
        sql.push(`${this._quoteElement(key)} = ?`)
        this._outputObj.values.push(value)
      }
    })

    this._outputObj.sql.push(`SET ${sql.join(', ')}`)
  }

  _getFlattenColumnValues (data, annotatedAllColumnNames) {
    const res = new Map()
    Object.keys(data).forEach(key => {
      if (annotatedAllColumnNames && annotatedAllColumnNames.includes(key)) {
        return
      }
      const value = data[key]
      if (typeof value === 'object' && value !== null) {
        if (value.hasOwnProperty('xpr')) {
          const xpr = new this.ExpressionBuilder(value.xpr, this._options).build()
          res.set(key, xpr)
        } else if (value.hasOwnProperty('ref')) {
          const ref = new this.ReferenceBuilder(value, this._options).build()
          res.set(key, ref)
        } else if (value.hasOwnProperty('val')) {
          res.set(key, value.val)
        } else {
          const resInternal = this._getFlattenColumnValues(value)
          Array.from(resInternal.keys()).forEach(keyInternal => {
            res.set(`${key}_${keyInternal}`, resInternal.get(keyInternal))
          })
        }
      } else {
        res.set(key, value)
      }
    })

    return res
  }

  _addAnnotatedUpdateColumns (resMap, annotatedColumns) {
    if (!annotatedColumns) {
      return
    }
    for (const col of annotatedColumns.updateAnnotatedColumns.keys()) {
      const annotatedValue = this._options[annotatedColumns.updateAnnotatedColumns.get(col).symbol]
      if (typeof annotatedValue === 'object') {
        annotatedValue.values = []
      }
      resMap.set(col, annotatedValue)
    }
  }

  _getAnnotatedColumnNames (annotatedColumns) {
    if (!annotatedColumns) {
      return []
    }
    const annotatedAllColumnNames = [...annotatedColumns.insertAnnotatedColumns.keys()]
    annotatedAllColumnNames.push(...annotatedColumns.updateAnnotatedColumns.keys())

    return annotatedAllColumnNames
  }

  _where () {
    const where = new this.ExpressionBuilder(this._obj.UPDATE.where, this._options).build()
    this._outputObj.sql.push('WHERE', where.sql)
    this._outputObj.values = this._outputObj.values.concat(where.values)
  }
}

module.exports = UpdateBuilder
