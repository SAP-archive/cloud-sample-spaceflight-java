const BaseBuilder = require('./BaseBuilder')
const {getAnnotatedColumns} = require('../util/annotations')

/**
 * InsertBuilder is used to take a CQN object as an input and to build an object representing an insert operation
 * with SQL string and values to be inserted with the prepared statement.
 * The SQL object can only be built if one of the properties 'entries', 'values' or 'rows' is available.
 * @example <caption>Example of CQN </caption>
 * {
 *  INSERT = {INSERT:{
 *  into: entity | string,
 *  columns: [ ...string ],
 *  values: [ ...any ],
 *  rows: [ ...[ ...any ] ],
 *  entries: [ ...{ ...column:any } ]
 *  }}
 * }
 */
class InsertBuilder extends BaseBuilder {
  /**
   * Base constructor with additionally provided csn
   *
   * @param {object} obj
   * @param {object} options
   * @param {object} csn
   */
  constructor (obj, options, csn) {
    super(obj, options)
    this._options.typeConversion = this._options.typeConversion || new Map()
    this._csn = csn
  }

  /**
   * Builds an Object based on the properties of the CQN object.
   * @example <caption>Example output</caption>
   * {
   *    sql: 'INSERT INTO "T" ("a", "b", "c") VALUES (?, ?, ?)',
   *    values: [1, 2, '\'asd\'']
   * }
   *
   * @returns {{sql: string, values: Array}} Object with two properties.
   * SQL string for prepared statement and array of values to replace the placeholders.
   * Property values can be an Array of Arrays for Batch insert of multiple rows.
   */
  build () {
    this._outputObj = {
      sql: ['INSERT', 'INTO'],
      values: []
    }

    const entityName = this._into()

    this._columnIndexesToDelete = []
    const annotatedColumns = getAnnotatedColumns(entityName, this._csn, this._options)

    if (this._obj.INSERT.columns) {
      this._columns(annotatedColumns)
    }

    if (this._obj.INSERT.values || this._obj.INSERT.rows) {
      if (annotatedColumns && !this._obj.INSERT.columns) { // if columns not provided get indexes from csn
        this._getAnnotatedColumnIndexes(annotatedColumns)
      }

      this._values(annotatedColumns)
    } else if (this._obj.INSERT.entries.length !== 0) {
      this._entries(annotatedColumns)
    }

    this._outputObj.sql = this._outputObj.sql.join(' ')
    return this._outputObj
  }

  _into () {
    if (typeof this._obj.INSERT.into === 'string') {
      this._outputObj.sql.push(this._quoteElement(this._obj.INSERT.into))
      return this._obj.INSERT.into
    }

    this._outputObj.sql.push(this._quoteElement(this._obj.INSERT.into.name))
    return this._obj.INSERT.into.name
  }

  _columnsAnnotatedFilter (annotatedColumns) {
    const annotatedAllColumnNames = this._getAnnotatedColumnNames(annotatedColumns)

    this._obj.INSERT.columns.forEach((col, index) => {
      if (annotatedAllColumnNames.includes(col)) {
        this._columnIndexesToDelete.push(index)
      }
    })

    this._spliceArray(this._obj.INSERT.columns) // remove all annotated columns
  }

  _columnAnnotatedAdded (annotatedColumns) {
    const annotatedInsertColumnNames = this._getAnnotatedInsertColumnNames(annotatedColumns)

    if (annotatedInsertColumnNames && annotatedInsertColumnNames.length !== 0) {
      this._outputObj.sql.push(',', annotatedInsertColumnNames.map(col => this._quoteElement(col)).join(', '))
    }
  }

  _columns (annotatedColumns) {
    this._outputObj.sql.push('(')

    if (annotatedColumns) { // filter out existing annotated columns
      this._columnsAnnotatedFilter(annotatedColumns)
    }

    this._outputObj.sql.push(this._obj.INSERT.columns.map(col => this._quoteElement(col)).join(', '))

    if (annotatedColumns) { // add insert annotated columns
      this._columnAnnotatedAdded(annotatedColumns)
    }

    this._outputObj.sql.push(')')
  }

  _valuesAnnotatedValues (annotatedInsertColumnValues, values) {
    this._spliceArray(values) // remove all annotated

    if (annotatedInsertColumnValues.values && annotatedInsertColumnValues.values.length !== 0) {
      values.push(...annotatedInsertColumnValues.values) // add insert annotated
    }
  }

  _values (annotatedColumns) {
    let placeholderNum = 0
    const annotatedInsertColumnValues = annotatedColumns ? this._getAnnotatedInsertColumnValues(annotatedColumns) : []

    if (this._obj.INSERT.values) {
      this._outputObj.values = this._obj.INSERT.values

      placeholderNum = this._outputObj.values.length

      this._valuesAnnotatedValues(annotatedInsertColumnValues, this._outputObj.values)
    } else {
      this._outputObj.values = this._obj.INSERT.rows

      placeholderNum = this._outputObj.values[0].length

      this._outputObj.values.forEach((values) => {
        this._valuesAnnotatedValues(annotatedInsertColumnValues, values)
      })
    }

    this._outputObj.sql.push(...this._createPlaceholderString(placeholderNum, annotatedInsertColumnValues.valuesAndSQLs))
  }

  /**
   * This method creates insert statement in case of multiple entries.
   * The assumption is that each entry contains exactly the same columns.
   *
   * @example:
   * [{a: {b: 1, c: 2}}, {a: {b: 2, c: 3}}, {a: {b: 3, c: 4}}]
   *
   * @private
   */
  _entries (annotatedColumns) {
    const columns = []
    const valuesArray = []
    const annotatedAllColumnNames = this._getAnnotatedColumnNames(annotatedColumns)
    const annotatedInsertColumnNames = this._getAnnotatedInsertColumnNames(annotatedColumns)
    const annotatedInsertColumnValues = this._getAnnotatedInsertColumnValues(annotatedColumns)
    const flattenColumnMap = this._getFlattenColumnMap(this._obj.INSERT.entries[0], annotatedAllColumnNames)

    columns.push(...flattenColumnMap.keys())

    for (const entry of this._obj.INSERT.entries) {
      const values = []

      for (const column of columns) {
        let val = entry

        for (const key of flattenColumnMap.get(column)) {
          val = val[key]
        }

        values.push(val)
      }

      // insert values for insert annotated columns
      values.push(...annotatedInsertColumnValues.values)

      valuesArray.push(values)
    }

    // add insert annotated columns
    const placeholderNum = columns.length
    columns.push(...annotatedInsertColumnNames)

    this._outputObj.sql.push(...this._entriesSqlString(columns, placeholderNum, annotatedInsertColumnValues.valuesAndSQLs))
    this._outputObj.values = valuesArray
  }

  _getFlattenColumnMap (entry, annotatedAllColumnNames) {
    const res = new Map()

    Object.keys(entry).forEach(key => {
      if (typeof entry[key] === 'object' && entry[key] !== null) {
        // TODO: consider structured elements with annotations ?
        const resInternal = this._getFlattenColumnMap(entry[key])

        Array.from(resInternal.keys()).forEach(keyInternal => {
          const arrInternal = resInternal.get(keyInternal)
          arrInternal.unshift(key)
          res.set(`${key}_${keyInternal}`, arrInternal)
        })
      } else {
        if (!annotatedAllColumnNames || !annotatedAllColumnNames.includes(key)) {
          res.set(key, [key])
        }
      }
    })

    return res
  }

  _entriesSqlString (columns, placeholderNum, valuesAndSQLs) {
    return ['(', columns.map(column => this._quoteElement(column)).join(', '), ')', ...this._createPlaceholderString(placeholderNum, valuesAndSQLs)]
  }

  _createPlaceholderString (placeholderNum, valuesAndSQLs = []) {
    const placeholders = []

    for (let i = 0, length = placeholderNum - this._columnIndexesToDelete.length; i < length; i++) {
      placeholders.push(this._options.placeholder)
    }

    for (const val of valuesAndSQLs) {
      placeholders.push((val && val.sql) ? val.sql : this._options.placeholder)
    }

    return ['VALUES', '(', placeholders.join(', '), ')']
  }

  _getAnnotatedColumnIndexes (annotatedColumns) {
    annotatedColumns.insertAnnotatedColumns.forEach((col) => {
      if (col.indexNo) {
        this._columnIndexesToDelete.push(col.indexNo)
      }
    })
    annotatedColumns.updateAnnotatedColumns.forEach((col) => {
      if (col.indexNo) {
        this._columnIndexesToDelete.push(col.indexNo)
      }
    })
  }

  _getAnnotatedColumnNames (annotatedColumns) {
    if (!annotatedColumns) {
      return []
    }

    const annotatedAllColumnNames = [...annotatedColumns.insertAnnotatedColumns.keys()]
    annotatedAllColumnNames.push(...annotatedColumns.updateAnnotatedColumns.keys())

    return annotatedAllColumnNames
  }

  _getAnnotatedInsertColumnNames (annotatedColumns) {
    return annotatedColumns ? [...annotatedColumns.insertAnnotatedColumns.keys()] : []
  }

  _getAnnotatedInsertColumnValues (annotatedColumns) {
    const res = {}
    res.values = []
    res.valuesAndSQLs = []

    if (!annotatedColumns) {
      return res
    }

    for (const col of annotatedColumns.insertAnnotatedColumns.keys()) {
      const annotatedValue = this._options[annotatedColumns.insertAnnotatedColumns.get(col).symbol]

      if (!annotatedValue || !annotatedValue.sql) {
        res.values.push(annotatedValue)
      }

      res.valuesAndSQLs.push(annotatedValue)
    }

    return res
  }

  _spliceArray (values) {
    for (let i = this._columnIndexesToDelete.length - 1; i >= 0; i--) {
      values.splice(this._columnIndexesToDelete[i], 1)
    }
  }
}

module.exports = InsertBuilder
