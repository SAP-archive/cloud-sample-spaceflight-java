const BaseBuilder = require('./BaseBuilder')
const cds = require('../cds')
const {isAssociation} = require('../util/associations')
const {convertDataType} = require('../util/dataTypes')

/**
 * CreateBuilder is used to take a CQN object as an input and to build an object representing a create operation
 * with SQL string.
 * The SQL object can only be built if properties 'entity' and 'as' in case 'entity' is string are available.
 * @example <caption>Example of CQN </caption>
 * {
 *  CREATE = {CREATE:{
 *  entity: entity | string,
 *  as: SELECT
 *  }}
 * }
 */
class CreateBuilder extends BaseBuilder {
  /**
   * The base class constructor for the builders.
   * If the options parameter is not specified, " are used as delimiter and ? as placeholders.
   *
   * @param {object} obj - The CQN object used for the insert operation
   * @param {object} [options] - The configuration object.
   * @param {string} [options.delimiter] - The delimiter string.
   * @param {string} [options.placeholder] - The placeholder for prepared statement.
   * @param {Map} [options.typeConversion] - Map for database specific type conversion.
   * @param {object} [csn] - The csn object.
   */
  constructor (obj, options, csn) {
    super(obj, options)
    this._options.typeConversion = this._options.typeConversion || new Map()
    this._csn = csn
  }

  /**
   * Builds an Object based on the properties of the CQN object.
   * @example <caption>Example output</caption>
   * {
   *    sql: 'CREATE TABLE name'
   * }
   *
   * @returns {{sql: string}} Object containing sql.
   */
  build () {
    this._outputObj = {
      sql: ['CREATE']
    }
    this._entity()
    if (!this._isView && this._obj.CREATE.entity.elements) {
      this._elements()
    }
    if (!this._isView && this._obj.CREATE.as) {
      this._as()
    }

    this._outputObj.sql = this._outputObj.sql.join(' ')
    return this._outputObj
  }

  get SelectBuilder () {
    const SelectBuilder = require('./SelectBuilder')
    Object.defineProperty(this, 'SelectBuilder', {value: SelectBuilder})
    return SelectBuilder
  }

  _entity () {
    let entityName
    let view
    if (typeof this._obj.CREATE.entity === 'string') {
      entityName = this._obj.CREATE.entity
      if (this._csn && this._csn.definitions[entityName]) {
        view = this._view(this._csn.definitions[entityName])
      }
    } else {
      entityName = this._obj.CREATE.entity.name
      view = this._view(this._obj.CREATE.entity)
    }

    if (view) {
      this._outputObj.sql.push('VIEW', this._quoteElement(entityName), 'AS', view)
      this._isView = true
    } else {
      this._outputObj.sql.push('TABLE', this._quoteElement(entityName))
    }
  }

  _view (entity) {
    if (entity.query) {
      const select = entity.query.cql ? cds.parse.cql(entity.query.cql) : entity.query
      const {sql, values} = new this.SelectBuilder(select, this._options).build()
      this._outputObj.values = values
      return sql
    } else if (entity.source) {
      const columns = []
      this._elementsForEntity(this._obj.CREATE.entity).forEach((element) => {
        columns.push(this._quoteElement(element.column))
      })

      return `SELECT ${columns.length > 0 ? columns.join(', ') : '*'} FROM ${this._quoteElement(entity.source)}`
    } else if (entity.type) {
      // TODO adapt when .type is documented
      const {sql, values} = new this.SelectBuilder({SELECT: {from: {ref: [entity.name]}}}, this._options).build()
      this._outputObj.values = values
      return sql
    }

    return undefined
  }

  _flattenStructuredElement (prefix, structuredType, arr) {
    const flattenedElements = arr || []
    for (const property of Object.keys(structuredType)) {
      if (structuredType[property].elements) {
        this._flattenStructuredElement(`${prefix}_${property}`, structuredType[property].elements, flattenedElements)
      } else {
        const dataType = convertDataType(structuredType[property], this._csn, this._options)
        const constraints = this._addConstraints(structuredType[property])

        flattenedElements.push({column: `${prefix}_${property}`, dataType: dataType, constraints: constraints})
      }
    }
    return flattenedElements
  }

  _association (associationName, element) {
    if (element.foreignKeys) {
      const associationColumns = Object.keys(element.foreignKeys).map((key) => {
        const dataType = convertDataType(this._csn.definitions[element.target].elements[key], this._csn, this._options)
        const constraints = this._addConstraints(this._csn.definitions[element.target].elements[key])

        return {column: `${associationName}_${key}`, dataType: dataType, constraints: constraints}
      })

      return associationColumns
    }
  }

  _addConstraints (element) {
    const notNull = element.notNull === true ? ' NOT NULL' : ''

    if (element.default) {
      const defaultConstraint = typeof element.default === 'string' ? ` DEFAULT '${element.default}'` : ` DEFAULT ${element.default}`
      return `${notNull}${defaultConstraint}`
    }

    return notNull
  }

  _combinePrefixAndElement (element, prefix) {
    return prefix ? `${prefix}_${element}` : element
  }

  _isComplexType (type) {
    return !this._options.typeConversion.get(type) &&
      this._csn.definitions[type] &&
      this._csn.definitions[type].elements
  }

  _elementsForEntity (entity, columnPrefix) {
    let elements = new Map()
    for (const element of Object.keys(entity.elements || {})) {
      if (isAssociation(entity.elements[element])) {
        const association = this._association(element, entity.elements[element])
        if (association) {
          association.forEach((e) => elements.set(e.column, e))
        }
        continue
      }

      if (entity.elements[element].elements) {
        this._flattenStructuredElement(element, entity.elements[element].elements)
          .forEach((e) => elements.set(e.column, e))
        continue
      }

      if (this._isComplexType(entity.elements[element].type)) {
        const complexTypePrefix = this._combinePrefixAndElement(element, columnPrefix)
        this._elementsForEntity(this._csn.definitions[entity.elements[element].type], complexTypePrefix)
          .forEach((e) => elements.set(e.column, e))
        continue
      }

      const columnName = this._combinePrefixAndElement(element, columnPrefix)
      const dataType = convertDataType(entity.elements[element], this._csn, this._options)
      const constraints = this._addConstraints(entity.elements[element])
      elements.set(columnName, {column: columnName, dataType: dataType, constraints: constraints})
    }

    return elements
  }

  _elements () {
    const elements = []

    this._elementsForEntity(this._obj.CREATE.entity).forEach((element) => {
      if (element.dataType !== 'cds.Composition' && element.dataType !== 'cds.Association') {
        elements.push(`${this._quoteElement(element.column)} ${element.dataType}${element.constraints}`)
      }
    })

    const keys = []

    // .keys returns undefined if no keys are available
    const keyElements = cds.reflect(this._obj.CREATE.entity).keys || {}

    for (const key of Object.keys(keyElements)) {
      keys.push(...this._constructKey(key, keyElements[key]).map((key) => this._quoteElement(key)))
    }

    if (elements.length > 0) {
      this._outputObj.sql.push('(', `${elements.join(', ')}${keys.length > 0 ? `, PRIMARY KEY (${keys.join(', ')})` : ''}`, ')')
    }
  }

  _constructKey (key, keyElement) {
    if (isAssociation(keyElement)) {
      return this._association(key, keyElement).map(key => key.column)
    } else if (this._isComplexType(keyElement.type)) {
      return Array.from(this._elementsForEntity(this._csn.definitions[keyElement.type], key).keys())
    } else {
      return [key]
    }
  }

  _as () {
    const as = new this.SelectBuilder(this._obj.CREATE.as).build()
    this._outputObj.sql.push('AS', as.sql)
  }
}

module.exports = CreateBuilder
