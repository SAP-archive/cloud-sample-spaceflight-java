const {resolveAssociation, isAssociation, isComplex} = require('../util/associations')

/**
 * Check if the value is a function or reference to private function.
 * Return if any of the cases are true.
 * @param {string|function} fn -
 * @returns {function}
 * @throws Error
 * @private
 */
const _getMethod = (fn) => {
  if (typeof fn === 'function') {
    return fn
  }

  throw Error(`Method '${fn}' does not exist`)
}

/**
 * Get the entity name from CQN and check if it exists at CSN.
 * @param {Object} csn - Reflected CSN
 * @param {String} from - Entity name
 * @returns {string|undefined}
 * @private
 */
const _getEntityName = (csn, from) => {
  if (!from.ref) {
    return
  }

  const entityName = from.ref[0]

  if (csn.definitions && csn.definitions[entityName]) {
    return entityName
  }
}

const _refs = (refs) => {
  const arr = []
  for (const element of refs) {
    if (element.hasOwnProperty('join')) {
      // multiple join are nested, so we need to find all the table names in there as well
      arr.push(..._extractRefs(element))
    } else {
      arr.push(element)
    }
  }
  return arr
}

const _extractRefs = (from) => {
  if (from.hasOwnProperty('join')) { // cqn with join in from
    return _refs(from.args)
  }

  return [from]
}

const _addMapperFunction = (elements, toService, key, type, from, allCombinations) => {
  if (!toService.has(type)) {
    return
  }

  const convertFunction = _getMethod(toService.get(type))

  // ambiguous cases will lead to SQL syntax errors anyway, so no need for a check
  elements.set(key, convertFunction)

  if (allCombinations) {
    elements.set(`${from.ref.join('.')}.${key}`, convertFunction)
    elements.set(`${from.as}.${key}`, convertFunction)
  }
}

/**
 * Get a map of all possible elements and their mappers.
 * @param {Map} toService - Mapping instructions for data conversions based on CDS data types
 * @param {Object} csn - Reflected CSN
 * @param {Object} cqn - CQN that is used to query the DB.
 * @param {Boolean} [allCombinations] - Include all possible combinations. Defaults to false.
 * @returns {Map<any, any>}
 * @private
 */
const _getElementCombinations = (toService, csn, cqn, allCombinations = false) => {
  const elements = new Map()

  // Get list of available and relevant entities as defined by from
  for (const from of _extractRefs(cqn.SELECT.from)) {
    const entityName = _getEntityName(csn, from)

    if (!entityName) {
      continue
    }

    for (const key of Object.keys(csn.definitions[entityName].elements)) {
      const element = csn.definitions[entityName].elements[key]

      // Complex type
      if (isComplex(element)) {
        for (const complexKey of Object.keys(element.elements)) {
          _addMapperFunction(elements, toService, `${key}_${complexKey}`, element.elements[complexKey].type, from, allCombinations)
        }
      }

      // Flat type
      _addMapperFunction(elements, toService, key, element.type, from, allCombinations)
    }
  }

  return elements
}

const _getCastFunction = ({type}) => {
  switch (type) {
    case 'cds.Boolean':
      return Boolean
    case 'cds.Integer':
      return Number
    default:
      return String
  }
}

/**
 * Get a map of to be converted elements and their conversion functions.
 * @param {Map} toService - Mapping instructions for data conversions based on CDS data types
 * @param {Object} csn - Reflected CSN
 * @param {Object} cqn - CQN that is used to query the DB.
 * @returns {Map<any, any>}
 * @private
 */
const _getMapperForListedElements = (toService, csn, cqn) => {
  const elements = _getElementCombinations(toService, csn, cqn, true)
  const mapper = new Map()

  for (const element of cqn.SELECT.columns) {
    if (element.ref) {
      const joinedName = element.ref.join('.')
      const name = (element.as) ? element.as : joinedName

      if (element.cast) {
        mapper.set(name, _getCastFunction(element.cast))
      } else if (elements.has(joinedName)) {
        mapper.set(name, elements.get(joinedName))
      }
    } else if (element.as && element.cast) {
      mapper.set(element.as, _getCastFunction(element.cast))
    }
  }

  return mapper
}

/**
 * Based on CSN and CQN get a map on how to map the result.
 * @param {Map} toService - Mapping instructions for data conversions based on CDS data types
 * @param {Object} csn - Reflected CSN
 * @param {Object} cqn - CQN that is used to query the DB.
 * @returns {Map<any, any>}
 * @private
 */
const getPostProcessMapper = (toService, csn = {}, cqn = {}) => {
  // No mapper defined or irrelevant as no READ request
  if (!cqn.hasOwnProperty('SELECT')) {
    return new Map()
  }

  if (Array.isArray(cqn.SELECT.columns) && cqn.SELECT.columns.length !== 0) {
    return _getMapperForListedElements(toService, csn, cqn)
  }

  // No element/column specified
  return _getElementCombinations(toService, csn, cqn)
}

/**
 * Transform values for a result row.
 * @param {Object} row - To be converted row.
 * @param {Map} mapper - Instructions, how to transform.
 * @private
 */
const _transformRow = (row, mapper) => {
  /*
   * If mapper is iterated, no iteration at all will happen in case of no mappers.
   * Less iteration as if all row keys would iterated.
   */
  for (const [column, converter] of mapper.entries()) {
    row[column] = converter(row[column])
  }
}

/**
 * Post process the result as given by the db driver.
 * @param {*} result - The result as returned by the db driver.
 * @param {Map} dataMapper - Instructions, how to transform.
 * @returns {*}
 * @private
 */
const _postProcessData = (result, dataMapper) => {
  if (Array.isArray(result)) {
    for (let i = 0, length = result.length; i < length; i++) {
      _transformRow(result[i], dataMapper)
    }
  } else if (typeof result === 'object') {
    _transformRow(result, dataMapper)
  }

  return result
}

const _transformProperties = (row, propertyMapper) => {
  for (const key of Object.keys(row)) {
    if (propertyMapper.has(key)) {
      row[propertyMapper.get(key)] = row[key]

      delete row[key]
    }
  }
}

/**
 * Rename the properties.
 * @param {*} result - The result as returned by the db driver.
 * @param {Map} propertyMapper - Instructions, how to transform.
 * @returns {*}
 * @private
 */
const _postProcessProperties = (result, propertyMapper) => {
  if (Array.isArray(result)) {
    for (let i = 0, length = result.length; i < length; i++) {
      _transformProperties(result[i], propertyMapper)
    }
  } else if (typeof result === 'object') {
    _transformProperties(result, propertyMapper)
  }

  return result
}

const _transformBoth = (result, dataMapper, propertyMapper) => {
  if (Array.isArray(result)) {
    for (let i = 0, length = result.length; i < length; i++) {
      _transformProperties(result[i], propertyMapper)
      _transformRow(result[i], dataMapper)
    }
  } else if (typeof result === 'object') {
    _transformProperties(result, propertyMapper)
    _transformRow(result, dataMapper)
  }

  return result
}

const _mapHasEntries = (map) => {
  return (map && map instanceof Map && map.size !== 0)
}

/**
 * Post process the result as given by the db driver.
 * @param {*} result - The result as returned by the db driver.
 * @param {Map} dataMapper - Instructions, how to transform.
 * @param {Map} propertyMapper - Instructions, how to rename properties.
 * @returns {*}
 * @private
 */
const postProcess = (result, dataMapper, propertyMapper) => {
  const hasDataMapper = _mapHasEntries(dataMapper)
  const hasPropertyMapper = _mapHasEntries(propertyMapper)

  if (hasDataMapper && hasPropertyMapper) {
    return _transformBoth(result, dataMapper, propertyMapper)
  }

  if (hasDataMapper) {
    return _postProcessData(result, dataMapper)
  }

  if (hasPropertyMapper) {
    return _postProcessProperties(result, propertyMapper)
  }

  return result
}

const _addToMap = (map, key) => {
  const allUpperKey = key.toUpperCase()

  if (key === allUpperKey) {
    return
  }

  map.set(allUpperKey, key)
}

const _addColumn = (map, from, element) => {
  _addToMap(map, element)

  if (from.ref) {
    _addToMap(map, `${from.ref.join('.')}.${element}`)
  }

  if (from.as) {
    _addToMap(map, `${from.as}.${element}`)
  }
}

const _addAssociationToMap = (map, from, element) => {
  for (const assocName of resolveAssociation(element)) {
    _addColumn(map, from, assocName)
  }
}

const _addComplexTypeToMap = (map, from, name, element) => {
  for (const complexName of Object.keys(element.elements)) {
    _addColumn(map, from, `${name}_${complexName}`)
  }
}

const _getKeyMapForAllElements = (csn, cqn) => {
  const map = new Map()

  // Get list of available and relevant entities as defined by from
  for (const from of _extractRefs(cqn.SELECT.from)) {
    const entityName = _getEntityName(csn, from)

    if (!entityName) {
      continue
    }

    for (const name of Object.keys(csn.definitions[entityName].elements)) {
      const element = csn.definitions[entityName].elements[name]

      if (isAssociation(element)) {
        _addAssociationToMap(map, from, element)
      } else if (isComplex(element)) {
        _addComplexTypeToMap(map, from, name, element)
      } else {
        _addColumn(map, from, name)
      }
    }
  }

  return map
}

const _getKeyMapForListedElements = (cqn) => {
  const map = new Map()

  for (const element of cqn.SELECT.columns) {
    if (element.as) {
      _addToMap(map, element.as)
    } else if (element.ref) {
      _addToMap(map, element.ref.join('.'))
    }
  }

  return map
}

/**
 * Provide a map with to be renamed properties.
 * @param {Object} csn - Reflected CSN
 * @param {Object} cqn - CQN that is used to query the DB.
 * @param {Boolean} convertKeyNames - If the dbc converts columns to uppercase in plain mode, we need to convert back
 * @returns {Map<any, any>}
 */
const getPropertyMapper = (csn, cqn, convertKeyNames) => {
  const {config: {data: {sql_mapping: sqlMapping}}} = require('../cds')

  if (!convertKeyNames || sqlMapping !== 'plain' || !cqn.SELECT) {
    return new Map()
  }

  // No element/column specified
  if (Array.isArray(cqn.SELECT.columns) && cqn.SELECT.columns.length !== 0) {
    return _getKeyMapForListedElements(cqn)
  }

  return _getKeyMapForAllElements(csn, cqn)
}

module.exports = {
  getPropertyMapper,
  getPostProcessMapper,
  postProcess
}
