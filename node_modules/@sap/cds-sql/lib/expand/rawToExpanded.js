const EXPAND = Symbol.for('expand')
const GET_KEY_VALUE = Symbol.for('getKeyValue')
const TO_MANY = Symbol.for('toMany')

class RawToExpanded {
  constructor (configs, results) {
    this._toManyResults = {expand: {}}
    this._result = []
    this._configs = configs
    this._results = results
  }

  /**
   * Parses and converts the raw result set(s) into one single expanded result set.
   * @returns {Array}
   */
  toExpanded () {
    const {queries, mappings} = this._configs

    for (let i = 0, length = this._results.length; i < length; i++) {
      const {_conversionMapper: conversionMapper = new Map(), _toManyTree: toManyTree = []} = queries[i]

      if (toManyTree.length === 0) {
        this._parseMainResult(this._results[i], mappings, conversionMapper, toManyTree)
      } else {
        this._parseExpandResult(this._results[i], mappings, conversionMapper, toManyTree)
      }
    }

    return this._result
  }

  _parseMainResult (result, mappings, conversionMapper, toManyTree) {
    const resultCache = this._getResultCache(toManyTree)

    for (const entry of result) {
      const parsed = this._parseRaw({mappings, toManyTree, conversionMapper, resultCache, entry})

      if (parsed) {
        this._result.push(parsed)
      }
    }
  }

  /**
   * Takes one result row (entry) and converts it into expanded row according to the config at the structureMap.
   * @param {Map} mappings - Config how to structure the entry. Can be nested which will lead to recursion.
   * @param {Map} conversionMapper - Post processing of values like 1/0 to true/false.
   * @param {Object} entry - One row (entry) of the result set.
   * @returns {Object}
   * @private
   */
  _parseRaw ({mappings, toManyTree, conversionMapper, resultCache, entry}) {
    let isEntityNull

    const row = {}

    // A raw row contains more elements than the config. Iterating over config is faster.
    for (const key of Object.keys(mappings)) {
      // To many entries have been already processed and cached
      if (mappings[key][TO_MANY]) {
        row[key] = this._getResultCache(toManyTree.concat(key))[mappings[key][GET_KEY_VALUE](false, entry)] || []

        // Will be true in case of 1:1 expands
      } else if (mappings[key] instanceof Object) {
        const parsed = this._parseRaw({
          mappings: mappings[key],
          toManyTree: toManyTree,
          conversionMapper: conversionMapper,
          resultCache: this._getResultCache(toManyTree.concat(key)),
          entry: entry
        })

        if (parsed) {
          row[key] = parsed
        }

        // No expand convert the result directly.
      } else {
        // The Hana hdb client converts to upper case in plain mode
        const rawValue = entry[mappings[key]] || entry[mappings[key].toUpperCase()]

        row[key] = this._convertValue(rawValue, conversionMapper.get(mappings[key]))

        isEntityNull = this._isNull(isEntityNull, rawValue)
      }
    }

    // No property holds any value. A to null must have failed.
    if (isEntityNull) {
      return
    }

    return row
  }

  /**
   * Check if row entry is null.
   * @param {boolean} isEntityNull - previous state
   * @param {*} value - Value of row entry
   * @returns {boolean}
   * @private
   */
  _isNull (isEntityNull, value) {
    if (isEntityNull === undefined) {
      return (value === null || value === undefined)
    }

    return (isEntityNull === true && (value === null || value === undefined))
  }

  /**
   * Helper to check if value needs to be converted and if yes, apply the conversion function.
   * @param {string|number} value - As received from DB
   * @param {function} converter - To something (Boolean, String, ...) conversion
   * @returns {*}
   * @private
   */
  _convertValue (value, converter) {
    if (converter) {
      return converter(value)
    }

    return value
  }

  _parseExpandResult (result, mappings, conversionMapper, toManyTree) {
    const resultCache = this._getResultCache(toManyTree)
    const expandMapping = this._getExpandMapping(mappings, toManyTree)

    for (const entry of result) {
      const parsed = this._parseRaw({mappings: expandMapping, toManyTree, conversionMapper, resultCache, entry})

      if (parsed) {
        const key = expandMapping[GET_KEY_VALUE](true, entry)

        if (!resultCache[key]) {
          resultCache[key] = []
        }

        resultCache[key].push(parsed)
      }
    }
  }

  _getResultCache (toManyTree) {
    let target = this._toManyResults

    for (const expand of toManyTree) {
      if (!target[expand]) {
        target[expand] = {
          [EXPAND]: {}
        }
      }

      target = target[expand]
    }

    return target
  }

  _getExpandMapping (mappings, toManyTree) {
    let mapping = mappings

    for (const key of toManyTree) {
      mapping = mapping[key]
    }

    return mapping
  }
}

/**
 * Convert N results into one expanded according to configurations.
 * @param {Array} configs - Array of instructions how to combine and expand the 1 to N results
 * @param {Array} results - Same amount of results as configs. Contains one result for each to many expand.
 * @returns {Array} The complete expanded result set.
 */
const rawToExpanded = (configs, results) => {
  return new RawToExpanded(configs, results).toExpanded()
}

module.exports = rawToExpanded
