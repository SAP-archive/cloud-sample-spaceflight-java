'use strict';

/* eslint max-lines:off */
/* eslint max-statements-per-line:off */

const COMPLEXTYPE_TRENNER='_'
let NAVPROP_TRENNER = '_'         // possibly overruled for TNT below
let VALUELIST_NAVPROP_PREFIX = '' // possibly overruled for TNT below

const glue = require('./glue.js')
const deepCopy = require('../base/deepCopy.js')
const Edm = require('./edm.js');
const translate = require('./annotations/genericTranslation.js');
const { setProp } = require('../base/model');

/*
OData V2 spec 06/01/2017 PDF version is available from here:
https://msdn.microsoft.com/en-us/library/dd541474.aspx
*/

/* invocation:
  metadata: csn2edm(forOdata, { version:'v2' })
*/


module.exports = function csn2edm(csn, _options) {

  const options = glue.validateOptions(_options);

  let v = options.v;

  // get us a fresh model copy that we can work with
  let model = JSON.parse(JSON.stringify(csn));
  model.messages = csn.messages;

  let serviceCsn = glue.initializeModel(model, options);
  if(serviceCsn == undefined)
    throw "No Service found in model"

  let navigationProperties = [];

  // FIXME: Temporary special handling for TNT
  if (options && options.tntFlavor)
  {
    if(options.oldstyleSelf)
      Edm.NavigationProperty.OLDSTYLE_SELF='self';
  }

  function baseName(str, del) { let l = str.lastIndexOf(del);   // eslint-disable-line no-unused-vars
    return (l >= 0) ? str.slice(l+del.length, str.length) : str; }

  // if we have a real alias take it, otherwise use basename of service
  // let alias = serviceCsn.alias || baseName(baseName(serviceCsn.name, '::'), '.');

  // FIXME: UI5 cannot deal with spec conforming simpleid alias names
  let alias = serviceCsn.name;

  let Schema = Edm.Schema.create(v, serviceCsn.name, undefined /* unset alias */);

  // now namespace and alias are used to create the fullQualified(name)
  const namespace = serviceCsn.name + '.'
  alias += '.'

  let service = Edm.DataServices.create(v, Schema);
  let edm = Edm.create(v, service);

  /* create the entitytypes and sets, ordinary entities first, parameterized entities last
     V4 containment: Do not create an EntitySet if _containerEntity is set and not equal with the artifact name
  */
  glue.foreach(model.definitions,
    a => glue.isEntityOrView(a) &&
    !a.abstract && a.params == undefined,
      (a,n) => createEntityTypeAndSet(a, n, undefined,
        !a._containerEntity || (a._containerEntity == n)));

  glue.foreach(model.definitions,
    a => glue.isEntityOrView(a) &&
    !a.abstract && a.params != undefined,
      createParmeterizedEntityTypeAndSet);

  // create unbound actions/functions
  glue.foreach(model.definitions, glue.isActionOrFunction,
               (options.isV4()) ? createActionV4 : createActionV2);

  // create the complex types
  glue.foreach(model.definitions, glue.isStructuredType, createComplexType);

  if(options.isV4())
  {
    glue.foreach(model.definitions,
      artifact => glue.isDerivedType(artifact) &&
      !glue.isAssociationOrComposition(artifact),
        createTypeDefinition);
  }

  navigationProperties.forEach(np => {
    if(options.isV4()) {
      // V4: No referential constraints for Containment Relationships
      if(!np.isContainment())
        np.addReferentialConstraintNodes();
    }
    else
      addAssociation(np);
  });

  createAnnotations(edm);

  if(Schema._ec._children.length == 0)
    throw "EntityContainer must contain at least one EntitySet"

  return edm

  //--------------------------------------------------------------------------------
  // embedded functions
  //--------------------------------------------------------------------------------

  function createParmeterizedEntityTypeAndSet(entityCsn, entityName)
  {
    // Naming rules
    // Parameters: EntityType <ViewName>Parameters, EntitySet <ViewName>
    //             with NavigationProperty "Results" pointing to the entity set of type <ViewName>Type
    // Result:     EntityType <ViewName>Result, EntitySet <ViewName>Results

    let parameterCsn = { name : entityName+'Parameters', elements : Object.create(null) };

    // copy over parameters and remove kind:param
    let idx = 0;
    glue.forAll(entityCsn.params, (p,n) => {
      let elt = deepCopy(p);
      elt.name = n;
      delete elt.kind;
      parameterCsn.elements[n] = elt;
      idx = (p.indexNo > idx) ? p.indexNo : idx;
    });

    entityCsn.name = entityCsn.name+'Result';
    // add assoc to result set, FIXME: is the cardinality correct?
    parameterCsn.elements['Results'] = {
      '@odata.contained':true,
      name: 'Results',
      target: entityCsn,
      type: 'cds.Association',
      indexNo: ++idx
    };

    createEntityTypeAndSet(parameterCsn, parameterCsn.name, entityName);

    // in V4 result entity set is implicitly provided via NavigationProperty:ContainsTarget
    createEntityTypeAndSet(entityCsn, entityCsn.name, entityCsn.name+'s', options.isV2());
  }

  function createEntityTypeAndSet(entityCsn, entityName, setName=undefined, createEntitySet=true)
  {
  // EntityType attributes are: Name, BaseType, Abstract, OpenType, HasStream
    // Sub Elements are: Key, Property, NavigationProperty

    let EntityTypeName = entityName.replace(namespace, '');
    let EntitySetName = setName || EntityTypeName;
    let fqEntityTypeName = fullQualified(entityName);

    let [ properties, hasStream ] = createProperties(entityCsn);

    // construct EntityType attributes
    let attributes = { Name : EntityTypeName };

    // CDXCORE-CDXCORE-173
    if(options.isV2() && hasStream)
      attributes['m:HasStream'] = hasStream;

    Schema.append(Edm.EntityType.create(v, attributes, properties, entityCsn));

    if (createEntitySet)
    {
      let entitySet = Edm.EntitySet.create(v, { Name: EntitySetName, EntityType: fqEntityTypeName }, entityCsn);

      // V4: Create NavigationPropertyBinding in EntitySet if NavigationProperty is not a Containment
      if(options.isV4())
        properties.filter(np => np instanceof Edm.NavigationProperty && !np.isContainment()).
          forEach(np => entitySet.append(np.createNavigationPropertyBinding(namespace)));

      Schema._ec.append(entitySet);
    }

    // put actions behind entity types in Schema/EntityContainer
    glue.forAll(entityCsn.actions, (a, n) => {
      (options.isV4()) ? createActionV4(a, n, entityCsn)
                       : createActionV2(a, n, entityCsn)
    });
  }

  // add bound/unbound actions/functions for V4
  function createActionV4(actionCsn, name, entityCsn=undefined)
  {
    let iAmAnAction = actionCsn.kind == "action";

    let actionName = actionCsn.name.replace(namespace, '');

    let attributes = { Name: actionName, IsBound : false };

    if(!iAmAnAction)
      attributes.IsComposable = false;

    let actionNode = (iAmAnAction) ? Edm.Action.create(v, attributes)
                                   : Edm.FunctionDefinition.create(v, attributes);

    if(entityCsn != undefined)
    {
      actionNode.IsBound = true;
      // Binding Parameter: 'in' at first position in sequence, this is decisive!
      actionNode.append(Edm.Parameter.create(v, { Name: "in", Type: fullQualified(entityCsn.name) }, {} ));
    }
    else // unbound
    {
      let actionImport = iAmAnAction ? Edm.ActionImport.create(v, { Name: actionName, Action : fullQualified(actionName) })
                                     : Edm.FunctionImport.create(v, { Name: actionName, Function : fullQualified(actionName) });

      let rt = actionCsn.returns && (actionCsn.returns.type || actionCsn.returns.items.type);
      if(rt) // add EntitySet attribute only if return type is a non abstract entity
      {
        let definition = model.definitions[rt];
        if(definition && definition.kind == 'entity' && !definition.abstract)
        {
          actionImport.EntitySet = rt.replace(namespace, '');
        }
      }
      Schema._ec.append(actionImport);
    }

    // Parameter Nodes
    glue.forAll(actionCsn.params, (parameterCsn, parameterName) => {
      actionNode.append(Edm.Parameter.create(v, { Name: parameterName }, parameterCsn ));
    });

    // return type if any
    if(actionCsn.returns)
    {
      actionNode._rtNode = Edm.ReturnType.create(v, actionCsn.returns, fullQualified);
    }
    Schema.append(actionNode);
  }

  // add bound/unbound actions/functions for V2
  function createActionV2(actionCsn, name, entityCsn=undefined)
  {
    let functionImport = Edm.FunctionImport.create(v, { Name: name.replace(namespace, '') } );

    // inserted now to maintain attribute order with old odata generator...
    /*
      V2 says (p33):
      * If the return type of FunctionImport is a collection of entities, the EntitySet
        attribute is defined.
      * If the return type of FunctionImport is of ComplexType or scalar type,
        the EntitySet attribute cannot be defined.
      The spec doesn't mention single ET: Ralf Handls confirmed that there is a gap
      in the spec and advised mention it as in V4
    */

    let rt = actionCsn.returns && (actionCsn.returns.type || actionCsn.returns.items.type);
    if(rt) // add EntitySet attribute only if return type is an entity
    {
      let defintion = model.definitions[rt];
      if(defintion && glue.isEntityOrView(defintion))
      {
        functionImport.EntitySet = rt.replace(namespace, '');
      }
    }

    if(actionCsn.returns)
      functionImport.ReturnType = getReturnType(actionCsn);

    if(actionCsn.kind == 'function')
      functionImport.setXml( {'m:HttpMethod': 'GET' });
    else if(actionCsn.kind == 'action')
      functionImport.setXml( {'m:HttpMethod': 'POST'});
    else
      throw "Please debug me: Neither function nor action";

    if(entityCsn != undefined)
    {
      // Make bound function names always unique as per Ralf's recommendation

      functionImport.setXml( {'sap:action-for': fullQualified(entityCsn.name) } );

      // Binding Parameter: Primary Keys at first position in sequence, this is decisive!
      glue.foreach(entityCsn.elements,
        elementCsn => elementCsn.key && !glue.isAssociationOrComposition(elementCsn),
        (elementCsn, elementName) => {
          functionImport.append(Edm.Parameter.create(v, { Name: elementName }, elementCsn, 'In' ));
        }
      );
    }

    // is this still required?
    for (let p in actionCsn)
      if (p.match(/^@sap./)) 
        functionImport.setXml( { ['sap:' + p.slice(5).replace(/\./g, '-')] : actionCsn[p] });

    // then append all other parameters
    glue.forAll(actionCsn.params, (parameterCsn, parameterName) => {
      functionImport.append(Edm.Parameter.create(v, { Name: parameterName }, parameterCsn, 'In' ));
    });

    Schema._ec.append(functionImport);
  }

  function getReturnType(action)
  {
    // it is safe to assume that either type or items.type are set
    let type = action.returns && (action.returns.type || action.returns.items.type);
    if(type && type.startsWith('cds.'))
      type = glue.mapCdsToEdmType(type, options.isV2());

    if(type && action.returns.items)
      type = `Collection(${type})`

    return type;
  }

  // returns a [ [ Edm Properties ], boolean hasStream ]
  // array of Edm Properties
  // boolean hasSstream : true if at least one element has @Core.MediaType assignment
  function createProperties(parentCsn, prefix='')
  {
    let props = [];
    let hasStream = false;
    glue.forAll(parentCsn.elements, (elementCsn, elementName) =>
    {
      setProp(elementCsn, '_parent', parentCsn);

      if(glue.isAssociationOrComposition(elementCsn))
      {
        // Foreign keys are part of the generic elementCsn.elements property creation

        // This is the V4 edmx:NavigationProperty
        // gets rewritten for V2 in addAssocations()

        // suppress navprop creation only if @odata.navigable:false is not annotated.
        // (undefined !== false) still evaluates to true
        if (elementCsn['@odata.navigable'] !== false)
        {
          let navProp = Edm.NavigationProperty.create(v, {
            Name: elementName,
            Type: fullQualified(elementCsn.target.name)
          }, elementCsn);

          props.push(navProp);
          // save the navProp in the global array for late constraint building
          navigationProperties.push(navProp);
        }
      }
      else if(glue.isStructuredArtifact(elementCsn))
      {
        // TODO: Makeover anonymous structured types
        let anonymousComplexType = createAnonymousComplexType(elementCsn, prefix);
        props.push(Edm.Property.create(v, {
          Name: elementCsn.name,
          Type: fullQualified(anonymousComplexType.Name)
        }, elementCsn));
      }
      else
      {
        // CDXCORE-CDXCORE-173
        // V2: filter  @Core.MediaType
        // V4: filter foreignKey elements of Container associations
        let isContainerFK = elementCsn['@odata.foreignKey4'] &&
          parentCsn.elements[elementCsn['@odata.foreignKey4']]._isToContainer;

        if(!(options.isV2() && elementCsn['@Core.MediaType']) &&
           !(options.isV4() && isContainerFK))
          props.push(Edm.Property.create(v, { Name: elementName }, elementCsn));
        else
        {
          hasStream = true;
          // CDXCORE-CDXCORE-177: remove elementCsn from elements dictionary
          delete parentCsn.elements[elementName];
        }
      }
    });
    return [ props, hasStream ];
  }

  function createAnonymousComplexType(element, prefix = '') {
    // Add named ComplexType as auxiliary for anonyous inner struct
    let name = element.name.replace(namespace, '')

    // array of complex type not yet allowed
    let typecsn = /*element.items ||*/ element;

    let type = new Edm.ComplexType({
      Name: prefix.replace(/\//g, COMPLEXTYPE_TRENNER) + name
    }).append(
      ...(createProperties(typecsn, prefix + name + '/')[0])
      );
    
    // collect anonymous complex type in Auxiliaries array, they will
    // be added to the Schema later in createComplexType...
    (Schema.Auxillaries || Schema.set({
      Auxillaries: []
    }).Auxillaries).push(type)
    return type
  }

  function createComplexType(structuredTypeCsn) 
  {
    // V4 attributes: Name, BaseType, Abstract, OpenType
    let attributes = { Name: structuredTypeCsn.name.replace(namespace, '') };

    let complexType = Edm.ComplexType.create(v, attributes, structuredTypeCsn);
    let elementsCsn = structuredTypeCsn.items || structuredTypeCsn;
    complexType.append(...(createProperties(elementsCsn)[0]));
    Schema.append(complexType);

    // append new anonymous complex types to the schema (and overwrite existing ones...)
    if (Schema.Auxillaries)
    {
      Schema.append(...Schema.Auxillaries)
    }
  }

  // V4 <TypeDefintion>
  function createTypeDefinition(typeCsn)
  {
    // derived types are already resolved to base types
    let typeDef;
    let props = { Name: typeCsn.name.replace(namespace, '') };
    if((typeCsn.items && typeCsn.items.enum) || typeCsn.enum)
      typeDef = Edm.EnumType.create(v, props, typeCsn);
    else
      typeDef = Edm.TypeDefinition.create(v, props, typeCsn );
    Schema.append(typeDef);
  }

  /*
   * addAssociation() constructs a V2 association.
   * In V4 all this has been simplified very much, the only thing actually left over is
   * <ReferentialConstriant> that is then a sub element to <NavigationProperty>.
   * However, referential constraints are substantially different to its V2 counterpart,
   * so it is better to reimplement proper V4 construction of<NavigationProperty> in a separate
   * function.
   *
   * This method does:
   * rewrite <NavigationProperty> attributes to be V2 compliant
   * add <Association> elements to the schema
   * add <End>, <ReferentialConstraint>, <Dependent> and <Principal> sub elements to <Association>
   * add <AssociationSet> to the EntityContainer for each <Association>
   */
  function addAssociation(navigationProperty)
  {
    let constraints = navigationProperty._referentialConstraints;
    let parentName = navigationProperty._csn._parent.name.replace(namespace, '');
    let assocName = parentName + NAVPROP_TRENNER + navigationProperty.Name.replace(VALUELIST_NAVPROP_PREFIX, '');

    let fromRole = parentName;
    let toRole = navigationProperty.Type.replace(alias, ''); // <= navprops type should be prefixed with alias
  
    let fromEntityType = fromRole;
    let toEntityType = toRole;

    // from and to roles must be distinguishable (in case of self association entity E { toE: association to E; ... })

    if(fromRole === toRole) {
      if(constraints._originAssocCsn)
        fromRole += '1';
      else
        toRole += '1';
    }

    let navPropFromRole = fromRole;
    let navPropToRole = toRole;

    // remove V4 attributes
    if(navigationProperty.Type != undefined)
      delete navigationProperty.Type;
    /* V2 erwaehnt kein Nullable genauso wie fuer Properties, TNT hats aber drin...
    if(navigationProperty.Nullable != undefined)
      delete navigationProperty.Nullable;
    */
    if(navigationProperty.Partner != undefined)
      delete navigationProperty.Partner;
    if(navigationProperty.ContainsTarget != undefined)
      delete navigationProperty.ContainsTarget;

    /*
      If NavigationProperty is a backlink association (constraints._originAssocCsn is set), then there are two options:
      1) Counterpart NavigationProperty exists and is responsible to create the edm:Association element which needs to
        be reused by this backlink association.
      2) Counterpart NavigationProperty does not exist (@odata.navigable:false), then the missing edm:Association element
        of the origin association needs to be created as if it would have been already available in case (1).
     */

    let reuseAssoc = false;
    if(constraints._originAssocCsn)
    {
      // This is a backlink, swap the roles and types, rewrite assocName
      [ fromRole, toRole ] = [ toRole, fromRole ];
      [ fromEntityType, toEntityType ] = [ toEntityType, fromEntityType ];

      parentName = constraints._originAssocCsn._parent.name.replace(namespace, '');
      assocName = parentName + NAVPROP_TRENNER + constraints._originAssocCsn.name.replace(VALUELIST_NAVPROP_PREFIX, '');
      navigationProperty.Relationship = fullQualified(assocName)

      reuseAssoc = !!constraints._originAssocCsn._NavigationProperty;
      constraints = navigationProperty.getReferentialConstraints(constraints._originAssocCsn);
    }

    // add V2 attributes to navigationProperty
    navigationProperty.Relationship = fullQualified(assocName);
    navigationProperty.FromRole = navPropFromRole;
    navigationProperty.ToRole = navPropToRole;

    if(reuseAssoc)
      return;

    // create Association and AssociationSet if this is not a backlink association
    let association = Edm.Association.create(v, { Name: assocName },
                                    [ fromRole, fullQualified(fromEntityType) ],
                                    [ toRole, fullQualified(toEntityType) ],
                                    constraints.multiplicity );

    // Add ReferentialConstraints if any
    if(Object.keys(constraints.constraints).length > 0)
      association.append(Edm.ReferentialConstraint.createV2(v,
        navigationProperty.FromRole, navigationProperty.ToRole, constraints.constraints));

    Schema.append(association);

    let assocSet = Edm.AssociationSet.create(v, { Name: assocName, Association: fullQualified(assocName) },
      fromRole, toRole, fromEntityType, toEntityType);
    Schema._ec.append(assocSet);
  }

  // produce a full qualified name replacing the namespace with the alias (if provided)
  function fullQualified(name) 
  {
    if (name == serviceCsn.name)
      return Schema.Alias
    else
      return alias + name.replace(namespace, '')
  }
    
  function createAnnotations(edm)
  {
    let annoEdm;
    if(options && options.tntFlavor)
    {
      options.suppressMessages = true;
    }
    annoEdm = translate.csn2annotationEdm(model, options);
    
    for(let i = 0; i < annoEdm.getSchemaCount(); i++)
    {
      edm.setAnnotations(annoEdm.getAnnotations(i), i);
    }
  }
}
