const parseXml = require('./xmlParserWithLocations');
const validator = require('./edmx2csnNewValidation');

// Predefined augmented csn parts
const augmented = {
  extensions: () => {
    return {
      kind: "source",
      extensions: [],
      messages: [],
      $frontend: 'xml',
    }
  },
  extension: (key, location) => {
    return {
      location,
      name: { path: [{ id: key, location }], location },
      annotationAssignments: [],
      kind: 'annotate'
    }
  }
}

/*

  The generator takes an xml file as an input and generates augmented csn extenstions as per the content.
  The logic assumes that the xml content is a valid edmx one, e.g. has 'Annotations' tags with 'Target' attributes
  and those 'Annotations' tags have 'Annotation' tags for children.

*/
function edmx2csn(src, filename) {
  let source = parseXml(src, filename);

  // create the skeleton for the augmented result
  let csn = augmented.extensions();

  // call 'processAnnotationsTag' method for each "Annotations" tag from the
  // input xml tree(the declarations in interest lie there)
  forEachAnnotationsTag(source);
  return csn;

  // goes recursively through the parsed xml object and call process the 'Annotations' tags
  function forEachAnnotationsTag(obj) {
    if (obj === null)
      return;
    for (let prop in obj) {
      if (prop === 'Annotations') {
        processAnnotationsTag(obj[prop], csn);
      }
      obj[prop].forEach(elem => forEachAnnotationsTag(elem));
    }
  }
}

// Each 'Annotations' tag has an attribute 'Target' denoting the artifact from the model to be annotated.
// This method creates the extension for this artifact with the content from the child 'Annotation' tag(s)
// for each 'Annotations' tag from the xml input.
function processAnnotationsTag(annotations, csn) {
  // loop through all the 'Annotations' tags in the source
  annotations.forEach(obj => {
    // the value has the form of 'ServiceName.EntityName[/elem1/elem2]'
    let elements = obj._attributes.Target.split('/');
    let topLevelArt = elements.shift(); // get the top level targeted artifact

    // 1. Determine which artifact to be annotated by the 'Target' attribute
    // look if there is an extension for this top level artifact already
    let toBeAnnotated = csn.extensions.find(ext => ext.name.absolute === topLevelArt);
    if (!toBeAnnotated) { // if not -> create one
      toBeAnnotated = augmented.extension(topLevelArt, obj._location);
      csn.extensions.push(toBeAnnotated);
    }
    // The extension to be annotated can be also a child element of a top level artifact
    elements.forEach(elem => {
      toBeAnnotated.elements = toBeAnnotated.elements || Object.create(null);
      toBeAnnotated = toBeAnnotated.elements[elem]
        ? toBeAnnotated.elements[elem]
        : toBeAnnotated.elements[elem] = augmented.extension(elem, obj._location);
    })

    // 2. Generate and assign the augmented annotations for this specific 'Target'
    // loop through all the 'Annotation' tags under an 'Annotations' tag
    // and assign the augmented form of the annotation
    obj.Annotation.forEach(annotion => {
      Object.assign(toBeAnnotated, augmentedExtensionFromEdmxAnno(annotion, csn.messages, topLevelArt));
    });
  });
}

// takes an 'Annotation' tag object of a parsed xml and creates annotation assignment in the extension from it
// last two arguments(messages, targetName) are used for logging during valdiation of an edmx annotation definition
function augmentedExtensionFromEdmxAnno(anno, messages, targetName) {

  validator.validateTerm(anno._attributes.Term, targetName, anno._location, messages);
  validator.validateType(anno, { term: anno._attributes.Term, target: targetName, messages: messages });

  let parsedAnnos = handleGeneric({ 'Annotation': [anno] });

  let result = Object.create(null);
  let annoName = `@${anno._attributes.Term}${anno._attributes.Qualifier ? `#${anno._attributes.Qualifier}` : ``}`;

  if (parsedAnnos.struct) { //from struct create all the annotations
    // TODO: nested elementes(Record in a Record) check if such a case exists
    Object.keys(parsedAnnos.struct).forEach(a => {
      result[`${annoName}.${a}`] = parsedAnnos.struct[a];
      setNameAndPriority(result[`${annoName}.${a}`], `@${anno._attributes.Term}.${a}`);
    });
  } else {
    result[annoName] = parsedAnnos;
    setNameAndPriority(result[annoName], anno._attributes.Term);
  }

  function setNameAndPriority(obj, name) {
    obj.name = {
      path: name.split('.').map(p => {
        return { id: p, location: anno._location }
      }), location: anno._location
    }
    obj.priority = 'annotate';
  }

  return result;

  // actual parsing of an edmx annotation definition
  function handleGeneric(obj, isCollection = false) {
    // Predefined edmx attributes to csn conversion relations
    const edmxAttrs = {
      Bool: val => {
        return {
          literal: 'boolean',
          val: val === 'true'
        }
      },
      String: val => {
        return {
          literal: 'string',
          val: val
        }
      },
      Decimal: val => {
        return {
          literal: 'decimal',
          val: Number(val)
        }
      },
      Int: val => {
        return {
          literal: 'integer',
          val: Number(val)
        }
      },
      EnumMember: obj => handleEnum(obj),
      Path: obj => handlePath(obj, false),
      NavigationPropertyPath: obj => handlePath(obj, false),
      PropertyPath: obj => handlePath(obj, false)
    }

    if (obj.Annotation)
      return handleAnnotation(obj.Annotation, isCollection);
    if (obj.Record)
      return handleRecord(obj.Record, isCollection);
    if (obj.Collection)
      return handleCollection(obj.Collection);
    if (getPath(obj))
      return handlePath(getPath(obj), isCollection);
    if (obj.PropertyValue)
      return handlePropValue(obj.PropertyValue, isCollection);
    if (obj.String)
      return handleString(obj.String, isCollection);
    else
      return handleValue(obj, isCollection);

    function getPath(obj) {
      return obj.PropertyPath || obj.NavigationPropertyPath || obj.AnnotationPath;
    }

    function handleAnnotation(obj, isCollection) {
      if (isCollection)
        return obj.map(e => handleAnnotation(e, false));
      obj = obj[0] || obj;
      // handle a nested annotation in an annotation
      if (obj.Annotation) {
        // assign the value
        let result = { literal: 'struct', location: obj._location, struct: {} };
        result.struct['$value'] = getPath(obj) ? handlePath(getPath(obj)) : handleValue(obj, false);
        result.struct['$value'].name = { id: '$value', location: obj._location };
        // assign the nested annotations
        obj.Annotation.forEach(anno => {
          let term = anno._attributes.Term;
          result.struct[`@${term}`] = { name: { id: term, location: anno._location } };
          Object.assign(result.struct[`@${term}`], handleGeneric(anno, false));
        });
        return result;
      } else
        return handleGeneric(obj, isCollection);
    }

    function handleRecord(obj, isCollection) {
      if (isCollection)
        return obj.map(e => handleRecord(e, false))
      let record = obj[0] || obj;
      let result = {
        literal: 'struct',
        location: record._location,
        struct: Object.create(null)
      }
      // a record can have as children either PropertyValue or Annotation
      if (record.PropertyValue)
        record.PropertyValue.forEach(prop => {
          Object.assign(result.struct, handlePropValue(prop, false));
        })
      if (record.Annotation)
        record.Annotation.forEach(anno => {
          result.struct[`@${anno._attributes.Term}`] = {
            name: {
              id: `@${anno._attributes.Term}`,
              location: anno._location
            }
          };
          Object.assign(result.struct[`@${anno._attributes.Term}`], handleGeneric(anno, false));
        })
      return result;
    }

    function handleCollection(collection) {
      // edmx annotation cannot have Collection of Collection (checked in Dictionary.json),
      // so will have always one Collection tag as a child tag
      return {
        literal: 'array',
        location: collection[0]._location,
        val: handleGeneric(collection[0], true)
      };
    }

    function handlePath(path, isCollection) {
      if (isCollection)
        return path.map(e => handlePath(e, false))
      return {
        path: (path._text || path).split('/').map(p => { return { id: p, location: obj._location } }),
        location: obj._location
      };
    }

    function handlePropValue(obj, isCollection) {
      if (isCollection)
        return obj.map(e => handlePropValue(e, false))
      let result = { [obj._attributes.Property]: handleGeneric(obj) };
      result[obj._attributes.Property].name = { id: obj._attributes.Property, location: obj._location };
      return result;
    }

    function handleString(obj, isCollection) {
      if (isCollection)
        return obj.map(e => handleString(e, false));
      return Object.assign(edmxAttrs.String(obj._text), obj._location);
    }

    function handleValue(obj, isCollection) {
      if (isCollection)
        return obj.map(e => handleValue(e, false));

      // if (obj._attributes.EnumMember)
      //   return handleEnum(obj._attributes.EnumMember, obj._location)

      let bltnAttr = Object.keys(edmxAttrs)
        .filter(attr => -1 !== Object.keys(obj._attributes).indexOf(attr))[0];
      if (bltnAttr)
        return Object.assign(edmxAttrs[bltnAttr](obj._attributes[bltnAttr]), obj._location);
      return {};
    }

    function handleEnum(enummember, location) {
      // the value contains whitespaces => array
      if (/\s/.test(enummember))
        return { literal: 'array', location, val: enummember.match(/\S+/g).map(e => handleEnum(e, location)) };
      let enumSymbol = enummember.split('/').pop();
      return {
        literal: 'enum',
        symbol: { id: enumSymbol, location },
        location
      }
    }
  }
}

module.exports = edmx2csn;
