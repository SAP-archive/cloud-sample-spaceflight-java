let W = require("./walker");
let nullProtos = require("./nullprotos3.js");

//main entry point
function augment(model) {

  let U = require("./augmentor3utils.js")(model)
  let transformers = require("./augmentor3transormers.js")(model)

  function augmentItems(path, items) {
    transformers.modifyNumber(items, "length", path);
    U.setLocation(items, path);
  }

  function augmentParam(name, node, Path) {
    let path = Path.concat(name)
    U.setLocation(node, path);
  }

  function augmentAction(name, node, Path) {
    let path = Path.concat(name)
    U.setLocation(node, path);
    if(node.returns && node.returns.items) {
      U.setLocation(node.returns.items, path.concat(["returns","items"]));
    }
  }

  function augmentElement(name, node, Path) {
    let path = Path.concat(name)
    U.setLocation(node, path);
    elementName(name, node, path);
    elementKind(node, path);
    emptyAnnotationAssignments(node);

    if(node.items)
      augmentItems(path.concat("items"),node.items)

    // returns an array of nodes where their parents have no protos, skipping the definition name
    function getElementPrefix(path) {
      let R = []
      let parent = model.definitions[path[0]]; // start with the definition
      W.forEach(path, (index,item) => {
        if(!parent) return;
        if(index==="0") return; // ignore the definition
        if(!Object.getPrototypeOf(parent))
          R.push(item)
        parent = parent[item]
      })
      return R;
    }

    function elementName(name, node, path) {
      let nameParts = getElementPrefix(path);
      node.name = {
        id: name,
        element:nameParts[-1]
      };
      U.setLocation(node.name, path.concat(name), U.WILO_FIRST)
    }

    function elementKind(node, path) {
      let kind = "element";
      // special handling for annotate extensions - the element.kind is annotate
      if( path.length>2
          && path[0] === "extensions"
          && model[path[0]][path[1]].kind==="annotate") {
        kind="annotate";
      }
      node.kind = kind;
    }

  }

  function augmentExpression(value, path) {
    return transformers.newValue(value,path)
  }

  function augmentEnumItem(name, node, path) {

    U.setLocation(node, path.concat(name));
    elementName(name, node, path); // reuse function !
    enumKind(node);

    node.value = augmentExpression(node.val, path)
    delete node["val"]

    function elementName(name, node, path) {
      let nameParts = getElementPrefix(path);
      nameParts.push(name)
      node.name = {
        id: name,
        element:nameParts[-1]
      };
      U.setLocation(node.name, path.concat(name), U.WILO_FIRST)
    }

    function getElementPrefix(path) {
      let R = []
      let parent = model.definitions[path[0]]; // start with the definition
      W.forEach(path, (index,item) => {
        if(!parent) return;
        if(index==="0") return; // ignore the definition
        if(!Object.getPrototypeOf(parent))
          R.push(item)
        parent = parent[item]
      })
      return R;
    }

    function enumKind(node) {
      node.kind = "enum";
    }
  }

  function emptyAnnotationAssignments(node) {
    if(!node.hasOwnProperty("annotationAssignments"))
      node.annotationAssignments = [];
  }

  function augmentDefinition(name, def, path) {
    U.setLocation(def, path);
    definitionName(name, def);
    emptyAnnotationAssignments(def);

    if(def.items)
      augmentItems(path.concat("items"),def.items)

    function definitionName(name, def) {
      let sp = name.split(".");
      let last = sp[sp.length-1];
      let sp1 = last.split("::"); //TODO check this split
      last = sp1[sp1.length-1];

      let location = U.newLocation(path, U.WILO_FIRST)
      def.name = {
        id: last, // TODO only for semanticChecks.js/checkGenericConstruct ?
        absolute: name, // TODO only for semanticChecks.js/checkGenericArtifact ?
        location
      }
    } // definitionName
  } // augmentDefinition

  function augmentExtension(key,E,path) {
    let locationObj = U.newLocation(path, U.WILO_FULL)
    if(E.annotate) {
      let location = U.newLocation(path.concat("annotate"), U.WILO_LAST)
      E.kind="annotate",
      E.name={path:[{id:E.annotate,location}],location};
      E.location = locationObj;
      delete E["annotate"]
    }
  }

  // here starts the augmentation

  nullProtos(model, {setAllMissingProtos:true}); // set the protos of dict nodes to null

  // traverse the whole tree and dependent of the node's proto calls the appropriate function
  W.walkWithPath(model, (isNode,PATH,NODE) => {
    let section = PATH[0];
    if(!["definitions","extensions"].includes(section))
      return;
    if (NODE == null || typeof NODE !== 'object') {
      return;
    }
    if(section === "definitions" && PATH.length === 2) // definition
      augmentDefinition(PATH[1], NODE, PATH);
    if(section === "extensions" && PATH.length === 2) // extension
      augmentExtension(PATH[1], NODE, PATH);

    let PROTO = Object.getPrototypeOf(NODE);
    W.forEach(NODE, (key,node) => {
      if(PROTO) {
        let T = transformers[key.charAt(0)==='@' ? '@' : key];
        if(T) {
          T(NODE, key, PATH);
        }
      } else { // dict
        if(getLastElement(PATH) === "elements") {
          augmentElement(key, node, PATH);
        }
        if(getLastElement(PATH) === "enum") {
          augmentEnumItem(key, node, PATH);
        }
        if(getLastElement(PATH) === "params") {
          augmentParam(key, node, PATH);
        }
        if(getLastElement(PATH) === "actions") {
          augmentAction(key, node, PATH);
        }
      }
    }) // forEach
  }) // walkWithPath

  //returns the last element of an array
  function getLastElement(a) {
    return a[a.length-1];
  }

} // function augment

module.exports = {
  augment
};