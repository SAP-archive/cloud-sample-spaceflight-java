let W = require("./walker");
let nullProtos = require("./nullprotos.js");

//main entry point
function augment(model, filename, options = {}) {

  const transformers = {
    '@': modifyAnnotation,
    actions: modifyActions,
    annotationAssignments: ignore, // original with structure values
    kind: ignore,
    location: ignore,
    name: ignore,
    foreignKeys: modifyForeignKeys,
    implicitForeignKeys: ignore,
    type: elementType,
    projection: modifyProjection,
    all: modifyBoolean,
    origin: elementOrigin,
    target: modifyTarget,
    source: modifySource, // for tnt, handled specially to reconstruct 'query'
    path: modifyPath,
    length: modifyNumber,
    precision: modifyNumber,
    scale: modifyNumber,
    sourceMax: modifyValue,
    targetMin: modifyValue,
    targetMax: modifyValue,
    artifacts: ignore,
    dbType: modifyBoolean,
    typeOf: modifyBoolean,
    key: modifyBoolean,
    localized: modifyBoolean,
    value: modifyValue,
    alias: modifyName,
    notNull: modifyBoolean,
    abstract: modifyBoolean,
    masked: modifyBoolean,
    includes: ignoreIncludes,
    sequenceOptions: ignore,    // TODO: currently not in the JSON by HANA
    default: modifyCondOrExpr,
    annoExtensions: ignore,
    extensions: ignore,
    onCond: modifyCondOrExpr,
    redirected: modifyBoolean,
    impl: modifyImpl,
    query: augmentQuery,
    op: modifyOp,
    params: modifyParams,
    func: modifyFunc,
    quantifier: modifyOp
  }

  const WILO_FULL = 0; // location of the first to the last token
  const WILO_FIRST = 1; // location of the first token
  const WILO_LAST = 2; // location of the first token

  function location(node, path, which=WILO_FULL) {
    if(node === undefined)
      return;
    if(node.location) // prevent double augmentation
      throw Error("Double augmentation: " + path.join("/"));
    node.location = newLocation(path, which)
  }

  function point(offset, line, column) {
    return {offset, line, column};
  }

  function newLocation(path, which=WILO_FULL) {
    let locations = model.locations;
    if(locations===undefined) throw Error("no locations");
    if(path===undefined) throw Error("no path");
    let loc = locations.getPathLocation(["definitions"].concat(path));
    if(which === WILO_FULL) {
      return {
        filename: locations.filename,
        start: point(loc.start.start, loc.start.line, loc.start.column),
        end: point(loc.stop.stop+1, loc.stop.line, loc.stop.column)
      }
    }
    if(which === WILO_FIRST) {
      return {
        filename: locations.filename,
        start: point(loc.start.start, loc.start.line, loc.start.column),
        end: point(loc.start.stop+1, loc.start.line, loc.start.column+(loc.start.stop-loc.start.start))
      }
    }
    if(which === WILO_LAST) {
      return {
        filename: locations.filename,
        start: point(loc.stop.start, loc.stop.line, loc.stop.column),
        end: point(loc.stop.stop+1, loc.stop.line, loc.stop.column+(loc.stop.stop-loc.stop.start))
      }
    }
    throw Error("newLocation: wrong modifier: "+which);
  }

  function definitionName(name, def) {
    let absolute = name;
    let sp = name.split(".");
    let last = sp[sp.length-1];
    let sp1 = last.split("::"); //TODO check this split
    last = sp1[sp1.length-1];
    def.name = {id: last, absolute};
    location(def.name, [name], WILO_FIRST);
  }

  function augmentQuery(node, name, path) {
    location(node[name], path.concat(name))
  }

  function modifyFunc(node, name, path) {
    let ipath = path.concat(name);
    node[name]={path:[{id:node[name],location: newLocation(ipath, WILO_LAST)}]}
    location(node[name], ipath);
  }

  function modifyOp(node, name, path) {
    let value = node[name];
    node[name] = {val:value, location:newLocation(path.concat(name))}
  }

  function modifyPath(node, name, path) {
    let value = node[name];
    if(typeof value === "string") {
      let ipath = path.concat(name);
      location(node[name], ipath);
      node[name] = value
        .split('.')
        .map( id => ({ id, location: newLocation(ipath, WILO_LAST) }) );
    }
  }

  function modifyImpl(node, name, path) {
    let value = node[name];
    node[name] = {id:value, location:newLocation(path.concat(name))};
  }

  function modifyBoolean(node, name, path) {
    let value = node[name];
    if(value !== undefined) {
      node[name]={val: value};
      location(node[name], path.concat(name));
      augmented(node[name]);
    }
  }

  function modifyProjection(node,name) {
    if(options.internal)
      node[name].projection = null;
  }

  function isHanaNodeType(node) {
    if(node.type
        && node.type.absolute
        && node.type.absolute.startsWith("hana."))
      return true;
    return false;
  }

  function modifyNumber(node,name,path) {
    if(isAugmented(node[name]))
      return;
    let value=node[name];
    if(value !== undefined) {
      node[name]={val: value,literal:"number"};
      augmented(node[name]);
      if(!isHanaNodeType(node) || value!==0) // TODO remove this if and add location for hana.ST_XXXX and there the length property
        location(node[name],path.concat(name),WILO_LAST);
    }
  }

  function isAugmented(node) {
    if(!node) return false;
    return node.augmented===true;
  }

  // hidden property "augmented" which prevents recursive augmentation
  function augmented(node) {
    if(node===null) return;
    if(node.augmented!==undefined) throw Error("Internal property 'augmented' already exists");
    Object.defineProperty(node, "augmented", {
      enumerable: false,
      writable: false,
      value: true
    });
  }

  function elementKind(node) {
    node.kind = "element";
  }
  function enumKind(node) {
    node.kind = "enum";
  }

  function elementType(node, name, path) {
    let t = node.type;
    if(t && (typeof t === "string")) {
      let loc = newLocation(path.concat(name), WILO_LAST)
      let sp = t.split("..")
      let ids=[sp[0]]
      if(sp[1]) {
        ids = ids.concat(sp[1].split("."))
      }
      node.type={
        path: ids.map( X => {
          return { id:X, location:loc };
        }),
        location: loc
      }
      node.type.absolute=t;//TODO remove absolute
      if(sp[1])
        node.type.element=sp[1]; // TODO what?
      internalPath(node.type)
    }
    else if(t && (typeof t === "object")) {
      internalPath(node.type)
      location(node.type, path.concat(name));
    }
  }

  // returns an array of nodes where their parents have no protos, skipping the definition name
  function getElementPrefix(path) {
    let R = []
    let parent = model.definitions[path[0]]; // start with the definition
    W.forEach(path, (index,item) => {
      if(!parent) return;
      if(index==="0") return; // ignore the definition
      if(!Object.getPrototypeOf(parent))
        R.push(item)
      parent = parent[item]
    })
    return R;
  }

  function elementName(name, node, path) {
    let nameParts = getElementPrefix(path);
    nameParts.push(name)
    node.name = {id: name, element:nameParts.join(".")};
    location(node.name, path.concat(name), WILO_FIRST)
  }

  function ignore() {
  }

  function internalPath(node) {
    if(options.internal)
      node.path = null;
  }

  function modifyName(node, name, path) {
    node[name] = {
      absolute: node[name],
      location: newLocation(path.concat(name))
    }
    internalPath(node[name])
  }

  function modifyValue(node,name,path) {
    let value = newValue(node[name], path.concat(name))
    if(value!==undefined)
      node[name] = value;
  }

  function ignoreIncludes() {
  }

  function isObject(o) {
    return typeof o == 'object';
  }

  function isArray(o) {
    return isObject(o) && Array.isArray(o);
  }

  function _modifyCondOrExprRecursive(obj,path) {
    if(isArray(obj)) {
      return obj.map((X,I) => _modifyCondOrExprRecursive(X,path.concat(I)));
    }

    let op=obj.op;
    let args=obj.args;
    if (op!==undefined && args!==undefined) {
      if(isArray(args)) {
        obj.args=args.map((X,I) => _modifyCondOrExprRecursive(X,path.concat(["args",I])));
      } else {
        throw Error("Unknown structure")
      }
      location(obj,path);
      return obj;
    } else {
      let ravno = obj["="];
      if(ravno) {
        delete obj["="];
        obj.path=ravno.split(".").map(X => {
          return {
            id: X,
            location: newLocation(path.concat("="), WILO_LAST)
          }
        })
        location(obj,path);
        return obj;
      } else {
        return newValue(obj,path);
      }
    }
  }

  function modifyCondOrExpr(node,name,path) {
    node[name] = _modifyCondOrExprRecursive(node[name], path.concat(name));
  }

  function augmentElement(name, node, path) {
    location(node, path.concat(name));
    elementName(name, node, path);
    elementKind(node);

    augmentElementProps(name, node, path);

    if(node.items)
      augmentItems(path.concat([name,"items"]),node.items)

  }

  function augmentEnumItem(name, node, path) {
    location(node, path.concat(name));
    elementName(name, node, path); // reuse function !
    enumKind(node);
  }

  function augmentItems(path, items) {
    modifyNumber(items, "length", path);
    location(items, path);
  }

  function elementOrigin(node, name, path) {
    if(node.origin === undefined)
      return;
    if(node.origin === null)
      return;
    let sp = node.origin.split("..")
    node.origin = {absolute:sp[0],element:sp[1],id:sp[1]} //TODO why sp[1] twice?
    location(node.origin, path.concat(name));
    internalPath(node.origin);
  }

  function modifyTarget(node, name, path) {
    let location = newLocation(path.concat(name))
    node.target = {
      path: [
        {
          id:node.target,
          location
        }
      ],
      location
    };
  }

  function modifySource(node, name, path) {
    /* TODO uncomment and test
    node.query ={
      op:
       {
         val: 'query' },
      from:
       [ { path:
            [ { id: node.source } ] } ],
      all:
       { value: true },
      elements: {}
     }
     */
    if(options && options.augmentor && options.augmentor.oldProjections) {
      node.source = {absolute:node.source, path:[{id:node.source}]}
      location(node.source, path.concat(name), WILO_LAST);
    } else if(node.kind==="entity") {
      delete node["source"]
      node.elements = Object.create(null);
    } else if(node.kind==="view") {
      node.source = {absolute:node.source, path:[{id:node.source}]} //TODO remove absolute
      location(node.source, path.concat(name), WILO_LAST);
    } else {
      throw Error("Unknown kind: " + node.kind)
    }
  }

  function elementCardinality(el, name, path) {
    let lpath = path.concat([name,"cardinality"]);
    let cardinality= el.cardinality;
    if(cardinality) {
      location(cardinality, lpath);
      if(cardinality.targetMin !== undefined) {
        if(cardinality.targetMin === "*")
          cardinality.targetMin = newValueAnonym(cardinality.targetMin, lpath.concat("targetMin"), WILO_LAST);
        else
          modifyNumber(cardinality, "targetMin", lpath);
      }
      if(cardinality.targetMax !== undefined) {
        if(cardinality.targetMax === "*")
          cardinality.targetMax = newValueAnonym(cardinality.targetMax, lpath.concat("targetMax"), WILO_LAST);
        else
          modifyNumber(cardinality, "targetMax", lpath);
      }
    }
  }

  function augmentElementProps(name, node, path) {
    elementCardinality(node, name, path);
  }

  function newAnnotation(anAnno, aValue, path) {
    if (aValue instanceof Object && 'literal' in aValue)
      throw new Error('strange re-run')
    let name = {};
    internalPath(name);
    location(name, path.concat(anAnno), WILO_FIRST);
    let ret = {};
    if(aValue!==true && aValue!==undefined)
      ret = newValue(aValue, path.concat(anAnno));
    ret.name = name;
    internalPath(ret);
    return ret;
  }

  // calls newValue without the "name" parameter
  function newValueAnonym(a, b, c=WILO_FULL) {
    return newValue(a,b,undefined,c)
  }

  function newValue(val, path, name, which=WILO_FULL) {
    // TODO for all: do more checks on correct values, especially with "object"
    if(val===undefined)
      return undefined;
    if(isAugmented(val))
      return undefined;
    let ret;
    let literal = typeof val; // TODO
    if(val===null) {
      ret = { literal: 'null', val };
    }
    else if(Array.isArray(val)) { // process array
      ret = { literal: 'array',
        val: val.map((V,I) => newValue( V, path.concat(''+I) ) )
      };
    }
    else if(literal !== "object") {  // number, string
      ret = { literal, val };
    }
    else if ('#' in val) {      // TODO: length / other property test?
      ret = { literal: 'enum', symbol: { id: val['#']} };
    }
    else if ('=' in val) {    // TODO: length / other property test?
      ret = { path: val['='].split('.').map( id => ({ id }) ) };
    }
    else {
      let struct = {};// TODO why not -> Object.create(null);
      ret = { literal: 'struct', struct };
      W.forEach(val, (K,V) => {
        struct[K] = newValue(V, path.concat(K), K);
      })
    }
    if(name) {
      ret.name = {id:name};
      location(ret.name, path);
    }
    location(ret, path, which);
    if(ret.symbol)
      location(ret.symbol, path);
    augmented(ret)
    return ret;
  }

  function simpleName(N, O, P, which) {
    O.name = {id:N, location: newLocation(P,which)}
  }

  function modifyParams(o,n,p) {
    W.forEach(o.params, (N,O) => {
      let ipath = p.concat(["params",N])
      location(O, ipath);
      simpleName(N,O,ipath,WILO_FIRST);
      O.name.param = N;
    })
  }

  function modifyActions(o,n,p) {
    if(!o.actions)
      return;
    W.forEach(o.actions, (N,O) => {
      let ipath = p.concat(["actions",N])
      location(O, ipath);
      simpleName(N,O,ipath,WILO_FIRST);
      O.name.action = N;
    })
  }

  function nullServiceArtifacts(node) {
    if(node.kind === "service")
      if(node.artifacts === undefined)
        node.artifacts = null;
  }

  function modifyAnnotation(node, key, path) {
    node[key] = newAnnotation(key, node[key], path);
  }

  function newInclude(name, path) {
    let ret = {
      location: newLocation(path),
      absolute: name
    }
    internalPath(ret);
    return ret;
  }

  function augmentDefinitionIncludes(def, path) {
    let includes = def.includes;
    if(includes === undefined)
      return;
    W.forEach(includes, (I,N) => {
      includes[I] = newInclude(N, path.concat(["includes",I]));
    })
  }

  function modifyForeignKeys(O, N, P) {
    augmentForeignKeys(P[0], O[N], getElementPrefix(P), P)
  }

  function augmentForeignKeys(defName, foreignKeys, elementPrefix, path) {
    W.forEach(foreignKeys, (fkName, obj) => {
      let ipath = path.concat(["foreignKeys",fkName]);
      obj.name = {id:fkName, absolute: defName, element: elementPrefix.concat(fkName).join(".")}
      obj.kind = "key";
      let loc = newLocation(ipath.concat("path"));
      location(obj.name, ipath, WILO_FIRST);
      location(obj, ipath);

      //build targetPath out of path
      let targetPath =  obj.path.split(".")
        .map(X => { return {id:X,location:loc}; });
      delete obj["path"];
      obj.targetElement = {path:targetPath,location:loc};
    })
  }

  function augmentActionParams(params, path) {
    W.forEachObject(params, (name,param) => {
      param.name = {id:name}
      location(param.name, path.concat("params",name), WILO_FIRST);
    })
  }

  function augmentDefinition(name, def) {
    let path = [name]
    definitionName(name, def);

    location(def, path);
    augmentDefinitionIncludes(def, path);
    nullServiceArtifacts(def);

    if(def.items)
      location(def.items, path)

    if(def.params && def.kind && def.kind == "action")
      augmentActionParams(def.params, path)
  }

  // here starts the augmentation

  nullProtos(model, {setAllMissingProtos:true}); // set the protos of dict nodes to null

  // traverse the whole tree and dependent of the node's proto calls the appropriate function
  W.walkWithPath(model.definitions, (isNode,PATH,NODE) => {
    if (NODE == null || typeof NODE !== 'object') {
      return;
    }

    if(PATH.length === 1) // definition
      augmentDefinition(PATH[0], NODE);
    
    let PROTO = Object.getPrototypeOf(NODE);
    W.forEach(NODE, (key,node) => {
      if(PROTO) {
        let T = transformers[key.charAt(0)==='@' ? '@' : key];
        if(T && !isAugmented(NODE))
          T(NODE, key, PATH);
      } else { // dict
        if(getLastElement(PATH) === "elements") {
          augmentElement(key, node, PATH);
        }
        if(getLastElement(PATH) === "enum") {
          augmentEnumItem(key, node, PATH);
        }
      }
    })
  })

  //returns the last element of an array
  function getLastElement(a) {
    return a[a.length-1];
  }

} // function augment

module.exports = {
  augment
};
