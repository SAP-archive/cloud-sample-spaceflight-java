// Transform augmented CSN into compact "official" CSN

'use strict';

const { queryOps } = require('../base/model');

// in main:
// const { compactModel: compactSortedJson } = require('./json/to-csn')

//var strict = false;

// dictionary:
// exclude
// namedArgs/arrowedArgs: insertOrderDict
// struct: insertOrderDict

var csn_gensrc = true;          // good enough here...

const transformers = {
  '@': value,
  '$': ignore,
  annotationAssignments: ignore, // TODO: make it $annotations
  artifacts: ignore,             // almost just $artifacts
  blocks: ignore,                // TODO: make it $blocks
  indexNo: ignore,               // TODO XSN: remove
  queries: ignore,               // TODO: make it $queries
  location: ignore,
  // future ------------------------------------------------------------------
  quoted: ignore,               // really?  What about CURRENT_DATE vs "CURRENT_DATE"?
  // members -----------------------------------------------------------------
  extensions: standard,  // is array - TODO: sort
  actions: nonEmptyDict,
  elements,
  enum: insertOrderDict,
  foreignKeys: renameTo( 'keys', dictAsArray ), // XSN: rename?
  mixin: insertOrderDict,       // only in queries with special handling
  params: insertOrderDict,
  // different XSN later -----------------------------------------------------
  _typeIsExplicit: ignore,
  calculated: ignore,            // later in name: $inferred: 'as'
  implicitForeignKeys: ignore,   // later in assoc: $inferred: { foreignKeys: 'fk' } or $inferred on each fk
  origin: ignore,                // remove (introduce non-enum _origin link)
  projection: ignore,            // later in entity: $syntax: 'projection'
  source: ignore,                // remove
  viaAll: ignore,                // TODO remove, later in elem: $inferred: '*'
  // general properties of constructs ----------------------------------------
  abstract: value,
  dbType: value,                // TODO: currently with --hana-flavor only
  default: expression,
  impl: a => a,                 // not yet obsolete - still required by toHana (FIXME: maybe rename to $impl, or try to keep the annotation?)
  _ignore: a => a,              // not yet obsolete - still required by toHana (FIXME: maybe rename to $ignore, or use an annotation instead?)
  key: value,
  localized: value,
  kind: filterKind,
  name: annotationName,
  virtual: value,
  notNull: value,
  masked: value,
  returns: standard,            // storing the return type of actions
  // type properties ---------------------------------------------------------
  cardinality: standard,
  includes: arrayOf( artifactRef ), // also entities
  length: value,
  on: (cond) => (typeof cond === 'string' ? undefined : condition( cond )),
  onCond : renameTo( 'on', condition ), // XSN TODO: onCond -> on
  precision: value,
  redirected: ignore,           // TODO: no need for this
  scale: value,
  target: artifactRef,
  type: artifactRef,
  items: standard,
  // inner properties --------------------------------------------------------
  path: ignore,                 // should not occur
  sourceMax: renameTo( 'src', value ), // TODO XSN: rename?
  targetMin: renameTo( 'min', value ),
  targetMax: renameTo( 'max', value ),
  targetElement: ignore,        // special display of foreign key
  // queries -----------------------------------------------------------------
  from: fromOld,                                 // XSN TODO just one (cross if necessary)
  quantifier: ( q, csn ) => { csn[ q.val ] = true; },
  exclude: renameTo( 'excluding', Object.keys ), // XSN TODO: exclude->excluding
  groupBy: arrayOf( expression ),
  having: condition,
  limit,                // TODO XSN: include offset
  offset: ignore,             // TODO XSN: move into `limit`
  orderBy: arrayOf( orderBy ), // TODO XSN: make `sort` and `nulls` sibling properties
  query,
  value: enumValue,             // do not list for select items as elements
  where: condition,
  // special HANA CDS featues ------------------------------------------------
  sequenceOptions: ignore,    // TODO: currently not in the JSON by HANA
  technicalConfig
}

const typeProperties = [        // currently just for select items
  'type', 'length', 'precision', 'scale', 'items', 'target', 'elements', 'enum'
];

const operators = {
  // standard is: binary infix (and corresponding n-ary), unary prefix
  isNot: [ 'is', 'not' ],       // TODO XSN: 'is not'
  isNull: postfix( ['is', 'null'] ),
  isNotNull: postfix( [ 'is', 'not', 'null' ] ),
  notIn: [ 'not', 'in' ],
  between: ternary( ['between'], ['and'] ),
  notBetween: ternary( ['not', 'between'], ['and'] ),
  like: ternary( ['like'], ['escape'] ),
  notLike: ternary( ['not', 'like'], ['escape'] ),
  when: (args) => ['when', ...args[0], 'then', ...args[1]],
  case: (args) => ['case'].concat( ...args, ['end'] ),
  // xpr: (args) => [].concat( ...args ), see below - handled extra
}

function compactModel( model, options = model.options || {} ) {
  csn_gensrc = options.disablePropagate;
  //strict = options.testMode;
  let csn = { definitions: sortedDict( model.definitions ) };
  if (!csn_gensrc)
    set( 'extensions', csn, model );
  else
    extensions( csn, model );
  if (model.version)
    csn.version = model.version;
  return csn;
}

function renameTo( csnProp, func ) {
  return function( val, csn, node, prop ) {
    let sub = func( val, csn, node, prop );
    if (sub !== undefined)
      csn[csnProp] = sub;
  }
}

function arrayOf( func ) {
  return ( val, ...args ) => val.map( v => func( v, ...args ) );
}

function extensions( csn, model ) {
  let extensions = (model.extensions) ? standard( model.extensions ) : [];
  for (let name in model.definitions) {
    let art = model.definitions[name];
    // in definitions (without redef) with potential inferred elements:
    if (!(art instanceof Array) && art.elements && (art.query || art.includes)) {
      let elements = inferred( art.elements );
      if (Object.keys( elements ).length)
        extensions.push( { annotate: name, elements } );
    }
  }
  if (extensions.length)
    csn.extensions = extensions;
}

function inferred( elements ) {
  let ext = Object.create(null);
  for (let name in elements) {
    let elem = elements[name];
    if (elem instanceof Array || !elem.$inferred)
      continue;
    let csn = annotations( elem, true );
    if (Object.keys(csn).length)
      ext[name] = Object.assign( { kind: 'annotate' }, csn );
  }
  return ext;
}

function standard( node ) {
  if (node instanceof Array)
    return node.map( standard );
  let csn = {};
  // To avoid another object copy, we sort according to the prop names in the
  // XSN input node, not the CSN result node.  Not really an issue...
  let keys = Object.keys( node ).sort( compareProperties );
  for (let prop of keys) {
    let transformer = transformers[prop] || transformers[prop.charAt(0)];
    // TODO: complain if falsy with strict
    // Apply transformer, or use standard() if there is none
    let sub = (transformer || standard)( node[prop], csn, node, prop );
    if (sub !== undefined)
      csn[prop] = sub;
  }
  return csn;
}

function elements( dict, csn, node ) {
  if (!csn_gensrc || !node.query && !node.type)
    return insertOrderDict( dict );
  else
    return undefined;
}

function set( prop, csn, node ) {
  let val = node[prop];
  if (val === undefined)
    return;
  let sub = transformers[prop]( node[prop], csn, node, prop );
  if (sub !== undefined)
    csn[prop] = sub;
}

// for csn_gensrc: return annotations from definition (annotated==false)
// or annotations (annotated==true)
function annotations( node, annotated ) {
  let csn = {};
  let transformer = transformers['@'];
  let keys = Object.keys( node ).filter( a => a.charAt(0) === '@' ).sort();
  for (let prop of keys) {
    let val = node[prop];
    if ((val.priority && val.priority !== 'define') == annotated) {
      // transformer (= value) takes care to exclude $inferred annotation assignments
      let sub = transformer( val, csn, node, prop );
      if (sub !== undefined)
        csn[prop] = sub;
    }
  }
  return csn;
}

function ignore() {}

function insertOrderDict( dict ) {
  let keys = Object.keys( dict );
  return dictionary( dict, keys );
}

function sortedDict( dict ) {
  let keys = Object.keys( dict );
  keys.sort();
  return dictionary( dict, keys );
}

function nonEmptyDict( dict ) {
  let keys = Object.keys( dict );
  return (keys.length)
    ? dictionary( dict, keys )
    : undefined;
}

function dictionary( dict, keys ) {
  let csn = Object.create(null);
  for (let name of keys) {
    let def = definition( dict[name] );
    if (def !== undefined)
      csn[name] = def;
  }
  return csn;
}

function dictAsArray( dict ) {
  let csn = [];
  for (let n in dict) {
    let d = definition( dict[n] );
    if (d !== undefined)
      csn.push( d );
  }
  return (csn.length) ? csn : undefined;
}

function definition( art ) {
  if (!art || typeof art !== 'object')
    return undefined;           // TODO: complain with strict
 // Do not include namespace definitions or inferred construct (in gensrc):
  if (art.kind === 'namespace' || art.$inferred && csn_gensrc)
    return undefined;
  if (art.kind === 'key')       // foreignkey
    return addExplicitAs( expression( art.targetElement ), art.name );
  else
    return standard( art );
}

function filterKind( kind, csn, node ) {
  if (kind === 'view')          // XSN TODO: kind: 'entity', $syntax: 'view'
    return 'entity';
  if (['element', 'key', 'enum', 'annotate'].includes(kind) ||
     'extend' === kind && !node._main)
    return undefined;
  return kind;
}

function annotationName( name, csn, node ) {
  if (!node._main && ['annotate', 'extend'].includes( node.kind ))
    // We just use `name.absolute` because it is very likely a "constructed"
    // extensions.  The CSN parser must produce name.path like for other refs.
    csn[node.kind] = name.absolute || artifactRef( name, true );
}

function artifactRef( node, terse ) {
  if (node.$inferred && csn_gensrc)
    return undefined;
  // Works also on XSN directly coming from parser
  let path = node.path;
  if (!path)                // does not work with current augmentor
    return undefined;           // TODO: complain with strict
  let length = path.length;
  let index  = 0;
  for (; index < length; ++index) {
    let art = path[index]._artifact;
    if (!art || art._main)      // stop if at element or not found/compiled
      break;
  }
  let id;
  if (index) {
    id = path[ index-1 ]._artifact.name.absolute;
  }
  else if (node.resolveSemantics === 'typeOf' && path[0]._artifact) {
    let name = path[0]._artifact.name;
    return { ref: [ name.absolute, ...name.element.split('.'), ...path.slice(1).map( pathItem ) ] };
  }
  else if (typeof node.scope === 'number') {
    // TODO: just use the first with CSN input - CDL should provide scope:0
    index = node.scope || length;
    id = (node.scope ? path.slice(0,index) : path).map( id => id.id ).join('.');
  }
  else {                        // JSON or i18n input (without compiler links)
    index = 1;
    id = path[0].id;
  }
  let main = Object.assign( {}, path[ index-1 ], { id } );
  let ref = [main, ...path.slice(index)].map( pathItem );
  return (!terse || ref.length != 1 || typeof ref[0] !== 'string')
         ? { ref }
         : ref[0];
}

function pathItem( item ) {
  if (!item.args && !item.namedArgs && !item.where && !item.cardinality)
    return item.id;
  let r = { id: item.id };
  if (item.args || item.namedArgs) // XSN TODO: namedArgs -> args
    r.args = args( item.args || item.namedArgs );
  set( 'cardinality', r, item );
  set( 'where', r, item );
  return r;
}

function args( node ) {
  if (node instanceof Array)
    return node.map( expression );
  let dict = Object.create(null);
  for (let param in node)
    dict[param] = expression( node[param] );
  return dict;
}

function value( node ) {
  if (!node)
    return true;                // `@aBool` short for `@aBool: true`
  if (node.$inferred && csn_gensrc)
    return undefined;
  if (node.path)
    return { '=': node.path.map( id => id.id ).join('.') };
  if (node.literal == 'enum')
    return { "#" : node.symbol.id };
  if (node.literal == 'array')
    return node.val.map( value );
  if (node.literal != 'struct')
    return !('val' in node) || node.val;
  let r = Object.create( null );
  for (let prop in node.struct)
    r[prop] = value( node.struct[prop] );
  return r;
}

function enumValue( v, csn, node )  {
  if (node.kind === 'enum')
    Object.assign( csn, expression(v) );
}

function condition( node ) {
  let expr = expression( node );
  return expr.xpr || [expr];
}

function expression( node ) {
  if (typeof node === 'string')
    return node;
  if (!node)                    // make to-csn robst
    return {};
  if (node instanceof Array) {
    let args = node.map( condition );
    let rest = args.slice(1).map( a => [',', ...a] );
    return { xpr: ['('].concat( args[0], ...rest, [')'] ) };
  }
  if (node.path) {
    // TODO: param/global
    return { ref: node.path.map( pathItem ) };
  }
  if (node.literal) {
    if (typeof node.val === node.literal || node.val === null)
      return { val: node.val };
    else if (node.literal === 'enum')
      return { "#" : node.symbol.id };
    else                        // TODO XSN: literal 'hex'->'x'
      return { val: node.val, literal: (node.literal==='hex') ? 'x' : node.literal };
  }
  if (node.func) {              // TODO XSN: remove op: 'call', func is no path
    return { func: node.func.path[0].id, args: args( node.args || node.namedArgs ) };
  }
  if (queryOps[ node.op.val ])
    return query( node );
  else     // do not use xpr() for xpr, as it would flatten inner xpr's (semantically ok)
    return { xpr: (node.op.val === 'xpr') ? node.args.map( expression ) : xpr( node ) };
}

function xpr( node ) {
  // if (!node.op) console.log(node)
  let op = operators[ node.op.val ] || node.op.val.split(' ');
  let args = node.args.map( condition );
  if (op instanceof Function)
    return op( args );
  if (node.quantifier)
    op.push( node.quantifier.val );
  if (args.length < 2)
    return [ ...op, ...args[0] || [] ];
  return args[0].concat( ...args.slice(1).map( a => [...op, ...a] ) );
}

function ternary( op1, op2 ) {
  return function( args ) {
    return (args[2])
      ? [ ...args[0], ...op1, ...args[1], ...op2, ...args[2] ]
      : [ ...args[0], ...op1, ...args[1] ];
  };
}

function postfix( op ) {
  return function( args ) {
    return [ ...args[0], ...op ];
  }
}

function query( node ) {
  // TODO: add "inferred" elements for leading query
  while (node instanceof Array) // in parentheses -> remove
    node = node[0];
  let csn = {};
  // for UNION, ... ----------------------------------------------------------
  if (!['query', 'subquery'].includes( node.op.val )) {
    if (node.op.val !== 'unionAll') // CSN TODO: quantifier: 'all'|'distinct'
      csn.op = node.op.val;
    else
      csn.op = 'union', csn.all = true;
  }
  if (node.args) {
    let args = node.args;
    // binary -> n-ary - the while loop should be done in parser (toCdl is
    // currently not prepared)
    while (args[0] && args[0].op && args[0].op.val === node.op.val &&
           !args[0].all === !node.all && args[0].args)
      args = [ ...args[0], ...args.slice(1) ]
    if (node.op.val === 'unionAll') // TODO grammar: set DISTINCT - quantifier: 'all'|'distinct'
      csn.all = true;
    csn.args = args.map( query );
  }
  // for SELECT --------------------------------------------------------------
  set( 'from', csn, node );
  set( 'mixin', csn, node );
  set( 'quantifier', csn, node );
  if (node.elements && (!node.all || node.all.val !== 'implicit')) {
    csn.columns = (node.all) ? ['*'] : [];
    for (let name in node.elements)
      addElementAsColumn( node.elements[name], csn.columns );
  }
  set( 'exclude', csn, node );  // XSN TODO: exclude->excluding
  set( 'where', csn, node );
  set( 'groupBy', csn, node );
  set( 'having', csn, node );
  // for both ----------------------------------------------------------------
  set( 'orderBy', csn, node );
  set( 'limit', csn, node );
  return (node.op.val === 'query') ? { SELECT: csn } : { SET: csn };
}

function fromOld( node ) {
  // TODO: currently an array in XSN:
  if (node.length > 1)
    return from( { join: 'cross', args: node } );
  else
    return from( node[0] );
}

// XSN TODO: remove '…Outer'
const joinTrans = { leftOuter: 'left', rightOuter: 'right', fullOuter: 'full' };

function from( node ) {
  while (node instanceof Array) // in parentheses
    node = node[0];
  // TODO: CSN: FROM ((SELECT...)) as -> also add 'subquery' op? - Together
  // with []-elimination in FROM...
  if (node.join) {         // XSN TODO: remove '…Outer'
    // binary (without additions) -> n-ary - the while loop should be done in
    // parser (toCdl is currently not prepared)
    let args = node.args;
    while (node.join === 'cross' && args[0] && args[0].join === node.join && args[0].args)
      args = [ ...args[0], ...args.slice(1) ]
    let join = { join: joinTrans[node.join] || node.join, args: node.args.map( from ) };
    set( 'on', join, node );
    return join;
  }
  else if (!node.path) {
    return addExplicitAs( query( node ), node.name );
  }
  else if (!node._artifact || node._artifact.main) {
    return addExplicitAs( artifactRef( node, null ), node.name );
  }
  else {
    let name = node._artifact.name.absolute;
    let dot  = name.lastIndexOf('.');
    return addExplicitAs( artifactRef( node, null ), node.name, name.substring( dot+1 ) );
  }
}

function addElementAsColumn( elem, columns ) {
  if (elem.viaAll)              // TODO: elem.$inferred (value '*')
    return;
  // TODO: 'priority' -> '$priority'
  // only list annotations here which a provided directly with definition
  let col = (csn_gensrc) ? annotations( elem, false ) : {};
  // with `client` flavor, assignments are available at the element
  let saved_gensrc = csn_gensrc;
  try {
    csn_gensrc = true;
    Object.assign( col, addExplicitAs( expression( elem.value ), elem.name ) );
    set( 'key', col, elem );
    if (elem._typeIsExplicit || elem.redirected) { // TODO XSN: introduce $inferred
      col.cast = {};
      for (let prop of typeProperties)
        set( prop, col.cast, elem );
    }
  }
  finally {
    csn_gensrc = saved_gensrc;
  }
  // FIXME: Currently toHana requires that an  '_ignore' property on the elem is also visible on the column
  if (elem._ignore) {
    col._ignore = true;
  }
  columns.push( col );
}

function orderBy( node ) {      // TODO XSN: flatten (no extra 'value')
  let expr = expression( node.value );
  if (node.sort)
    expr.sort = node.sort.val;
  if (node.nulls)
    expr.nulls = node.nulls.val;
  return expr;
}

function limit( limit, csn, node ) { // XSN TODO: use same structure
  let rows = expression( limit );
  return (node.offset)
    ? { rows, offset: expression( node.offset ) }
    : { rows };
}

function addExplicitAs( node, name, implicit ) {
  if (name && (!name.calculated && !name.$inferred || implicit && implicit !== name.id))
    node.as = name.id;
  return node;
}

// normalize CSN: sort properties alphabetically if no prototype (also sort model.definitions)
// for "niceness", put the following properties first: op, kind, name
const earlyProperties = { op: '\x01', kind: '\x02', name: '\x03' };

function compareProperties( a, b ) {
  if (a === b)
    return 0;
  else if ((earlyProperties[a] || a) < (earlyProperties[b] || b))
    return -1;
  else
    return 1;
}

function compactQuery( q ) {    // TODO: options
  csn_gensrc = true;
  return q && query( q );
}

function compactExpr( e ) {     // TODO: options
  csn_gensrc = true;
  return e && expression( e );
}

function technicalConfig( tc/*, parentCsn, parentArtifact, prop */) {
  let csn = { [tc.backend.val]: { } };
  let be = csn[tc.backend.val];
  if(tc.backend.calculated)
    be.calculated = true;
  if(tc.migration) {
    if(!be.tableSuffix)
      be.tableSuffix = [];
    be.tableSuffix.push({ xpr: ['migration', value(tc.migration)] });
  }
  if(tc.storeType) {
    if(!be.tableSuffix)
      be.tableSuffix = [];
    be.tableSuffix.push({ xpr: [value(tc.storeType), 'store'] });
  }
  if(tc.extendedStorage) {
    if(!be.tableSuffix)
      be.tableSuffix = [];
    be.tableSuffix.push({ xpr: ['using', 'extended', 'storage'] });
  }
  if(tc.group) {
    if(!be.tableSuffix)
      be.tableSuffix = [];
    let group = { xpr: [] };
    if(tc.group.name) {
      group.xpr.push('group', 'name ', { ref: [tc.group.name.id] });
    }
    if(tc.group.type) {
      group.xpr.push('group', 'type', { ref: [tc.group.type.id] });
    }
    if(tc.group.subType) {
      group.xpr.push('group', 'subtype', { ref: [tc.group.subType.id] });
    }
    be.tableSuffix.push(group);
  }
  if(tc.unloadPrio) {
    if(!be.tableSuffix)
      be.tableSuffix = [];
    be.tableSuffix.push({ xpr: ['unload', 'priority', expression(tc.unloadPrio)] });
  }
  if(tc.autoMerge) {
    if(!be.tableSuffix)
      be.tableSuffix = [];
    let autoMerge = { xpr: [] }
    if(!tc.autoMerge.val)
      autoMerge.xpr.push('no');
    autoMerge.xpr.push('auto', 'merge');
    be.tableSuffix.push(autoMerge);
  }
  if(tc.partition) {
    if(!be.tableSuffix)
      be.tableSuffix = [];
    be.tableSuffix.push({ xpr: [partition(tc.partition)] });
  }

  if(tc.fzindexes) {
    if(!be.fzindexes)
      be.fzindexes = {};
    tc.fzindexes.forEach(i => {
      i.columns.filter(c => !c._ignore).forEach(c => {
        let stream = [];
        stream.push('fuzzy', 'search', 'index', 'on');
        if(i.fuzzy) {
          stream.push('fuzzy', 'search', 'mode');
          if(i.fuzzy.mode) {
            stream.push(expression(i.fuzzy.mode));
          }
        }
        let name = c.path.map(p=>p.id).join('.');
        if(be.fzindexes[name]) {
          be.fzindexes[name].push(stream);
        }
        else {
          be.fzindexes[name] = [ stream ];
        }
      });
    });
  }

  if(tc.indexes) {
    be.indexes = {};
    for(let idxName in tc.indexes) {
      let idx = tc.indexes[idxName];
      be.indexes[idxName] = (Array.isArray(idx)) ? idx.map(index) : index(idx);
    }
  }
  return csn;

  function index(idx) {
    let stream = [];
    if(idx.kind === 'index') {
      if(idx.unique) {
        stream.push('unique');
      }
      stream.push('index', idx.name.id, 'on', '(');
      columns(idx.columns, stream);
      stream.push(')');
      if(idx.sort)
        stream.push(value(idx.sort));
    } else if(idx.kind === 'fulltextindex') {
      stream.push('fulltext', 'index', idx.name.id, 'on', '(');
      columns(idx.columns, stream);
      stream.push(')');
      if(idx.language) {
        if(idx.language.column) {
          stream.push('language', 'column');
          stream.push(expression(idx.language.column));
        }
        if(idx.language.detection) {
          stream.push('language', 'detection', '(');
          let i = 0;
          idx.language.detection.forEach(v => {
            if(i > 0)
              stream.push(',');
            stream.push(expression(v));
            i++;
          });
          stream.push(')');
        }
      }
      if(idx.mimeTypeColumn) {
        stream.push('mime', 'type', 'column', expression(idx.mimeTypeColumn));
      }
      if(idx.fuzzySearchIndex) {
        stream.push('fuzzy', 'search', 'index', value(idx.fuzzySearchIndex));
      }
      if(idx.phraseIndexRatio) {
        stream.push('phrase', 'index', 'ratio', expression(idx.phraseIndexRatio));
      }
      if(idx.configuration) {
        stream.push('configuration', expression(idx.configuration));
      }
      if(idx.textAnalysis) {
        stream.push('text', 'analysis', value(idx.textAnalysis));
      }
      if(idx.searchOnly) {
        stream.push('search', 'only', value(idx.searchOnly));
      }
      if(idx.fastPreprocess) {
        stream.push('fast', 'preprocess', value(idx.fastPreprocess));
      }
      if(idx.mimeType) {
        stream.push('mime', 'type', expression(idx.mimeType));
      }
      if(idx.tokenSeparators) {
        stream.push('token', 'separators', expression(idx.tokenSeparators));
      }
      if(idx.textMining) {
        if(idx.textMining.state) {
          stream.push('text', 'mining', value(idx.textMining.state));
        }
        if(idx.textMining.config) {
          stream.push('text', 'mining', 'configuration', expression(idx.textMining.config));
        }
        if(idx.textMining.overlay) {
          stream.push('text', 'mining', 'configuration', 'overlay', expression(idx.textMining.overlay));
        }
      }
      if(idx.changeTracking) {
        let ct = idx.changeTracking;
        stream.push(value(ct.mode));
        if(ct.asyncSpec) {
          let asp = ct.asyncSpec;
          stream.push('flush');
          if(asp.queue) {
            stream.push(value(asp.queue));
          }
          if(asp.minutes) {
            stream.push('every ', expression(asp.minutes), 'minutes');
            if(asp.documents) {
              stream.push('or');
            }
          }
          if(asp.documents) {
            stream.push('after', expression(asp.documents), 'documents');
          }
        }
      }
    }
    return stream;
  }

  function partition(p) {
    let stream = [];
    let i = 0;
    p.specs.forEach(s => {
      if(i == 0)
        stream.push('partition', 'by', ...s.scheme.val.split(' '));
      else
        stream.push(',', ...s.scheme.val.split(' '));
      spec(s);
      i++;
    });
    if(p.wpoac) {
      stream.push('with', 'partitioning', 'on', 'any', 'columns', value(p.wpoac));
    }
    return stream;

    function spec(s) {
      if(s.columns) {
        stream.push('(');
        columns(s.columns, stream);
        stream.push(')');
      }
      if(s.partitions) {
        stream.push('partitions', value(s.partitions));
      }
      if(s.ranges) {
        stream.push('(');
        let oppStore = (s.ranges[0].store === 'default' ? 'extended' : 'default');
        let delimiter = false;
        s.ranges.forEach(r => {
          if(r.store != oppStore) {
            if(s.withStorageSpec) {
              if(delimiter) {
                stream.push(')');
              }
              stream.push('using', r.store, 'storage', '(');
            }
            delimiter = false;
            oppStore = r.store;
          }
          if(delimiter) {
            stream.push(',');
          }
          stream.push('partition');
          if(r.others) {
            stream.push('others');
          }

          if(r.min && !r.max) {
            stream.push('value', '=');
          }
          if(r.min) {
            stream.push(expression(r.min));
          }

          if(r.isCurrent) {
            stream.push('is', 'current');
          }
          if(r.min && r.max) {
            stream.push('<=', 'values', '<', expression(r.max));
          }
          delimiter = true;
        });
        if(s.withStorageSpec) {
          stream.push(')');
        }
        stream.push(')');
      }
    }
  }

  function columns(arr, stream) {
    let i = 0;
    arr.filter(c=>!c._ignore).forEach(c => {
      if(i > 0)
        stream.push(',');
      if(c.unit)
        stream.push(value(c.unit), '(');
      stream.push(expression(c));
      if(c.unit)
        stream.push(')');
      if(c.sort)
        stream.push(value(c.sort));
      i++;
    });
  }
}


module.exports = { compactModel, compactQuery, compactExpr };
