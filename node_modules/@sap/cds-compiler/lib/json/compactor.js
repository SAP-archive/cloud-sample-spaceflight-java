// Transform augmented CSN into compact "official" CSN

// Augmented CSN is the CDS model which includes all data which is necessary
// for checks and user-friendly error reporting (sources positions, ...).  See
// file '../compiler/definer.js for technical details.

// The transformation works as follows: from the model object, we just use the
// `definitions` property and transform its value to the following rule:
//  - if it is a non-object, return it directly
//  - if it is an array, return it with all items transformed recursively
//  - if it is a dictionary (object without [[Prototype]]), return it with
//    all property values transformed recursively; properties with value
//    `undefined` are deleted
//  - if it is another object, return it with all property values transformed
//    according to function `transformers.<prop>` or (if it does not exist)
//    recursively to the rule; properties with value `undefined` are deleted

'use strict';

let cloneWithTransformations = require('../base/model').cloneWithTransformations;
const { refString } = require('../base/messages');
const { queryOps } = require('../base/model');
const { mergeOptions }  = require('../model/modelUtils');


function getCompactors(options = {} ) {
  const transformers = {
    '@': compactValue,
    '$': ignore,
    'queries': ignore,          // TODO: make it $queries
    viaAll: ignore,
    actions: compactActions,
    blocks: ignore,
    annotationAssignments: ignore, // original with structure values
    kind: filterKind,
    location: ignore,
    name: ignore,
    // foreignKeys: compactForeignKeys,
    implicitForeignKeys: ignore,
    calculated: ignore,         // implicit foreign key
    type: options.hanaFlavor ? followTypeOf : compactName,
    projection: ignore,
    quantifier: ( q, node, r ) => { r[ q.val ] = true; },
    all: asBool,
    origin: compactName,
    target: compactName,
    source: compactName,
    scope: ignore,
    query: compactQuery,
    path: compactPath,
    quoted: ignore,             // really?  What about CURRENT_DATE vs "CURRENT_DATE"?
    targetElement: compactTargetElement,
    length: value,
    precision: value,
    scale: value,
    sourceMax: value,
    targetMin: value,
    targetMax: value,
    artifacts: ignore,
    dbType: asBool,
    typeOf: options.hanaFlavor ? ignore : asBool,
    key: asBool,
    localized: asBool,
    virtual: asBool,
    value: value,
    // val: value,
    alias: compactName,
    notNull: asBool,
    abstract: asBool,
    masked: asBool,
    includes: compactIncludes,
    sequenceOptions: ignore,    // TODO: currently not in the JSON by HANA
    default: compactCondOrExpr,
    annoExtensions: ignore,
    extensions: ignore,
    onCond : compactCondOrExpr,
    on: (x => (typeof x === 'string') ? x : compactCondOrExpr(x)),
    where: compactCondOrExpr,
    groupBy: compactCondOrExpr,
    having: compactCondOrExpr,
    limit: value,
    offset: value,
    redirected: asBool,
    impl: i => i.id,
    opLocation: ignore, // TODO: clarify expression parser depth and the locations to the nodes
    op: compactOp,
  }

  function compactOp(node) {
    if(node && node.val) return node.val;
    return node;
  }

  const typeProperties = [        // used in followTypeOf()
    'length', 'precision', 'scale', 'items', 'target', 'source',
    'elements', 'enum'
  ]

  // Export all publicly usable compactors here
  // FIXME: Once we get rid of 'options', we won't need the indirection via getCompactors any more
  return {
    compactNode,
    compactValue,
    compactName,
    compactPath,
    compactCondOrExpr,
  };

  // Default compactor - applies all transformers listed above
  function compactNode(node) {
    return cloneWithTransformations(node, transformers);
  }

  function ignore() {}

  function asBool(loc) {
    return loc != null && (loc.val != null) ? loc.val : !!loc;
  }

  function value(val) {
    return (val == null || typeof val !== 'object')
      ? val
      : compactValue(val);
  }

  function filterKind(kind) {
    // We always filter these
    if (kind !== 'element' && kind !== 'key' && kind !== 'enum')
      return kind;
    return undefined;
  }

  function compactTargetElement( elem, node, result ) {
    if (!elem || typeof elem !== 'object')
      return null;
    result.path = compactPath( elem.path ); // compatibility - TODO: use {ref:[…]} .
    return undefined;
  }

  function compactName( name ) {
    if (!name || typeof name !== 'object')
      return null;
    if (name.absolute || name._artifact && name._artifact.kind !== 'builtin')
      return refString( name );
    return null;                // for CURRENT_DATE etc in origin
  }

  function followTypeOf( name, node, r ) {
    if (!name._artifact || name._artifact.kind !== 'element')
      return compactName( node.type );

    let final = node._finalType;
    while (node !== final && node.type._artifact && node.type._artifact.kind === 'element')
      // We do not need to consider `origin`, as this is for --hana-flavor
      node = node.type._artifact;

    for (let prop of typeProperties) {
      if (node[prop] !== undefined) {
        let func = transformers[prop];
        let item = func ? func(node[prop]) : compactNode(node[prop]);
        if (item !== undefined)
          r[prop] = item;
      }
    }
    return node.type ? compactName( node.type ) : undefined;
  }

  function compactPath( path ) {
    return path && path.map( id => id.id ).join('.');
  }

  function compactActions(actions) {
    // Ignore empty actions section
    if (!actions || Object.keys(actions).length == 0) {
      return undefined;
    }
    return compactNode(actions)
  }

  function compactIncludes(includes) {
    return includes.map( refString );
  }
  // Transform value `node` to the official CSN form
  // TODO: small change so it can also be used instead of `value` and `asBool`
  function compactValue( node ) {
    if (!node)
      return true;                // `@aBool` short for `@aBool: true`
    if (node.literal == 'array')
      return node.val.map( compactValue );
    if (node.literal == 'enum') {
      return { "#" : node.symbol.id };
    }
    if (node.path)              // TODO: incompatibility HANA CDS
      return { '=': node.path.map( id => id.id ).join('.') };

    if(node.op && node.op.val === "notyet" && node.args === undefined) { // TODO: remove this when notyet is gone
      return { op : "notyet" };
    }

    if(node instanceof Array || node.op && node.args) {
      return compactCondOrExpr(node)
    }
    if (node.literal != 'struct')
      return !('val' in node) || node.val;
    let r = Object.create( null );
    for (let prop in node.struct)
      r[prop] = compactValue( node.struct[prop] );
    return r;
  }

  function compactQuery( query, node ) { // not for projections - TEMP?
    return (node.projection) ? undefined : compactCondOrExpr( query );
  }

  // Compact a condition or expression tree
  // TODO: there should be nothing special about it, i.e. performed by compactNode()
  // if ref paths are written as { ref: […] } and values like { val: […] }
  function compactCondOrExpr(condOrExpr) {
    if (condOrExpr == null || typeof condOrExpr !== 'object')
      return condOrExpr;
    if (Array.isArray(condOrExpr)) { // brackets in expressions result arrays
      let r = condOrExpr.map(compactCondOrExpr);
      return r;
    }
    // Query expressions are rendered as normal nodes (as should all, see TODO above)
    if (condOrExpr.op && queryOps[ condOrExpr.op.val ])
      return compactNode( condOrExpr );
    // Dive recursively into nested conditions or expressions
    if (condOrExpr && 'op' in condOrExpr && 'args' in condOrExpr) {
      let r = { op : condOrExpr.op.val, args : condOrExpr.args.map(compactCondOrExpr) };
      if(condOrExpr.quantifier)
        r.quantifier=condOrExpr.quantifier.val;
      if (condOrExpr.func)
        r.func = compactPath( condOrExpr.func.path );
      return r;
    }
    // Treat everything else as values
    return compactValue(condOrExpr);
  }
}

// Top-level compactor function for a whole model. Strips everything but definitions,
// compacts definitions, according to provided 'options' or model options.
function compact( model, options ) {
  options = mergeOptions(model.options, options);
  const { compactNode } = getCompactors(options);
  let newModel = { definitions: compactNode(model.definitions) }
  for (let name in newModel.definitions) {
    let art = newModel.definitions[name];
    if (art && typeof art === 'object' && art.kind === 'namespace')
      delete newModel.definitions[name];
  }
  if (model.version)
    newModel.version = model.version;

  let PERSIST_COMPACTED_CSN = "PERSIST_COMPACTED_CSN" in process.env;
  if(PERSIST_COMPACTED_CSN) {
    let fs = require("fs");
    let rnd = Math.random();
    let fn1 = "tmp/csn."+rnd+".augmented.json"
    let fn2 = "tmp/csn."+rnd+".compacted.json"
    let augmentedModel = { definitions: model.definitions};
    fs.writeFileSync(fn1, JSON.stringify(augmentedModel,null,2));
    let dumpModel = { definitions: compactNode(model.definitions)};
    fs.writeFileSync(fn2, JSON.stringify(dumpModel,null,2));

    //options
    let fn3 = "tmp/csn."+rnd+".options.json"
    fs.writeFileSync(fn3, JSON.stringify(options,null,2));
  }

  //check if environment variable VALIDATE_CSN is set and if so perform CSN validation
  let VALIDATE_CSN = "VALIDATE_CSN" in process.env;
  if(VALIDATE_CSN) {
    let validateCSN = require("./schema/validateCSN.js");
    let errors = validateCSN(newModel, {ajv:{useDefaults: false}});
    if(errors.length>0) {
      // persist the results in files if environment variable VALIDATE_CSN_PERSIST_ERROR is set
      let VALIDATE_CSN_PERSIST_ERROR = "VALIDATE_CSN_PERSIST_ERROR" in process.env;
      if(VALIDATE_CSN_PERSIST_ERROR) {
        let fs = require("fs");
        fs.writeFileSync("lasterror.json", JSON.stringify(newModel,null,2));
        fs.writeFileSync("lasterror.txt", errors.toString());
        throw Error("Invalid CSN: see lasterror.json and lasterror.txt");
      } else {
        throw Error("Invalid CSN:"
          + JSON.stringify(newModel,null,2)
          + errors);
      }
    }
  }
  return newModel;
}

// normalize CSN: sort properties alphabetically if no prototype (also sort model.definitions)
// for "niceness", put the following properties first: op, kind, name
const earlyProperties = { op: '\x01', kind: '\x02', name: '\x03' };

function compactSorted( ...args ) {
  let model = compact( ...args );
  let result = Object.create(null);
  let definitions = model.definitions;
  for (let k of Object.keys( definitions ).sort())
    result[k] = normalizeNode( definitions[k] );
  model.definitions = result;
  return model;
}

// TODO: put the following directly into compact() ?
function normalizeNode( node ) {
  if (node == null || typeof node !== 'object') {
    return node
  }
  // Transform arrays element-wise
  if (node instanceof Array) {
    return node.map( normalizeNode );
  }
  // Things not having 'proto' are dictionaries
  let proto = Object.getPrototypeOf(node);
  // Iterate own properties of 'node' and transform them into 'resultNode'
  let result = Object.create(proto);
  let keys = Object.keys(node);
  if (proto)
    keys.sort( compareProperties );
  for (let k of keys)
    result[k] = normalizeNode( node[k] );
  return result;
}

function compareProperties( a, b ) {
  if (a === b)
    return 0;
  else if ((earlyProperties[a] || a) < (earlyProperties[b] || b))
    return -1;
  else
    return 1;
}


module.exports = {
  compact,
  compactSorted,
  getCompactors,
};
