// Compiler functions and utilities shared across all phases


'use strict';

const { msgName } = require('../base/messages');
const alerts = require('../base/alerts');
const { kindProperties } = require('../base/model');
const { addToDict, addToDictWithIndexNo, pushToDict } = require('../base/dictionaries');


// Main export function of this file.  Return "resolve" functions shared for phase
// "define" and "resolve".  Argument `model` is the augmented CSN.  Optional
// argument `environment` is a function which returns the search environment
// defined by its argument - it defaults to the dictionary of subartifacts of
// the argument.
function fns( model, environment = (o => o.artifacts || Object.create(null) ) ) {
  var options = model.options || {};
  const { error, warning, signal } = alerts(model);
  const specExpected = {
    annotation: { useDefinitions: true, severity: 'None' },
    extend: { useDefinitions: 'NullIfNotFound' }, // ref in top-level EXTEND
    annotate: { useDefinitions: true, severity: 'Info' }, // ref in top-level ANNOTATE
    type: { reject: rejectNonType }, // TODO: more detailed later (e.g. for enum base type?)
    typeOf: { next: '_$next' },
    include: { reject: rejectNonStruct },
    target: { reject: rejectNonEntity, noDep: true },
    element: { next: '__none_' },
    from: { reject: rejectNonSource },
    const: { next: '_$next', reject: rejectNonConst },
    expr: { next: '_$next' }   // TODO: better - on condition for assoc, other on
  }

  return {
    resolveUncheckedPath,
    resolvePath,
    defineAnnotations,
    message: signal,
    error, warning,
  };

  function rejectNonConst( art ) {
    return (art.kind === 'builtin') ? undefined : 'A constant value is expected here';
  }

  function rejectNonStruct( art ) {
    return (['type', 'entity'].includes( art.kind ) && art.elements && !art.query)
      ? undefined
      : 'A structured type or a non-query entity is expected here';
  }

  function rejectNonType( art ) {
    return (['type', 'entity', 'view'].includes( art.kind ) ||
            // art.kind === 'type' || // too strong for positive/BoundFunctions
            // art._main && art._main.kind === 'type')  // currently too strong
            art._main && ['type', 'entity', 'view'].includes( art._main.kind ))
      ? undefined
      : 'A type or an element of a type is expected here';
  }

  function rejectNonEntity( art ) {
    return (['view', 'entity'].includes( art.kind ))
      ? undefined
      : 'An entity, projection or view is expected here';
  }

  function rejectNonSource( art, path ) {
    if (['view', 'entity'].includes( art.kind ))
      return undefined;
    let main = [...path].reverse().find( item => !item._artifact._main );
    if (!['view', 'entity'].includes( main._artifact.kind ))
      return 'A source must start at an entity, projection or view';
    environment( art );           // sets _finalType on art
    return (!art._finalType || art._finalType.target)
      ? undefined
      : 'The path must end with an association';
  }

  // Return absolute name for unchecked path `ref`.  We first try searching for
  // the path root starting from `env`.  If it exists, return its absolute name
  // appended with the name of the rest of the path and set `ref.absolute` to
  // the return value.  Otherwise, complain if `unchecked` is false, and set
  // `ref.absolute` to the path name of `ref`.
  // Used for collecting artifact extension, and annotation assignments.
  function resolveUncheckedPath( ref, expected, env ) {
    if( ref.absolute && !ref.path )
      return ref.absolute;
    if (!ref.path || ref.path.broken) // incomplete type AST
      return undefined;
    let spec = specExpected[expected];
    let art = getPathRoot( ref.path, spec, env );
    if (!art)
      return (spec.useDefinitions === true) ? pathName( ref.path ) : undefined;
    setProp( ref.path[0], '_artifact', art );
    if (ref.path.length > 1)
      return art.name.absolute + '.' + pathName( ref.path.slice(1) );
    else
      return art.name.absolute;
  }

  // Return artifact or element referred by the path in `ref`.  The first
  // environment we search in is `env`.  If no such artifact or element exist,
  // complain with message and return `undefined`.  Record a dependency from
  // `user` to the found artifact if `user` is provided.
  function resolvePath( ref, expected, user, env, extDict ) {
    if (ref == undefined)       // no references -> nothing to do
      return undefined;
    if ('_artifact' in ref)     // also true for _artifact: undefined
      return ref._artifact;
    if (ref.param)              // :path not yet supported
      return undefined;

    let spec = specExpected[expected];
    if( ref.absolute && !ref.path ) { // TODO: this should disappear
      let art = !ref.query && !ref.alias && model.definitions[ref.absolute];
      art = resolveMember( art, ref.action, 'actions' );
      art = resolveMember( art, ref.param, 'params' );
      art = resolveMember( art, ref.element );
      setProp( ref, '_artifact', art );
      if (!art && spec.severity !== 'None')
        signal( error`Artifact ${msgName( ref )} has not been found`,
                ref.location, spec.severity );
      return art;
    }
    if (!ref.path || ref.path.broken || !ref.path.length || !env) // incomplete type AST or empty env (already reported)
      return undefined;
    var [head, ...tail] = ref.path;
    // if (!head) console.error(ref)

    // 'global' for CSN later in value paths, CDL for Association/Composition:
    var art = (ref.scope === 'global')
              ? getPathRoot( ref.path, spec, {}, model.definitions )
              : getPathRoot( ref.path, spec, env, extDict );
    if (art && art.kind === 'using') {
      art = model.definitions[ art.name.absolute ];
    }
    else if (art && art.name.$mixin) {
      setProp( head, '_navigation', art );
    }
    else if (art && kindProperties[ art.kind ].$navigation ) { // '$tableAlias, $navElement
      setProp( head, '_navigation', art );
      let real = art.origin || art.type;                  // is undefined for sub query
      art = real && real._artifact || art;
    }
    setProp( head, '_artifact', art );

    if (art) {
      art = getPathItem( tail, spec, art, head );
    }
    if (art && spec.reject) {
      let msg = spec.reject( art, ref.path );
      if (msg) {
        signalNotFound( msg, ref.location );
        art = undefined;
      }
    }
    if (art) {
      if (art.name.absolute)    // TODO: theses settings will disappear
        ref.absolute = art.name.absolute;
      if (art.name.element)
        ref.element = art.name.element;
      if (art.name.alias)
        ref.alias = art.name.alias;
      if (art.name.query != null)
        ref.query = art.name.query;
      if (art.name.action)
        ref.action = art.name.action;
      if (art.name.param)
        ref.param = art.name.param;
      if (user && !spec.noDep) {
        let location = ref.location || combinedLocation( head, ref.path[tail.length] );
        if (!user._deps)
          setProp( user, '_deps', [] );
        user._deps.push( { art, location } );
        // Without on-demand resolve, we can simply signal 'undefined "x"'
        // instead of 'illegal cycle' in the following case:
        //    element elem: type of elem.x;
      }
    }
    setProp( ref, '_artifact', art );
    return art;
  }

  function resolveMember( art, ref, memberProp ) {
    if (!ref || !art)
      return art;
    let path = ref.split(':');
    for (let id of path) {
      let dict = (memberProp)
          ? art[memberProp]
          : (art.elements || art.enum || art.foreignKeys);
      art = dict && dict[id];
      if (!art)
        return undefined;
    }
    return art;
  }

  function transformMagicName( name ) {
    // TODO: store magic variable in lower case (nicer for code completion)
    return (name === 'self' || name.charAt() === '$') ? name : name.toUpperCase();
  }

  // Return artifact or element referred by name `head`.  The first environment
  // we search in is `env`.  If `unchecked` is equal to `true`, do not report an error
  // if the artifact does not exist.  Return a "fresh" artifact for
  // non-existing external using references if `unchecked` is truthy.
  function getPathRoot( path, spec, env, extDict ) {
    if (!spec.next && !extDict)
      extDict = (spec.useDefinitions || ['json','i18n','xml'].includes(env.$frontend))
                ? model.definitions
                : model.$builtins;
    // TODO: remove resolveSemanics, just have typeOf for type refs
    let nextProp = spec.next || '_block';
    let head = path[0];
    for (let art = env; art; art = art[nextProp]) {
      let e = art.artifacts || art.$tableAliases || Object.create(null);
      let r = (art.kind !== '$magicVariables')
              ? e[ head.id ]
              // do not find magic variables if quoted:
              : (!head.quoted) && e[ transformMagicName( head.id ) ];
      if (r) {
        if (r instanceof Array) // redefinitions
          return undefined;
        else if (r.kind === 'block')
          return r.name._artifact;
        else if (r.kind !== '$tableAlias' ||
                 (r.self ? !head.quoted : path.length > 1))
          // except $self if quoted, or "real" table aliases (not $self) with path len 1
          return r;
      }
    }
    if (extDict) {
      let r = extDict[head.id];
      if (r instanceof Array)
      {
        // TODO: collect table refs - ok if only one, otherwise ambiguity (better
        // msg) - let functionality be provided by function as argument
        if (r[0].kind === '$navElement')
          signal( `Ambiguous, use table alias"`, head.location );
        return undefined;
      }
      else if (r)
        return r;
    }
    if (spec.severity === 'None')
      return undefined;

    let valid = [];
    for (let art = env; art; art = art[nextProp]) {
      let e = art.artifacts || art.$tableAliases || Object.create(null);
      valid.push( e );
    }
    if (extDict) {
      let e = Object.create(null);
      // the names of the external dictionary are valid, too, except duplicate
      // navigation elements (for which you should use a table alias)
      for (let name in extDict) {
        if (!(extDict[name] instanceof Array && extDict[name][0].kind === '$navElement'))
          e[name] = extDict[name];
      }
      valid.push( e );
    }

    if (spec.next) {
      if (env.$msg)
        signalNotFound( error`Element ${msgName( head.id )} has not been found in ${msgName( env.$msg )}`,
                        head.location, valid, spec.severity );
      else 
        signalNotFound( `No element has been found with name ${msgName( head.id )}`,
                        // TODO: we could sometimes use "Element ... not been found in ..."
                        head.location, valid, spec.severity );
    }
    else if (['json','i18n','xml'].includes(env.$frontend)) // only searches in definitions
      signalNotFound( error`Artifact ${msgName( head.id )} has not been found`,
                      head.location, [env], spec.severity );
    else
      signalNotFound( `No artifact has been found with name ${msgName( head.id )}`,
                      head.location, valid, spec.severity );
    return undefined
  }

  // Return artifact or element referred by path (array of ids) `tail`.  The
  // search environment (for the first path item) is `arg`.  For messages about
  // missing artifacts (as opposed to elements), provide the `head`(first
  // element item in the path)
  function getPathItem( tail, spec, art, head ) {
    for (let item of tail) {
      if (!item)                // incomplete AST
        return undefined;
      let env = (head) ? environment(art) : art.elements;
      let sub = env && env[item.id];
      if (sub) {
        if (sub instanceof Array) // redefinitions
          return undefined;
        art = setProp( item, '_artifact', sub );
        continue;
      }
      if (art.kind === 'context' || art.kind == 'service' || art.kind == 'namespace' ) {
        signalNotFound( error`Artifact ${msgName( art.name.absolute + '.' + item.id )} has not been found`,
                        item.location, [env], spec.severity );
      }
      else if (art.self && art.name.query != null) {
        signalNotFound( error`Element ${msgName( item.id )} has not been found in the elements of the query`,
                        item.location, [env], spec.severity );
      }
      else if (art.name.alias && art.type && art.type._artifact)
      {
        signalNotFound( error`Element ${msgName( item.id )} has not been found in ${msgName( art.type )}`,
                        item.location, [env], spec.severity );
      }
      else {
        let elem = (art.kind === 'element') ? art.name.element + '.' + item.id : item.id;
        signalNotFound( error`Element ${msgName( elem )} has not been found in ${msgName( art.name, true )}`,
                        item.location, [env], spec.severity );
      }
      return undefined;
    }
    // TODO: $navElement
    // TODO: extra with $parameters if that is supported
    return art;
  }

  function signalNotFound( text, location, valid, severity = 'Error' ) {
    if (location._notFound)
      return;
    setProp( location, '_notFound', true );
    signal( text, location, severity ); // arg, it returns true/false
    let err = model.messages[ model.messages.length-1 ];
    // console.log( Object.keys( Object.assign( Object.create(null), ...valid.reverse() ) ) )
    if (valid && (options.attachValidNames || options.testMode))
      err.validNames = Object.assign( Object.create(null), ...valid.reverse() );
    if (options.testMode && valid) {
      let names = Object.keys( err.validNames );
      signal( names.length ? 'Valid: ' + names.sort().join(', ') : 'No valid names',
              location, 'Info' );
    }
  }

  // Resolve all annotation assignments for the node `art`.  Set `art.@` to all
  // flattened assignments.  This function might issue error message for
  // duplicate assignments.
  // TODOs:
  // * do something for extensions by CSN or Properties parsers
  // * make sure that we do not issue repeated warnings due to flattening if an
  //   annotation definition is missing
  function defineAnnotations( construct, art, block, priority ) {
    if (!construct.annotationAssignments || !construct.annotationAssignments.length) {
      if (construct === art)
        return;
      for (let annoProp in construct) {
        if (annoProp.charAt(0) === '@') {
          let annos = construct[annoProp];
          if (!(annos instanceof Array))
            annos = [annos];
          for (let a of annos) {
            setProp( a, '_block', block );
            addToDict( art, annoProp, a );
          }
        }
      }
      return;
    }
    for (let anno of construct.annotationAssignments) {
      let ref = anno.name;
      let name = resolveUncheckedPath( ref, 'annotation', block );
      let annoProp = (anno.name.variant)
          ? '@' + name + '#' + anno.name.variant.id
          : '@' + name;
      if(anno.priority === 'i18n')
        priority = 'i18n';
      flatten( ref.path, annoProp, anno.value || {}, anno.name.variant, anno.name.location );
    }
    return;

    function flatten( path, annoProp, value, iHaveVariant, location ) {
      // Be robust if struct value has duplicate element names
      if (value instanceof Array) // TODO: do that differently in CDL parser
        return;                 // discard duplicates in flattened form

      if (value.literal === 'struct') {
        for (let item of value._struct || []) {
          let prop = pathName(item.name.path);
          if (item.name.variant) {
            if (iHaveVariant)
              signal('Annotation variant has been already provided', item.name.variant.location);
            prop = prop + '#' + item.name.variant.id; // TODO: check for double variants
          }
          flatten( [...path, ...item.name.path], annoProp + '.' + prop, item, iHaveVariant || item.name.variant);
        }
        for (let prop in value.struct) {
          let item = value.struct[prop];
          flatten( [...path, item.name], annoProp + '.' + prop, item, iHaveVariant );
        }
        return;
      }
      let anno = Object.assign( {}, value ); // shallow copy
      anno.name = { path, location: location || value.name && value.name.location || value.path && value.path.location };
      if (priority)
        anno.priority = priority;
      setProp( anno, '_block', block );
      // TODO: _parent, _main is set later (if we have ElementRef), or do we
      // set _artifact?
      setAnnotation( art, annoProp, anno, priority );
    }
  }

  function setAnnotation( art, annoProp, anno, priority = 'define') {
    anno.priority = priority;
    addToDict( art, annoProp, anno );
  }
}

// Create a location with location properties `filename` and `start` from
// argument `start`, and location property `end` from argument `end`.
function combinedLocation( start, end ) {
  return {
    filename: start.location.filename,
    start: start.location.start,
    end: end.location.end
  };
}

// Return string 'A.B.C' for parsed source `A.B.C` (is vector of ids with
// locations):
function pathName (path) {
  return path.map( id => id.id ).join('.');
}

// Like `obj.prop = value`, but not contained in JSON / CSN
function setProp ( obj, prop, value ) {
  Object.defineProperty( obj, prop, { value, configurable: true, writable: true } );
  return value;
}

function linkToOrigin( origin, name, parent, prop, location ) {
  let elem = {
    name: { location, id: origin.name.id }, // more by setMemberParent()
    kind: origin.kind,
    origin: Object.assign( {}, origin.name ), // TODO: {} should be enough - but tests fail
    location
  };
  if (origin.name.$inferred)
    elem.name.$inferred = origin.name.$inferred;
  delete elem.origin.id;
  delete elem.origin.quoted;
  if (parent)
    setMemberParent( elem, name, parent, prop ); // TODO: redef in template
  setProp( elem.origin, '_artifact', origin );
  return elem;
}

function setMemberParent( elem, name, parent, prop ) {
  if (prop) {              // extension or structure include
    // TODO: consider ARRAY OF and RETURNS
    if (!(prop in parent))
      parent[prop] = Object.create(null);
    addToDictWithIndexNo( parent, prop, name, elem )
  }
  setProp( elem, '_parent', parent );
  setProp( elem, '_main', parent._main || parent );
  elem.name.absolute = elem._main.name.absolute;
  [ 'element', 'alias', 'query', 'param', 'action' ].forEach( function( kind ) {
    // console.log(elem.kind || elem)
    let normalized = kindProperties[ elem.kind ].normalized || elem.kind;
    if (normalized === kind) {
      elem.name[kind] = (parent.name[kind] != null) ? parent.name[kind] + '.' + name : name;
    }
    else if (parent.name[kind] != null) {
      elem.name[kind] = parent.name[kind];
    }
    else
      delete elem.name[kind];
  });
  // try { throw new Error('Foo') } catch (e) { elem.name.stack = e; };
}

function storeExtension( elem, name, prop, parent, block ) {
  if (prop === 'enum')
    prop = 'elements';
  setProp( elem, '_block', block );
  let kind = '_' + elem.kind; // _extend or _annotate
  if (!parent[kind])
    setProp( parent, kind, {} );
  if (!parent[kind][prop])
    parent[kind][prop] = Object.create(null)
  pushToDict( parent[kind][prop], name, elem );
}

// Returns true iff a paths navigates along an association, i.e. return false
// if the path just ends in an association
function navigatesAlongAssoc( ref ) {
  let type = {};
  for (let item of ref.path) {
    if (type.target)
      return true;
    type = item._artifact && item._artifact._finalType;
  }
  return false;
}

module.exports = {
  fns,
  linkToOrigin, setMemberParent,
  storeExtension,
  navigatesAlongAssoc,
  combinedLocation };
