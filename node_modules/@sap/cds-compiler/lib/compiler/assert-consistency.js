// Consistency checker on model (XSN = augmented CSN)

'use strict';

const { locationString } = require('../base/messages');
const { queryOps } = require('../base/model');

function assertConsistency( model, stage ) {
  let stageParser = typeof stage === 'object';
  let options = stageParser && stage || model.options || { testMode: true };
  if (stageParser
    ? !options.testMode && (model.$frontend !== 'json' || !options.newCsn)
    : !options.testMode || options.parseOnly)
  //if (!options.testMode || options.parseOnly && !stageParser)
    return;

  const schema = {
    '': {                       // top-level
      required: ['messages','options','definitions','sources'],
      reqParser: ['$frontend'],
      optional: ['extensions','version','$magicVariables','$builtins'], // version not with --test-mode
      optParser: [
        'messages','options','definitions','extensions',
        'artifacts','namespace','usings', // CDL parser
        'package',                        // HANA CDS
        'filename', 'dirname',  // TODO: move filename into a normal location?
        'dependencies',         // for USING..FROM
        'kind',                 // TODO: remove from parser
        'version',              // TODO: do not set in parser
      ],
    },
    $frontend: { parser: true, test: () => true },      // TODO
    messages: { test: isVector( () => true ) }, // TODO: check message object
    options: { test: () => true },              // TODO
    definitions: {
      test: isDictionary( definition ),
      required: ['kind','location','name'],
      reqParser: ['kind','location'], // add 'name' to optional as still allowed
      optional: thoseWithKind
    },
    extensions: {
      inherits: 'definitions',
      test: isVector( standard ),
      reqParser: null           // like normal "require"
    },
    elements: { kind: true, inherits: 'definitions' },
    elements_: { kind: true, parser: true, test: () => true  }, // TODO: remove
    _elementsIndexNo: { kind: true, parser: true, test: () => true  }, // TODO: remove
    actions: { kind: true, inherits: 'definitions' },
    actions_: { kind: true, parser: true, test: () => true  }, // TODO: remove
    enum: { kind: true, inherits: 'definitions' },
    enum_: { kind: true, parser: true, test: () => true  }, // TODO: remove
    foreignKeys: { kind: true, inherits: 'definitions' },
    foreignKeys_: { kind: true, parser: true, test: () => true  }, // TODO: remove
    _foreignKeysIndexNo: { kind: true, parser: true, test: () => true  }, // TODO: remove
    params: { kind: true, inherits: 'definitions' },
    params_: { kind: true, parser: true, test: () => true  }, // TODO: remove
    _paramsIndexNo: { kind: true, parser: true, test: () => true  }, // TODO: remove
    mixin: { inherits: 'definitions' },
    query: {
      kind: true,
      test: query,              // properties below are "sub specifications"
      op: {
        schema: { args: { inherits: 'query', test: isVector( query ) } },
        required: ['op','location','args'],
        optional: ['quantifier','orderBy','limit','offset','_leadingQuery']
      },
      select: {
        required: ['op','location','from','elements'],
        optional: [
          'name','quantifier','mixin','all','exclude',
          'where','groupBy','having','orderBy','$orderBy','limit','offset',
          '_elementsIndexNo','_projections','_block','_parent','_main',
          '$tableAliases','kind','_firstAliasInFrom','queries','_$next','$combined',
          '$dictOrderBy'
        ]
      }
    },
    _typeIsExplicit: { kind: true, enumerable: true, test: () => true  }, // TODO: remove
    type: {
      kind: true,
      required: ['location','path'],
      schema: { query: { test: () => true } }, // TODO: rename query prop in name
      optional: [
        'scope','_artifact','$inferred', // TODO: remove the rest
        'calculated',                    // TODO: remove calculated
        'resolveSemantics',              // replace by scope: 'typeOf'
        'absolute','element','alias','query','action','param' // do not set in compiler
      ]
    },
    target: { kind: true, inherits: 'type' },
    path: {
      test: isVector( pathItem ),
      required: ['location','id'], // TODO: it can be `func` instead of `id` later
      // TODO: rename namedArgs to args
      optional: ['quoted','namedArgs','where','cardinality','_artifact','_navigation']
    },
    id: { test: string },
    kind: { test: string },
    value: {
      kind: true,
      test: expression,         // properties below are "sub specifications"
      ref: { inherits: 'type' },
      val: {
        required: ['literal','location'],
        // TODO: remove augmented, rename symbol to sym
        optional: ['val','symbol','augmented'] // struct only for annotation assignments
      },
      op: {
        required: ['op','location','args'],
        optional: ['func','quantifier','$inferred','augmented']
      },
      query: { inherits: 'query' }
    },
    args: { inherits: 'value', test: args },
    onCond: { kind: true, inherits: 'value' },
    on: { kind: true, test: () => true }, // TODO: rename 'onCond' to 'on', remove 'on'
    where: { inherits: 'value' },
    having: { inherits: 'value' },
    op: { required: ['location', 'val'] }, // TODO: make it 'id' instead of 'val'
    augmented: { enumerable: false, test: () => true }, // FIXME: remove
    // preliminary -----------------------------------------------------------
    '@': { kind: true, test: () => true },
    annotationAssignments: { kind: true, test: () => true },
    name: {
      kind: true,
      schema: { query: { test: () => true } }, // TODO: rename query prop in name
      required: ['location'],
      optional: [
        'path','id','quoted',            // TODO: req path, opt id for main, req id for member
        '$mixin',                        // TODO: delete, use kind = 'mixin'
        '_artifact','$inferred',
        'calculated',                    // TODO: remove calculated
        'absolute','element','alias','query','action','param'
      ]
    },
    expectedKind: { kind: ['extend'], test: () => true },
    abstract: { kind: true, test: () => true },
    virtual: { kind: true, test: () => true },
    key: { kind: true, test: () => true },
    masked: { kind: true, test: () => true },
    notNull: { kind: true, test: () => true },
    includes: { kind: true, test: () => true },
    returns: { kind: true, test: () => true },
    dbType: { kind: true, test: () => true },
    temporary: { kind: true, test: () => true },  // TODO: HANA-CDS - keep?
    source: { kind: true, test: () => true }, // TODO: remove in JSON/CDL parser
    projection: { kind: true, test: () => true }, // TODO: remove in JSON/CDL parser
    technicalConfig: { kind: ['entity'], test: () => true },
    sequenceOptions: { kind: true, test: () => true }, // hanaFlavor
    targetElement: { kind: true, test: () => true },   // for foreign keys
    indexNo: { kind: true, test: () => true },
    artifacts: { kind: true, test: () => true }, // just test whether in definitions
    artifacts_: { kind: true, parser: true, test: () => true  }, // TODO: remove
    blocks: { kind: true, test: () => true },    // make it $blocks ?
    length: { kind: true, test: () => true },
    precision: { kind: true, test: () => true },
    scale: { kind: true, test: () => true },
    localized: { kind: true, test: () => true },
    items: { kind: true, test: () => true },
    cardinality: { kind: true, test: () => true },
    default: { kind: true, test: () => true },
    typeArguments: { kind: true, test: () => true }, // TODO: only in CDL parser or compiler w errors
    $tableAliases: { kind: true, test: () => true }, // containing $self outside queries
    _block: { kind: true, test: () => true },
    _parent: { kind: true, test: () => true },
    _main: { kind: true, test: () => true },
    _finalType: { kind: true, test: () => true },
    queries: { kind: true, test: () => true }, // TODO: $queries with other structure
    _leadingQuery: { kind: true, test: () => true },
    $replacement: { kind: true, test: () => true }, // for smart * in queries
    origin: { kind: true, test: () => true }, // TODO: define some _origin
    $from: { kind: true, test: () => true }, // all table refs necesary to compute elements
    _origTarget: { kind: true, test: () => true }, // for REDIRECTED TO
    _$next: { kind: true, test: () => true }, // next lexical search environment for values
    _extend: { kind: true, test: () => true }, // for collecting extend/annotate on artifact
    _annotate: { kind: true, test: () => true }, // for collecting extend/annotate on artifact
    _extension: { kind: true, test: () => true }, // on artifact to its "super extend/annotate" statement
    _deps: { kind: true, test: () => true },      // for cyclic calculation
    _scc: { kind: true, test: () => true },       // for cyclic calculation
    _sccCaller: { kind: true, test: () => true }, // for cyclic calculation
    _status: { kind: true, test: () => true },    // TODO: $status
    _projections: { kind: true, test: () => true }, // for mixin definitions
    $extension: { kind: true, test: () => true }, // TODO: introduce $applied instead or $status
    $inferred: { parser:true, kind: true, test: string },
    calculated: { kind: true, test: () => true }, // TODO remove
    viaAll: { kind: true, test: () => true },     // TODO remove
    implicitForeignKeys: { kind: true, test: () => true }, // TODO: do it with $inferred with object value
    redirected: { kind: true, test: () => true }, // TODO: do it with not-$inferred
  }
  var _noSyntaxErrors = null;
  assertProp( model, null, '' );
  return

  function noSyntaxErrors() {
    if (_noSyntaxErrors != null)
      return _noSyntaxErrors;
    // TODO: currently, we only have errors - use hasErrors() later
    if (stageParser || !model.sources) {
      _noSyntaxErrors = !(model.messages && model.messages.length);
      return _noSyntaxErrors;
    }
    for (let file in model.sources) {
      let s = model.sources[file];
      if (s.messages && model.messages.length) {
        _noSyntaxErrors = false;
        return _noSyntaxErrors;
      }
    }
    _noSyntaxErrors = true;
    return _noSyntaxErrors;
  }

  function assertProp( node, parent, prop, extraSpec ) {
    let spec = extraSpec || schema[ prop ] || schema[ prop.charAt() ];
    if (!spec)             // TODO temp
      spec = { test: () => true };
    else if (spec.inherits)
      spec = Object.assign( {}, schema[ spec.inherits ], spec );

    if (prop) {
      let char = prop.charAt();
      let parser = ('parser' in spec) ? spec.parser : char !== '_' && char !== '$';
      if (stageParser && !parser)
        throw new Error( `Non-parser property '${prop}' set by ${model.$frontend||''} parser${at( [node, parent] )}` );
      let enumerable = ('enumerable' in spec) ? spec.enumerable : char !== '_';
      if (parent.propertyIsEnumerable(prop) !== enumerable)
        throw new Error( `Unexpected enumerability ${!enumerable}${at( [node, parent], prop )}` );
    }
    (spec.test||standard)( node, parent, prop, spec );
  }

  function definition( node, parent, prop, spec, name ) {
    if (!(node instanceof Array))
      node = [node];
    // TODO: else check that there is a redefinition error
    for (let art of node) {
      standard( art, parent, prop, spec, name );
    }
  }

  function pathItem( node, ...args ) {
    if (node !== null || noSyntaxErrors())
      standard( node, ...args );
  }

  function standard( node, parent, prop, spec, name ) {
    if (!node || typeof node !== 'object' || Object.getPrototypeOf( node ) !== Object.prototype)
      throw new Error( `Expected standard object${at( [null, parent], prop, name )}` );

    let names = Object.getOwnPropertyNames( node );
    let required = stageParser && spec.reqParser || spec.required;
    // Do not test 'required' with parse errors:
    for (let p of required || []) {
      // if (!names.includes(p) && (noSyntaxErrors() || spec.isReqWithParseErrors))
      if (!names.includes(p) && (noSyntaxErrors() || p === 'location' && names.length))
        throw new Error( `Required property '${p}' missing in object${at( [node, parent], prop, name )}` );
    }
    let optional = stageParser && spec.optParser || spec.optional || [];
    for (let n of names) {
      let opt = (optional instanceof Array)
                ? optional.includes( n ) || optional.includes( n.charAt() )
                : optional( n, spec );
      if (!(opt || required && required.includes( n ))) {
        throw new Error( `Property '${n}' is not expected${at( [node[n], node, parent], null, name )}` );
      }
      assertProp( node[n], node, n, spec.schema && spec.schema[n] );
    }
  }

  function thoseWithKind( prop, spec ) {
    let those = spec.schema && spec.schema[ prop ] || schema[ prop ] || schema[ prop.charAt() ];
    return those && those.kind;
  }

  function query( node, parent, prop, spec ) {
    while (node instanceof Array) {
      if (node.length !== 1)
        throw new Error( `Unexpected length ${node.length} for query expression${at( [node, parent], prop )}` );
      // TODO: also check getOwnPropertyNames(node)
      node = node[0];
    }
    if (!node || typeof node !== 'object' || Object.getPrototypeOf( node ) !== Object.prototype)
      throw new Error( `Expected standard object${at( [null, parent], prop )}` );

    if (node.op && node.op.val !== 'query')
      standard( node, parent, prop, spec.op );
    else
      standard( node, parent, prop, spec.select );
  }

  function expression( node, parent, prop, spec, idx ) {
    while (node instanceof Array) {
      // TODO: also check getOwnPropertyNames(node)
      if (node.length !== 1) {
        node.map( n => ( n, parent, prop, spec ) )
        return;
      }
      node = node[0];
    }
    if (!node || typeof node !== 'object' || Object.getPrototypeOf( node ) !== Object.prototype)
      throw new Error( `Expected standard object${at( [null, parent], prop, idx )}` );

    let sub = spec[ expressionSpec(node) ];
    if (sub.inherits)
      sub = Object.assign( {}, schema[ sub.inherits ], sub );
    (sub.test||standard)( node, parent, prop, sub, idx );
  }

  function expressionSpec( node ) {
    if (node.path)
      return 'ref';
    else if (node.literal || node.val)
      return 'val';
    else if (node.op && typeof node.op.val === 'string' && queryOps[ node.op.val ])
      return 'query';
    else
      return 'op';
  }

  function args( node, parent, prop, spec ) {
    if (!(node instanceof Array))
      throw new Error( `Expected array${at( [null, parent], prop )}` );
    if (parent.op && parent.op.val === 'xpr') // remove keywords for `xpr` expressions
      node = node.filter( a => typeof a !== 'string');
    node.forEach( (item, idx) => expression( item, parent, prop, spec, idx ) );
  }

  function string( node, parent, prop ) {
    if (typeof node !== 'string')
      throw new Error( `Expected string${at( [node, parent], prop )}` );
      // TODO: also check getOwnPropertyNames(node)
  }

  function at( nodes, prop, name ) {
    let n = (typeof name === 'number') ? ` for index ${name}` : name ? ` for "${name}"` : '';
    let loc = nodes.find( o => o && typeof o === 'object' && o.location );
    let f = (prop && loc !== nodes[0]) ? ` in property '${prop}'` : '';
    let l = loc && locationString( loc.location ) || model.filename;
    return (!l) ? n+f : n+f+' at '+l;
  }

  function isDictionary( func ) {
    return function dictionary( node, parent, prop, spec ) {
      // if (!node || typeof node !== 'object' || Object.getPrototypeOf( node ))
      //   console.log(node,prop,model.$frontend)
      if (!node || typeof node !== 'object' || Object.getPrototypeOf( node ))
        throw new Error( `Expected dictionary${at( [null, parent], prop )}` );
      for (let n in node)
        func( node[n], parent, prop, spec, n );
    }
  }

  function isVector( func ) {
    return function vector( node, parent, prop, spec ) {
      if (!(node instanceof Array))
        throw new Error( `Expected array${at( [null, parent], prop )}` );
      node.forEach( (item, n) => func( item, parent, prop, spec, n ) );
    }
  }
}

module.exports = assertConsistency;
