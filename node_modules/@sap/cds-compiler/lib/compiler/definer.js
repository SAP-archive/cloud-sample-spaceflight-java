// Compiler phase "define": transform dictionary of AST-like CSNs into augmented CSN

// AST-like CSN looks as follows:
//   { kind: 'source', env: <dictionary of artifact defs>, namespace: {}, ... }
//
// The property `artifacts` of a source contains the top-level definitions.
// Definitions inside a context are not listed here (as opposed to
// `definitions`, see below), but inside the property `artifacts` of that context.

// The define phase (function 'initSources' below) enriches a dictionary of
// (file names to) AST-like CSNs and restructure them a little bit, the result
// is called "augmented CSN":
//   { sources: <dictionary of ASTs>, definitions: <dictionary of artifact defs> }
//
// The property `sources` is the input argument (dictionary of source ASTs).
//
// The property `definitions` is set by this compiler phase.  It contains the
// definitions of all main artifacts (i.e. not elements) from all sources, the
// key is the absolute name of that artifact.  These definitions are the same
// objects as the definitions accessible via `sources` and `artifacts` of the
// corresponding source/context.
//
// Because different sources could define artifacts with the same absolute
// name, this compiler phase also put a property `messages` to the resulting
// model, which is a vector of messages for the redefinitions.  (Using the same
// name for different definitions in one source is already recognized during
// parsing.)
//
// You get the compact "official" CSN format by applying the function exported
// by "../json/compactor.js" to the augmented CSN.

// Example 'file.cds':
//   namespace A;
//   context B {
//     type C { elem: String(4); }
//   }
// Check the augmented CSN by compiling it with
//   cdsv --raw-output file.cds
//
// ┌───────────────┐           ┌───────────────────────────────────────────┐
// │    sources    │           │                 definitions               │
// └──┬────────────┘           └──┬────────────────────────────┬───────────┘
//    │                           │                            │
//    │ ['file.cds']              │ ['A.B']                    │ ['A.B.C']
//    ↓                           ↓                            ↓
// ┌───────────────┐  _parent  ┌────────────────┐  _parent  ┌──────────────┐
// │ kind:'source' │←──────────┤ kind:'context' │←──────────┤ kind: 'type' │
// │ artifacts: ───┼──────────→│ artifacts: ────┼──────────→│ ...          │
// └───────────────┘   ['B']   └────────────────┘   ['C']   └──────────────┘
//
// The _parent properties are not shown in the JSON - they are used for name
// resolution, see file './resolver.js'.

// An artifact definition looks as follows (example: context "A.B" above):
//   {
//     kind: 'context',
//     name: { id: 'B', absolute: 'A.B', location: { <for the id "B"> } },
//     artifacts: <for contexts, a dictionary of artifacts defined within>,
//     location: { <of the complete artifact definition> } },
//     _parent: <the parent artifact, here the source 'file.cds'>
//   }
// The properties `name.absolute`, `name.component` and `_parent` are set
// during this compiler phase.

// The definition of an entity or a structured type would contain an `elements`
// property instead of an `artifacts` property.

// An element definition looks as follows (example: "elem" above):
//   {
//     kind: 'element',
//     name: { id: 'elem', component: 'elem', location: { <for the id "elem"> } }
//     type: { path: [ { id: 'String', location: ... } ] },
//     typeArguments: [ { number: '4', location: ... } ]
//     location: { <of the complete element definition> } },
//     _parent: <the parent artifact, here the type "A.B.C">
//   }
// References are resolved in the "resolve" phase of the compiler, see
// './resolver.js'.  We then get the properties `type.absolute` and `length`.

'use strict';

const { msgName } = require('../base/messages');
const { kindProperties, queryOps, setProp, forEachGeneric, forEachInOrder, forEachMember }
      = require('../base/model');
var { addToDict, addToDictWithIndexNo, clearDict, dictLocation, pushToDict }
    = require('../base/dictionaries');
const { fns, linkToOrigin, setMemberParent, storeExtension, combinedLocation } = require('./shared');
var initBuiltins = require('./builtins');

// Export function of this file.  Transform argument `sources` = dictionary of
// AST-like CSNs into augmented CSN.  If a vector is provided for argument
// `messages` (usually the combined messages from `parse` for all sources), do
// not throw an exception in case of an error, but push the corresponding error
// object to that vector.  If at least one AST does not exist due to a parse
// error, set property `lintMode` of `options` to `true`.  Then, the resolver
// does not report errors for using directives pointing to non-existing
// artifacts.
function define( model, options = model.options || {} ) {
  // Get simplified "resolve" functionality and the message function:
  const {
    resolveUncheckedPath,
    resolvePath,
    defineAnnotations,
    message
  } = fns( model );
  model.definitions = Object.create(null);
  // model.annotations = Object.create(null);

  var extensionsDict = Object.create(null);
  initBuiltins( model );
  for (let name in model.sources) {
    initSource( model.sources[name] );
  }
  applyExtensions();
  forEachGeneric( model, 'definitions', checkRedefinitions );
  return model;

  function checkRedefinitions( obj, name, prop, i ) {
    forEachMember( obj, checkRedefinitions );
    if (i == undefined)
      return;
    let loc = obj.name.location;
    if (prop === 'elements')
      message( `Duplicate definition of element ${msgName( name )}`, loc );
    else if (prop === 'enum')
      message( `Duplicate definition of enum ${msgName( name )}`, loc );
    else if (prop === 'foreignKeys')
      message( `Duplicate definition of foreign key ${msgName( name )}`, loc );
    else if (prop === 'actions')
      message( `Duplicate definition of action or function ${msgName( name )}`, loc );
    else if (prop === 'params')
      message( `Duplicate definition of parameter ${msgName( name )}`, loc );
    else if (obj.kind === 'namespace')
      message( `Other definition blocks ${msgName( name )} for namespace name`, loc );
    else
      message( `Duplicate definition of artifact ${msgName( name )}`, loc );
  }

  function initSource( src ) {
    // handle sub model from CSN parser
    if (!src.kind)
      src.kind = 'source';
    if (src.definitions) {
      forEachGeneric( src, 'definitions', function( art, name ) {
        if (!art.kind)            // TODO: should be done by augmentor
          art.kind = 'type';
        let dot = name.lastIndexOf('.');
        if (dot > name.indexOf('::')) // there is a dot (after '::')
          addAsContextArtifact( art, name.substring(dot+1), name.substring(0,dot), src );
        setProp( art, '_block', src );
        addToDefinitions( art, name );
        initMembers( art, art, src );
      });
      initArtifacts( src, null, src, true, null, 'definitions' );
    }
    // handle sub model from CDL parser, handle `extensions` in sub models
    // (from all parsers) by `initArtifacts) argument collectExts = true
    initUsings( src, src.usings );
    let decl = src.namespace;
    let prefix = (decl && decl.dcPath) ? pathName(decl.dcPath) + '::' : '';
    let namespace = decl && decl.path && namespaceContext( decl.path, prefix, undefined, decl.location );
    if (!namespace) {
      // also handles `extensions` property
      initArtifacts( src, namespace, src, true, prefix );
    }
    else {
      setProp( decl, '_artifact', namespace );
      // create using for own namespace:
      let last = decl.path[ decl.path.length - 1 ];
      let builtin = model.$builtins[ last.id ];
      if (builtin && !builtin.internal) {
        message( `You might also need 'using ${builtin.name.absolute};'`,
                 src.namespace.location, 'Info' );
      }
      let block = {
        kind: 'source', filename: src.filename,
        name: { id: last.id, location: last.location }, // for --raw-output
        artifacts: Object.create(null)
      };
      let absolute = namespace.name.absolute;
      block.artifacts[ last.id ] = { // assert( last.id === namespace.name.id )
        kind: 'using',               // TODO: or store namespace directly?
        //implicit: true,
        name: { id: last.id, absolute, location: last.location, calculated: true, $inferred: 'as' },
        extern: decl,
        location: decl.location
      };
      setProp( src, '_block', block );
      initArtifacts( src, namespace, src, true );
    }
  }

  function namespaceContext( path, prefix = '', parent, declLocation ) {
    let absolute;
    for (let item of path) {
      let id = item.id;
      absolute = (absolute) ? absolute + '.' + id : prefix + id;
      let context = model.definitions[absolute];
      if (!context || context instanceof Array ||
          !kindProperties[ context.kind ].artifacts) {
        let location = combinedLocation( path[0], item );
        context = {
          kind: 'namespace',
          name: { id, location, absolute },
          blocks: [],
          artifacts: Object.create(null),
          location: declLocation || location
        };
        if (parent) {
          if (!parent.artifacts)
            parent.artifacts = Object.create(null);
          addToDict( parent.artifacts, id, context );
        }
        addToDefinitions( context, absolute );
      }
      setProp( item, '_artifact', context );
      parent = context;
    }
    return parent;
  }

  // Set property `name.absolute` or artifact `art` to `absoluteName`.  Also
  // store `art` in the `definition` property of the model and complain if
  // another artifact has already been defined with the same absolute name.
  function addToDefinitions( art, absolute = art.name.absolute, prefix, parent ) {
    let context = reuse();
    //console.log(context?'Reuse':'Def',art.name,prefix ,parent&&parent.name)
    if (context)
      return context;
    if (prefix != null && art.name.path && art.name.path.length > 1) {
      let path = [...art.name.path];
      let id = path.pop();
      art.name.id = id.id;
      context = namespaceContext( path, prefix, parent );
      addToDict( context.artifacts, id.id, art );
    }
    else if (parent && art.name.path) {
      addToDict( parent.artifacts, art.name.path[0].id, art );
    }
    addToDict( model.definitions, absolute, art );
    return art;

    function reuse( ) {
      if (!kindProperties[ art.kind ].artifacts)  // no context, service or namespace
        return undefined;
      let found = model.definitions[absolute];
      if (!found || found instanceof Array)
        return undefined;
      if (art.kind === 'namespace' && kindProperties[ found.kind ].artifacts)
        // we are namespace, `found` is context, service or namespace
        return found;
      if (found.kind !== 'namespace')
        return undefined;
      found.kind = art.kind;    // use non-namespace kind
      found.name = art.name;    // use name (its location!) of definition
      return found;
    }
  }

  function addAsContextArtifact( art, id, contextName, src ) {
    let context = src.definitions[contextName];
    if (!context) {
      let location = art.name.location;
      let colons = contextName.indexOf('::');
      colons = (colons < 0) ? 0 : colons + 2;
      let path = contextName.substring(colons).split('.').map( id => ({ id, location }) );
      context = namespaceContext( path, contextName.substring(0,colons), undefined, location );
    }
    if (context instanceof Array || !context.kind) // no proper construct
      return;
    if (!kindProperties[ context.kind ].artifacts) // no context or service
      return;
    if (!context.artifacts)
      context.artifacts = Object.create(null);
    addToDict( context.artifacts, id, art );
  }

  // Initialize the USING declarations in source `src`.  Add the corresponding
  // names to the top-level search environment of the source, and set the
  // absolute name referred by the USING declaration.
  function initUsings( src, usings ) {
    if (!usings)
      return;
    if (!src.artifacts)
      src.artifacts = Object.create(null);
    for (let def of usings) {
      if (def.usings) {
        initUsings( src, def.usings );
        continue;
      }
      let ue = def.extern;
      if (!def.name) {
        def.name = Object.assign( { calculated: true, $inferred: 'as' },
                                  ue.path[ ue.path.length - 1] );
      }
      if (!(ue.path.broken || ue.dcPath && ue.dcPath.broken)) {
        def.name.absolute = (ue.dcPath)
          ? pathName(ue.dcPath) + '::' + pathName(ue.path)
          : pathName(ue.path);
      }
      addToDict( src.artifacts, def.name.id, def, function( name, loc ) {
        message( `Duplicate definition of top-level name ${msgName( name )}`, loc );
      } );
    }
  }

  // Set property `_parent` for all sub artifact in `parent` to `parent` and do
  // so recursively for all sub artifacts.  Also set the property
  // `name.absolute` of all those artifacts with the help of argument `prefix`
  // (which is basically the absolute name of `parent` plus a dot).  If a sub
  // artifact has elements, call function `initElements`.
  function initArtifacts( construct, parent, block, collectExts,
                          prefix = parent.name.absolute + '.', defProp ) {
    if (parent && !checkDefinitions( construct, parent, 'artifacts' ))
      return;
    // TODO: the checkDefinitions must be propably checked by the parsers
    //let dottedNames = [];
    //let namespaces = Object.create(null);
    for (let name of Object.keys( construct.artifacts || {} )) { // setName adds items
      let def = construct.artifacts[name];
      if (def instanceof Array) {
        for (let art of def)
          setName( art, name );
      }
      else {
        setName( def, name );
      }
    }
    // defineAnnotations() and collectArtifactExtensions() in init() requires
    // names of other artifacts in context
    // var namespaceParent = { artifacts: Object.create(null) };
    forEachGeneric( construct, defProp || 'artifacts', init );
    if (collectExts)
      collectArtifactExtensions( construct, block );
    return;

    function setName( art, pathName ) {
      if (art.kind === 'using')
        return;
      setProp( art, '_block', block );
      art.name.absolute = prefix + pathName;
      let path = art.name.path;
      if (!path || path.length <= 1)
        return;
      let root = path[0];
      let id = root.id;
      let namespace = namespaceContext( [root], prefix, parent );
      if (construct.artifacts[id])
        // TODO: complain if USING uses that name
        return;                 // TODO: do we need to set root._artifact?
      let name = { absolute: prefix + id, id, location: root.location };
      setProp( name, '_artifact', namespace );
      construct.artifacts[id] = { kind: 'block', name, pathPrefix: true };
    }

    function init( art ) {
      if (art.pathPrefix || art.kind === 'using') // real.path as name, or using proxies
        return;
      if (kindProperties[ art.kind ].artifacts) { // context or service
        if (defProp) {                            // from JSON parser
          defineAnnotations( art, art, block );
          art.blocks = [null];  // TODO: assert that there are no blocks before
          if (!art.artifacts)   // if art had been no namespace before
            art.artifacts = Object.create(null); // TODO: test with A.B.C then A.B in definitions
          return;
        }
        let env = art;
        art = addToDefinitions( shallowContext(env), undefined, prefix, parent );
        env.kind = 'block';
        env.name.query = art.blocks.length;
        setProp( env.name, '_artifact', art );
        art.blocks.push( env );
        defineAnnotations( env, art, block ); // requires name.absolute of siblings!
        initArtifacts( env, art, env, collectExts );
        // initMembers(art, art, block); // if we define "service-bound" actions
      }
      else if (art.query) {     // view or projection
        if (!defProp)
          addToDefinitions( art, undefined, prefix, parent );
        defineAnnotations( art, art, block );
        if (defProp) {
          initMembers( art, art, block );               // augmentor bug workaround
          return;
        }
        art.$from = [];         // for sequence of resolve steps
        art.queries = [];
        setProp( art, '_leadingQuery', initQueryExpression( art, art.query ) );
        art.queries.forEach( initSubQuery ); // TODO: per art.query
        // TODO: simplified for simple views = just one query with one table source
        if (art.query.from && art.query.from.length === 1 && art.query.from[0] && art.query.from[0].path)
          art.source = art.query.from[0];
        // resolve parameters and actions:
        initMembers( art, art, block ); // before setting art.elements! 
        // TODO: Also allow extension if without union (even then, but later
        // check checks whether union can be used)?
        if (art._leadingQuery)
          art.elements = art._leadingQuery.elements;
        if (!options.hanaFlavor)
          initDollarSelf( art ); // to allow extend projection with auto-mixin assoc, see #924
      }
      else {
        if (!defProp)
          addToDefinitions( art, undefined, prefix, parent );
        defineAnnotations( art, art, block );
        initMembers( art, art, block );
        let absolute = art.name.absolute;
        if (art.includes && !(absolute in extensionsDict))
          extensionsDict[absolute] = []; // structure with includes must be "extended"
        if (art.elements)
          initDollarSelf( art );
      }
    }

    function initDollarSelf( art ) {
      let selfname = (options.hanaFlavor) ? art.name.id : '$self';
      art.$tableAliases = Object.create(null);
      art.$tableAliases[selfname] = {
        name: { id: selfname, alias: selfname, absolute: art.name.absolute },
        kind: '$tableAlias', self: true,
        type: {},
        location: art.location };
      setProp( art.$tableAliases[selfname].type, '_artifact', art );
      if (options.oldstyleSelf)
        art.$tableAliases.self = art.$tableAliases[selfname];
    }
  }

  function initSubQuery( query ) {
    query.queries = [];
    if (query.on)
      initExprForQuery( query.on, query );
    // TODO: MIXIN with name = ...subquery
    for (let name in query.elements) {
      let elem = query.elements[name];
      if (elem && elem.value)
        initExprForQuery( elem.value, query ); // adds to query.queries
    }
    if (query.where)
      initExprForQuery( query.where, query );
    if (query.having)
      initExprForQuery( query.having, query );
    for (let sub of query.queries) {
      initSubQuery( sub );
      setProp( sub, '_$next', query ); // for name resolution
    }
    initMembers( query, query, query._block );
  }

  function initExprForQuery( expr, query ) {
    if (expr instanceof Array)
      expr.forEach( e => initExprForQuery( e, query ) );
    else if (!expr || !expr.op)
      return;
    else if (expr.op && queryOps[ expr.op.val ]) {
      initQueryExpression( query, expr ); // adds to query.queries
    }
    else if (expr.args)
      expr.args.forEach( e => initExprForQuery( e, query ) );
  }

  // for an example, see view V006 in test/fromHanaCDS/positive/Queries_Subquery_ok
  function initQueryExpression( art, query, parents = [] ) {
    while (query instanceof Array) // query / join args in parentheses
      query = query[0];
    if (!query)                 // parse error
      return query;

    if (query.path) {           // path in FROM - this query is a table ref
      if (!query.path.length || query.path.broken)
        // parse error (e.g. final ',' in FROM), projection on <eof>
        return query;
      if (!query.name) {
        let last = query.path[ query.path.length-1 ];
        let dot  = last.id.lastIndexOf('.');
        let id   = (dot < 0) ? last.id : last.id.substring( dot+1 );
        // TODO: if we have too much time, we can calculate the real location with '.'
        query.name = { calculated: true, $inferred: 'as', id, location: last.location };
      }
      addAlias( { type: query }, query );
      if (art.kind !== 'query')
        art.$from.push( query ); // store tabref if outside "real" subquery
    }
    else if (query.join) {
      if (query.on) {
        addQuery();
        parents = [...parents, query];
      }
      for (let tab of query.args)
        initQueryExpression( art, tab, parents );
    }
    else if (query.op && query.op.val === 'query') { // select
      addQuery();
      if (parents.length)
        // It is ensured that query.elements is defined (see `queryTerm` in grammar)
        addAlias( { elements: query.elements }, query );
      for (let tab of query.from)
        initQueryExpression( art, tab, [query] );
      if (query.mixin)
        addMixin();
      if (!query.$tableAliases.$projection) {
        query.$tableAliases.$projection = {
          name: { alias: '$projection', query: query.name.query, absolute: art.name.absolute },
          kind: '$tableAlias', self: true,
          elements: query.elements, // TODO: shouldn't we set type._artifact: query instead?
          location: query.location };
      }
    }
    else if (query.args) {      // UNION, INTERSECT, ..., sub query
      let leading = initQueryExpression( art, query.args[0], [] );
      for (let q of query.args.slice(1))
        initQueryExpression( art, q, [] );
      setProp( query, '_leadingQuery', leading );
      if (query.orderBy) {
        if (leading.$orderBy)
          leading.$orderBy.push( ...query.orderBy );
        else
          leading.$orderBy = [ ...query.orderBy ];
        query.orderBy.forEach( ob => setProp( ob, '_$queryNode', query ) ); // TODO: we can again remove that
      }
      // ORDER BY to be evaluated in leading query (LIMIT is literal)
      if (parents.length)
        addAlias( { elements: leading.elements }, leading );
    }
    // else: with parse error (`select from <EOF>`)
    return query._leadingQuery || query;

    function signalDuplicate( name, loc ) {
      message( `Duplicate definition of table alias or mixin ${msgName( name )}`, loc );
    }

    function addAlias( alias, subquery ) {
      if (!query.name || !query.name.id) {
        message( `Table alias is required for this subquery`, query.location );
        return;
      }
      let name = { id: query.name.id, location: query.name.location };
      Object.assign( alias, { name, kind: '$tableAlias', location: query.location } );
      let parent = parents[0];
      setMemberParent( alias, name.id, parent );
      if (!parent._firstAliasInFrom)
        setProp( parent, '_firstAliasInFrom', alias );
      setProp( subquery, '_tableAlias', alias );
      for (let p of parents) {
        //console.log('ADD:', query.name.id, parents.length, p)
        addToDict( p.$tableAliases, alias.name.id, alias, p === parent && signalDuplicate );
      }
    }

    function addMixin() {
      // TODO: re-check if mixins have already duplicates
      for (let name in query.mixin) {
        let mixin = query.mixin[name];
        if (!(mixin instanceof Array)) {
          setMemberParent( mixin, name, query );
          // TODO: without old CSN: delete 'alias & $mixin', keep element and set kind='mixin'
          mixin.name.alias = mixin.name.element;
          delete mixin.name.element;
          mixin.name.$mixin = true;
          setProp( mixin, '_block', art._block );
          // TODO: do some initMembers() ?  If people had annotation
          // assignments on the mixin... (also for future mixin definitions
          // with generated values)
          addToDict( query.$tableAliases, name, query.mixin[name], signalDuplicate );
        }
      }
    }

    function addQuery() {
      // TODO: set $next
      setProp( query, '_block', art._block );
      query.kind = 'query';
      if (!query.name)
        query.name = { location: query.location };
      setMemberParent( query, art.queries.length, art );
      art.queries.push( query );
      query.$tableAliases = Object.create( null ); // table aliases and mixin definitions
    }
  }

  function shallowContext( ext ) {
    let art = {
      kind: ext.kind,
      name: Object.assign( {}, ext.name ),
      blocks: [],
      artifacts: Object.create(null),
      location: ext.location
    };
    setProp( art, '_block', null ); // prevent usage
    return art;
  }

  // Set property `_parent` for all elements in `parent` to `parent` and do so
  // recursively for all subelements.  Also set the property
  // `name.component` of the element with the help of argument `prefix`
  // (which is basically the component name of the `parent` element plus a dot).
  function initMembers( construct, parent, block ) {
    let isQueryExtension = kindProperties[ construct.kind ].isExtension &&
                           (parent._main||parent).query;
    let obj = construct.returns || construct; // why the extra `returns` for actions?
    if (construct.returns)
      setProp( obj, '_artifact', construct ); // TODO: remove this `returns` property

    obj = obj.items || obj;
    if (obj !== parent && obj.elements && parent.enum) {
      for (let n in obj.elements) {
        let e =  obj.elements[n];
        if (e.kind === 'element')
          e.kind = 'enum';
        delete e.indexNo;
      }
      // obj = Object.assign( { enum: obj.elements}, obj );
      // delete obj.elements;      // No extra syntax for EXTEND enum
      forEachGeneric( { enum: obj.elements }, 'enum', init );
    }
    else {
      if (obj.elements && checkDefinitions( construct, parent, 'elements', obj.elements ))
        forEachInOrder( obj, 'elements', init );
      if (obj.enum && checkDefinitions( construct, parent, 'enum', obj.enum ))
        forEachGeneric( obj, 'enum', init );
    }
    if (obj.foreignKeys)  // cannot be extended or annotated - TODO: check anyway?
      forEachInOrder( obj, 'foreignKeys', init );
    if (construct.actions && checkDefinitions( construct, parent, 'actions' ))
      forEachGeneric( construct, 'actions', init );
    if (construct.params && checkDefinitions( construct, parent, 'params' ))
      forEachInOrder( construct, 'params', init );
    return;

    function init ( elem, name, prop ) {
      if (!elem.name) {
        let ref = elem.targetElement || elem.kind === 'element' && elem.value;
        if (ref && ref.path) {
          elem.name = Object.assign( { calculated: true, $inferred: 'as' },
                                     ref.path[ ref.path.length-1 ] );
        }
        else {                  // if JSON parser misses to set name
          elem.name = { id: name, location: elem.location };
        }
      }
      if (kindProperties[ elem.kind ].isExtension) {
        storeExtension( elem, name, prop, parent, block );
      }
      else if (isQueryExtension && elem.kind === 'element') {
        message( `Query entity ${msgName( parent._main||parent )} can only be extended with actions`, elem.location );
      }
      else {
        setProp( elem, '_block', block );
        setMemberParent( elem, name, parent, construct !== parent && prop );
        defineAnnotations( elem, elem, block );
        initMembers( elem, elem, block );
      }
    }
  }

  function checkDefinitions( construct, parent, prop, dict = construct[prop] ) {
    let feature = kindProperties[ parent.kind ][prop];
    if (feature &&
        (feature === true || construct.kind !== 'extend' || feature( prop, parent )))
      return true;
    let propname = (prop === 'enum') ? 'enum symbols' : prop;
    let where = {
      element: 'an element',
      action: 'an action',
      param: 'a parameter',
    }[parent.kind] || `artifact "${parent.name.absolute}"`;
    // TODO: no constructed messages
    message( (construct.kind !== 'extend')
             ? 'You cannot define ' + propname + ' inside ' + where
             : 'You cannot add ' + propname + ' to ' + where + ' via EXTEND',
             dictLocation( dict ) );
    // If the members are directly defined, define them anyway - ignore them
    // for extensions
    return construct === parent;
  }

  // Collect all artifact extensions
  function collectArtifactExtensions( construct, block ) {
    for (let ext of construct.extensions || []) {
      setProp( ext, '_block', block );
      // complain about non-existent path base, but do not check complete path:
      // normal ref in outer extend, relative ref inside EXTEND CONTEXT
      let name = resolveUncheckedPath( ext.name, ext.kind, block );
      // TODO: somehow provide expectedKind as filter?
      if (name) {
        pushToDict( extensionsDict, name, ext );
        // an extend with main artifact extension is a block
        collectArtifactExtensions( ext, ext );
      }
    }
  }

  // phase 1: context extends, 2: extends with structure includes, 3: extends
  // without structure includes (in the case of cyclic includes)
  //
  // Before phase 1: all artifact extensions have been collected (even those
  // inside extend context), only "empty" ones from structure includes are still unknown.
  // After phase 1, all main artifacts are known, also "empty" extensions are known.
  function applyExtensions() {
    let phase = 1;
    let extNames = Object.keys( extensionsDict ).sort();
    // Remark: The sort() makes sure that an extend for artifact C.E is applied
    // after the extend for C has been applied (which could have defined C.E).
    // Looping over model.definitions in Phase 1 would miss the `extend
    // context` for a context C.C defined in an `extend context C`.
    while (extNames.length) {
      let length = extNames.length;
      for (let name of extNames) {
        let art = model.definitions[name];
        if (!art) {
          if (!options.lintMode) {
            // If not lint-mode, complain about unused extensions, i.e. those
            // which do not point to a valid artifact: TODO: not so for i18n
            for (let ext of extensionsDict[name]) {
              resolvePath( ext.name, ext.kind, undefined, ext._block ); // should issue error/info
              if (ext.kind === 'annotate')
                delete ext.name._artifact; // make it be considered by extendArtifact()
            }
            // create "super" ANNOTATE containing all non-applied ones
            let first = extensionsDict[name][0];
            let location = first.name.location;
            art = {
              kind: 'annotate',
              name: { path: [ { id: name, location } ], absolute: name, location },
              location: first.location
            };
            model.extensions ? model.extensions.push(art) : model.extensions = [art];
            extendArtifact( name, art ); // also sets _artifact link in extensions
          }
          delete extensionsDict[name];
        }
        else if (art instanceof Array) { // cannot extend redefinitions
          delete extensionsDict[name];
        }
        else if (phase === 1
                 ? extendContext( name, art )
                 : extendArtifact( name, art, phase > 2 )) {
          delete extensionsDict[name];
        }
      }
      extNames = Object.keys( extensionsDict ); // no sort() required anymore
      if (phase === 1)
        phase = 2;
      else if (extNames.length >= length)
        phase = 3;
    }
  }

  function extendContext( name, art ) {
    // (ext.expectedKind == art.kind) already checked by parser (TODO: modulo context/service)
    if (!kindProperties[ art.kind ].artifacts) // no context or service
      return false;

    for (let ext of extensionsDict[name]) {
      setProp( ext.name, '_artifact', art );
      if (ext.artifacts) {    // extend context with artifacts
        ext.name.query = art.blocks.length;
        art.blocks.push( ext ); // extend context is block of context
      }
      else if (ext.elements) {
        message( (ext.kind === 'extend')
                 ? `No 'EXTEND artifact' or element definition within 'EXTEND ${art.kind}'`
                 : `No 'ANNOTATE artifact' within 'ANNOTATE ${art.kind}'`,
                 dictLocation( ext.elements ) );
      }
      defineAnnotations( ext, art, ext._block, ext.kind );
      initArtifacts( ext, art, ext );
    }
    return true;
  }

  function extendArtifact( name, art, noIncludes ) {
    if (!noIncludes && art.includes) {
      for (let ref of art.includes) {
        let template = resolvePath( ref, 'include', art, art._block );
        if (template && template.name.absolute in extensionsDict)
          return false;
      }
      includeMembers( art, 'elements', forEachInOrder );
      includeMembers( art, 'actions', forEachGeneric );
    }
    extendMembers( extensionsDict[name], art );
    // TODO: complain about element extensions inside projection
    return true;
  }

  function extendMembers( extensions, art ) {
    let elemExtensions = [];
    for (let ext of extensions) {
      if (!('_artifact' in ext.name)) { // not already applied
        setProp( ext.name, '_artifact', art );
        defineAnnotations( ext, art, ext._block, ext.kind );
        // TODO: do we allow to add elements with array of {...}?  If yes, adapt
        initMembers( ext, art, ext._block ); // might set _extend, _annotate
      }
      if (ext.elements &&       // at least one elem definition (not extension)
          Object.keys( ext.elements ).some( n => ext.elements[n].kind === 'element' ))
        elemExtensions.push( ext.elements );
    }
    if (elemExtensions.length > 1) {
      for (let dict of elemExtensions)
        message( `Unstable element order due to repeated extensions`,
                 dictLocation( dict ), 'Warning' );
    }
    ['elements', 'actions'].forEach( function ext(prop) {
      let dict = art._extend && art._extend[prop];
      for (let name in dict) {
        let member = (art[prop] || prop === 'elements' && art.enum)[name];
        if (!member)
          extendNothing( dict[name], prop, name, art.name.absolute );
        else if (!(member instanceof Array))
          extendMembers( dict[name], member );
      }
    });
  }

  function extendNothing( extensions, prop, name, absolute ) {
    // TODO: re-check messages
    for (let ext of extensions) {
      if (prop === 'elements')
        message( `Element "${name}" has not been found in "${absolute}"`,
                   ext.name.location );
      else if (prop === 'enum')
        message( `Enum symbol "${name}" has not been found in "${absolute}"`,
                 ext.name.location );
      else
        message( `Action "${name}" has not been found in "${absolute}"`,
                 ext.name.location );
    }
  }

  function includeMembers( art, prop, forEach ) {
    // TODO: a projection cannot be used as include, right?
    // TODO two kind of messages:
    // Error 'More than one include defines element "A"' (at include ref)
    // Warning 'Overwrites definition from include "I" (at elem def)
    let members = art[prop];
    clearDict( art, prop );     // TODO: do not set actions property if there are none
    for (let ref of art.includes) {
      let template = resolvePath( ref, 'include', art, art._block );
      if (template) {           // be robust
        forEach( template, prop, function( origin, name ) {
          if (members && name in members)
            return;               // TODO: warning for overwritten element
          let elem = linkToOrigin( origin, name, art, prop, ref.location );
          elem.$inferred = 'include';
          if (origin.masked)
            elem.masked = origin.masked;
          if (origin.key)
            elem.key = origin.key;
          // TODO: also complain if elem is just defined in art
        });
      }
    }
    // TODO: expand elements having direct elements (if needed)
    if (members) {
      forEach( { [prop]: members }, prop, function( elem, name ) {
        addToDictWithIndexNo( art, prop, name, elem );
      });
    }
  }
}

// Return string 'A.B.C' for parsed source `A.B.C` (is vector of ids with
// locations):
function pathName (path) {
  return path.map( id => id.id ).join('.');
}

module.exports = define;
