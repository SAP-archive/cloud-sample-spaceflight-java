const { setProp, forEachDefinition, forEachGeneric, forEachMemberRecursively } = require('../base/model');
const { CompilationError, hasErrors, sortMessages } = require('../base/messages');
const transformUtils = require('./transformUtils');
const { isAssociation } = require('../model/modelUtils');
const alerts = require('../base/alerts');

function preprocessModel(model, tntFlavor) {
  // e.g. signal(error`...`, <artifact>.location);
  const { error, signal } = alerts(model);
  const { preprocessAction, setServiceProperty, checkExposedAssoc } = transformUtils.getTransformers(model, '_');
  // Set '_service' property for all artifacts and sub-artifacts, for each service in the model
  setServiceProperty(model);

  forEachDefinition(model, obj => {
    if (obj.kind !== 'service')
      return;
    forEachGeneric(obj, 'artifacts', art => {
      processElements(art);
      if (art.projection)
        processProjection(obj, art);
      if (art.kind === 'entity' && art.actions)
        Object.keys(art.actions).forEach(a => preprocessAction(art.actions[a]));
      if (art.kind === 'action' || art.kind === 'function')
        preprocessAction(art);
      if (art.kind === 'type')
        processType(obj, art);
    });
  });

  // Throw up if we have errors
  if (hasErrors(model.messages)) {
    throw new CompilationError(sortMessages(model.messages));
  }

  // Preprocess elements of artifact in a service
  // 1. If some element has user defined type:
  //  - If the type definition is structured -> should be exposed in the current service
  //  - If the defined type is builtin -> expand it
  // 2. If a element is association checks if the target is from the current service
  function processElements(art) {
    let currentService = art._service;
    forEachMemberRecursively(art, member => {
      if (member.kind !== 'element')
        return;

      // 1. If the member has for a type a derived one - check if the type definition is
      // from the current service, it is exposed to the current service or builtin
      let memberType = member.items ? member.items.type : member.type;
      if (!memberType)
        return;
      if (!memberType.absolute.startsWith('cds.')) {
        let memberTypeService = memberType._artifact._service || memberType._artifact._main && memberType._artifact._main._service;
        if (memberTypeService !== currentService) {
          // if the type is builtin and not from the current service -> expand it
          if (!art.projection && memberType._artifact.type && memberType._artifact.type.absolute.startsWith('cds.'))
            member.items ? setProp(member.items, '_swaggerExpandType', true) : setProp(member, '_swaggerExpandType', true);
          else if (/* the projection case is handle in processProjection */!art.projection)// structured type not from the current service
            signal(error`The type ${memberType.absolute} of ${member.name.absolute} is not from the service ${currentService.name.absolute}`, member.location);
        }
      }

      // 2. check if the target of the association is part of the current service
      if (!art.projection && isAssociation(member.type)) {
        if (tntFlavor) { /* ugly tnt magic -> to be removed */
          if (member.target && member.target._artifact && member.target._artifact._service != art._service)
            setProp(member, '_swaggerTntString', true);
        } else
          checkExposedAssoc(art, member);
      }
    });
  }

  // if an artifact is a projection on entity not from the current service,
  // then check its elements, if some of the elements:
  //   -> is an association - set a '_swaggerTarget' to the association with a value of the corresponding 
  //      projection(on the target of the assoc in the underlying context) from the current service
  //      or throw an error if the target is not exposed in the current service
  //   -> has a user defined type - check if the type is exposed or not
  function processProjection(parent, art) {
    if (parent._service !== art.source._artifact._service) {
      forEachMemberRecursively(art, elem => {
        if (elem.kind !== 'element')
          return;
        // association redirecting
        if (elem.type && isAssociation(elem.type)) {
          // try to find representation of the association target in the current service
          let targetFromCurrectService = Object.keys(parent.artifacts).filter(artName => parent.artifacts[artName].projection)
            .find(projName =>
              // the projection source with which the reference to be replaced
              parent.artifacts[projName].source._artifact.name.absolute === elem.target._artifact.name.absolute
            );
          if (targetFromCurrectService)
            setProp(elem, '_swaggerTarget', targetFromCurrectService);
          else {
            /* ugly tnt magic -> to be removed*/
            tntFlavor ?
              setProp(elem, '_swaggerTntString', true)
              : signal(error`Association ${elem.name.absolute}.${elem.name.id} cannot be implicitly redirected: Target ${elem.target._artifact.name.absolute} is not exposed in service ${parent.name.absolute} by any projection`, elem.location);
          }
        } else {
          // check the case when the element has a user defined type
          let elemType = elem.items ? elem.items.type : elem.type;
          if (!elemType)
            return;
          if (elemType.absolute.startsWith('cds.'))
            return;
          let elemTypeService = elemType._artifact._service || elemType._artifact._main && elemType._artifact._main._service;
          // the type is not from the current definition
          if (elemTypeService !== parent._service) {
            // try to find the exposition of the type in the current service
            let typeFromCurrectService = Object.keys(parent.artifacts).filter(artName => parent.artifacts[artName].kind === 'type')
              .find(typeName =>
                parent.artifacts[typeName].type._artifact.name.absolute == elemType._artifact.name.absolute
              );
            if (typeFromCurrectService)
              elem.items ? setProp(elem.items, '_swaggerType', typeFromCurrectService) : setProp(elem, '_swaggerType', typeFromCurrectService);
            else if (elemType._artifact.type && elemType._artifact.type.absolute.startsWith('cds.'))
              // if the type is builtin and not from the current service -> expand it
              elem.items ? setProp(elem.items, '_swaggerExpandType', true) : setProp(elem, '_swaggerExpandType', true);
            else
              signal(error`The type ${elemType.absolute} of element ${elem.name.absolute}.${elem.name.id} is not exposed in service ${parent.name.absolute} via a type definition`, elem.location);
          }
        }
      })
    }
  }

  function processType(parent, art) {
    setProp(art, '_swaggerExpandType', true);
    if (art._finalType && art._finalType.builtin)
      return;
    // ugly tnt magic -> to be removed
    if (art.type && art.type.builtin)
      return;
    forEachMemberRecursively(art._finalType /* ugly tnt magic -> to be removed once @extends is resolved correctly */ || art.type._artifact, member => {
      let memberType = member.items ? member.items.type : member.type;
      if (!memberType)
        return;
      if (memberType.absolute.startsWith('cds.'))
        return;
      // try to find the exposition of the type in the current service
      let typeFromCurrectService = Object.keys(parent.artifacts).filter(artName => parent.artifacts[artName].kind === 'type')
        .find(typeName =>
          parent.artifacts[typeName].type._artifact === memberType._artifact
        );
      if (typeFromCurrectService)
        member.items ? setProp(member.items, '_swaggerType', typeFromCurrectService) : setProp(member, '_swaggerType', typeFromCurrectService);
      else
        signal(error`The type ${memberType.absolute} of artifact ${member.name.absolute}.${member.name.id} is not exposed in service ${parent.name.absolute} via a type definition`, member.location);
    });
  }
}
module.exports = preprocessModel;
