'use strict'

var { CompilationError, hasErrors, sortMessages } = require('../base/messages');
const { setProp, forEachGeneric, forEachDefinition } = require('../base/model');
const modelUtils = require('../model/modelUtils.js');
const compactor = require('../json/compactor');
var { linkToOrigin } = require('../compiler/shared');
const deepCopy = require('../base/deepCopy');
const alerts = require('../base/alerts');

function translateAssocsToJoins(inputModel)
{

  const { error, signal } = alerts(inputModel);

  var options = inputModel.options || {};

  if(!options.betaMode)
    signal(error`Conversion of associations into JOINs is not supported yet`);

  // Note: This is called from the 'forHana' transformations, so it is controlled by its options)
  const pathDelimiter = (options.forHana && options.forHana.names == 'hdbcds') ? '.' : '_';
    
  const { compactCondOrExpr } = compactor.getCompactors(options);

  let model = deepCopy(inputModel);
  model.alerts = inputModel.alerts;

  forEachDefinition(model, prepareAssociations);
  forEachDefinition(model, transformView);

    // Throw up if we have errors
  if (hasErrors(model.messages)) {
    throw new CompilationError( sortMessages(model.messages), model)
  }

  return model;

  function prepareAssociations(art)
  {
    let type = art._finalType;
    if(art.kind === 'element' && type && type.target) // contexts have no type
    {
      /* create the prefix string up to the main artifact which is
         prepended to all source side paths of the resulting ON condition
         (cut off name.id from name.element)
      */
      art.elementPrefix = art.name.element.slice(0, art.name.element.length - art.name.id.length).replace(/\./g, pathDelimiter);

      // create path prefix tree for Foreign Keys, required to substitute aliases in ON cond calculation
      // also very useful to detect fk overlaps
      if(type.foreignKeys && !type.fkPathPrefixTree)
      {
        type.fkPathPrefixTree = { children: Object.create(null) };
        forEachGeneric(type, 'foreignKeys', fk => {
          let ppt = type.fkPathPrefixTree;
          fk.targetElement.path.forEach(ps => {
            if(!ppt.children[ps.id])
              ppt = ppt.children[ps.id] = { children: Object.create(null) };
            else
              ppt = ppt.children[ps.id];
          });
          setProp(ppt, '_fk', fk);
        });
      }
      else
      {
        let env = {
          tableAliases: [ art.name.id ],
          type,
          location: 'onCondAssoc',
          callback: [ flyTrap ]
        };
        walk(type.onCond || type.on, env);
      }
    }
    // drill into structures
    forEachGeneric(art, 'elements', prepareAssociations);
  }

  function transformView(art)
  {
    if(modelUtils.isView(art))
      transformQueries(art.queries);
  }

  function transformQueries(queries)
  {
    if(queries.length>0)
    {
      /*
             Setup QATs and leaf QAs (mixins, query, subqueries in from clause)
         1a) First, mark all mixin assoc definitions with a pseudo QA that points to the assoc target.
         1b) Next, for all paths in a query do flytrap checks and create the path prefix trees aka QATs.
             Paths that start with a mixin assoc are Qat'ed into the mixin definition.
             If a mixin assoc is published, its leaf Qat receives the pseudo QA(view) from the rootQat,
             which is the mixin definition itself. See 1a)
         1c) Finally create QAs for from clause subqueries, as they are not yet swept by the path walk
      */
      let env = {
        aliasCount: 0,
        walkover: { from: true, onCondFrom:true, select:true, filter: true },
        callback: [ flyTrap, mergePathIntoQAT ]
      };
      queries.map(q => createQAForMixinAssoc(q, env));
      queries.map(q => walkQuery(q, env));
      queries.map(q => createQAForFromClauseSubQuery(q, env));

      // 2) walk over each from table path, transform it into a join tree
      env.walkover = { from:true, onCondFrom:false, select: false, filter: false };
      env.callback = [ createInnerJoins ];
      queries.map(q => walkQuery(q, env));

      // 3) transform toplevel from block into cross join
      queries.map(q => createCrossJoins(q));

      // 4) transform all remaining join relevant paths into left outer joins and connect with
      //    FROM block join tree. Instead of walking paths it is sufficient to process the $qat of each tableAlias
      queries.map(q => createLeftOuterJoins(q, env));

      // 5) rewrite original/native ON cond paths (same rewrite as with assoc ON cond path but with different table alias)
      // 6) prepend table alias to all remaining paths
      env.walkover = { from:false, onCondFrom:true, select: true, filter: false };
      env.callback = [ rewriteGenericPaths ];
      queries.map(q => walkQuery(q, env));

      // 7) attach firstFilterConds to Where Condition.
      queries.map(q => attachFirstFilterConditions(q));

      // TODO: support parameters
    }
  }

  function createCrossJoins(query)
  {
    // if the toplevel FROM block is a comma separated list and has more then one entry,
    // cross join list items and replace from array

    if(query.op.val === 'query')
    {
      if(Array.isArray(query.from) && query.from.length > 1)
        query.from.splice(0, query.from.length, { op: { val: 'join' }, join: 'cross', args: [...query.from ] });

      // recurse into sub queries
      query.queries.map(q => createCrossJoins(q));
    }
  }

  // transform each from table path into a join tree and attach the tree to the path object
  function createInnerJoins(fromPathNode, env)
  {
    let fqat = env.lead.$tableAliases[fromPathNode.name.id].$fqat;
    let joinTree = createJoinTree(env, undefined, fqat, 'inner', '$fqat', undefined);

    replaceNodeContent(fromPathNode, joinTree);
  }

  // translate all join relevant query paths into left outer join tree and attach it to the lead query
  function createLeftOuterJoins(query, env)
  { 
    if(query.op.val === 'query')
    {
      env.lead = query;
      let joinTree = Array.isArray(query.from) ? query.from[0] : query.from;
      for(let tan in query.$tableAliases)
      {
        if(tan !== '$projection') // don't drive into $projection tableAlias (yet)
        {
          let ta = query.$tableAliases[tan];
          joinTree = createJoinTree(env, joinTree, ta.$qat, 'leftOuter', '$qat', ta.QA);
        }
      }
      query.from = [ joinTree ];

      // recurse into sub queries 
      query.queries.map(q => createLeftOuterJoins(q, env));
    }
  }

  /*
  Each leaf node of a table path must end in either a direct or target artifact. During mergePathIntoQat() this 'leaf' artifact
  is marked as QA at the corresponding 'leaf' QAT and to the respective $tableAlias which is used to link hte remaining paths to
  the correct table alias.
  However, subqueries are not considered in the mergePathIntoQat(), so a subquery QA must be created and added separately to
  the lead query $tableAlias'es.

  Also the name of the subquery (the alias) needs to be set to the final QA alias name.
  */
  function createQAForFromClauseSubQuery(query, env)
  {
    // only subqueries of the FROM clause have a name (which is the alias)
    if(query.op.val === 'query' && query.name.id)
    {
      // set the QA for the outer ON cond paths and rename the query name itself
      let QA = query._tableAlias._parent.$tableAliases[query.name.id].QA = createQA(env, query);
      incAliasCount(env, QA);
      query.name.id = QA.name.id;

      query.queries.map(q => createQAForFromClauseSubQuery(q, env));
    }
  }

  /*
    Add an artificial QA to each mixin definition. This QA completes the QAT
    datastructure that requires a QA at the rootQat before starting the join generation.
    This QA is marked as 'mixin' which indicates that the paths of the ON condition must
    not receive the usual source and target table alias (which is used for generic associations)
    but instead just use the rootQA of the individual ON condition path. These paths are
    resolved against the FROM clause and must of course be connected to the respective table
    aliases
  */
  function createQAForMixinAssoc(query, env)
  {
    if(query.op.val === 'query')
    {
      env.lead = query;
      // use view as QA origin, don't increment aliasCount
      forEachGeneric(query, 'mixin', art => {
        if(!art.QA)
        {
          art.QA = createQA(env, art.target._artifact);
          art.QA.mixin = true; // <=== this is the marker
        }
      });

      query.queries.map(q => createQAForMixinAssoc(q, env));
    }
  }

  /*
    Prefix all paths with table alias (or replace existing alias)

    Rewrite a given path of the native ON condition to TableAlias.ColumnName
    and substitute all eventually ocurring foreign key path segments against the respective FK aliases

    No flattening of structured leaf types necessary, this is done later in toSQL renderer
  */
  function rewriteGenericPaths(pathNode, env)
  {
    if(pathNode.rewritten)
      return;

    let path;
    if(env.location === 'onCondFrom')
    {
      let [ tableAlias, tail ] = constructTableAliasAndTailPath(pathNode.path);
      let pathStr = translateONCondPath(tail).map(ps => ps.id).join(pathDelimiter);
      path = [ tableAlias, [ pathStr, pathNode._artifact ] ];
    }
    else 
    {
      // Paths without _navigation in ORDER BY are select item aliases, they must
      // be rendered verbatim
      if(env.location === 'OrderBy' && !pathNode.path[0]._navigation)
        return;

      // path outside ON cond, follow QAT path backwards until QA is found
      let pl = pathNode.path.length-1;
      let ps = pathNode.path[pl--];
      let QA = ps._navigation._parent.QA;
      while(!QA && pl >= 0)
      {
        ps = pathNode.path[pl--];
        QA = ps._navigation._parent.QA;
      }

      if(QA)
        path = [ [ QA.name.id, QA._artifact ], 
          ...pathNode.path.slice(pathNode.path.indexOf(ps)).map(ps => [ps.id, ps._artifact ]) ];
      else
        throw Error('No QA found for path ' + pathAsStr(pathNode.path, '"'));
    }
    replaceNodeContent(pathNode, constructPathNode(path));
  }

  /*
  Logically AND the filter conditions of the first path steps of the FROM clause to
  the WHERE condition. If no WHERE is specified, create a new one. This step must be done after running
  rewriteGenericPaths because otherwise the filter expressions would be traversed twice.
  */
  function attachFirstFilterConditions(query)
  {
    if(query.op.val === 'query')
    {
      if(query._startFilters)
      {
        if(query.where)
        {
          if(query.where.op.val == 'and')
            query.where.args.push(...query._startFilters);
          else
            query.where = { op: {val: 'and' }, args: [ [query.where],  ...query._startFilters ] };
        }
        else
          query.where = query._startFilters.length > 1
            ? { op: {val: 'and' }, args: query._startFilters }
            : query._startFilters;
      }
      // recurse into sub queries
      query.queries.map(q => attachFirstFilterConditions(q));
    }
  }

  /*
    transform a QAT into a JOIN tree
    Starting from a root (parentQat) follow all QAT children and in case QAT.origin is an association,
    create a new JOIN node using the existing joinTree as LHS and the QAT.QA as RHS.
  */
  function createJoinTree(env, joinTree, parentQat, joinType, qatAttribName, lastAssocQA)
  {
    for(let childQatId in parentQat)
    {
      let childQat = parentQat[childQatId];
      let newAssocLHS = lastAssocQA;
      let art = childQat.origin._artifact;

      if(isEntityOrView(art)) // check if this pathstep is an entity or view
      {
        if(!childQat.QA)
          childQat.QA = createQA(env, art, childQat._parameters);
        incAliasCount(env, childQat.QA);
        newAssocLHS = childQat.QA;

        if(joinTree === undefined) // this is the first artifact in the JOIN tree
        {
          joinTree = childQat.QA;
          // collect the toplevel filters and add them to the where condition
          if(childQat._filter)
          {
            // filter conditions are unique for each JOIN, they don't need to be copied
            let filter = childQat._filter;
            rewritePathsInExpression(filter, function(pathNode) {
              return [ /* tableAlias=> */[childQat.QA.name.id, childQat.QA._artifact ], /*filterPath=>*/ pathNode.path ];
            });

            if(!env.lead._startFilters)
              setProp(env.lead, '_startFilters', []);
            env.lead._startFilters.push( [ filter ] ); // [ filter ] parenthesizes each filter
          }
        }
      }
      else // it's not an artifact, so it should be an assoc step
      {
        if(art.target)
        {
          if(joinTree === undefined)
            throw Error('Cannot follow Associations without starting Entity');

          if(!childQat.QA)
            childQat.QA = createQA(env, art.target._artifact, childQat._parameters);

          // do not create a JOIN for that assoc if it has no subsequent path steps
          //  (except for the last path step in the from table path)
          if(env.location == 'from' || getChildrenCount(childQat) > 0)
          {
            incAliasCount(env, childQat.QA);
            joinTree = createJoinQA(joinType, joinTree, childQat.QA, childQat, lastAssocQA);
            newAssocLHS = childQat.QA;
          }
        }
      }
      // follow the children of this qat to append more JOIN nodes
      joinTree = createJoinTree(env, joinTree, childQat[qatAttribName], joinType, qatAttribName, newAssocLHS);
    }
    return joinTree;

    function isEntityOrView(node)
    {
      if (!node) {
        return false;
      }
      switch (node.kind) {
        case 'entity':
        case 'view':
          return true;
        case 'context':
        case 'service':
        case 'namespace':
        case 'type':
        case 'annotation':
        case 'action':
        case 'function':
        case 'const':
        case 'role':
        case 'aspect':
        case 'accesspolicy':
        case 'element':
        case 'query':
        case 'param':
        case 'enum':
          return false;
        default:
          throw new Error('Unknown artifact kind: ' + node.kind);
      }
    }

    // return the number of direct children to the given qat accross all filters
    function getChildrenCount(qat)
    {
      let count = 0;
      for(let fid in qat[qatAttribName])
      {
        count += Object.keys(qat[qatAttribName][fid]).length;
      }
      return count;
    }
  }

  // creator methods for QAs
  function createJoinQA(joinType, lhs, rhs, assocQAT, assocSourceQA)
  {
    let node = { op: { val: 'join' }, join: joinType, args: [lhs, rhs] };

    // 'path steps' for the src/tgt table alias
    let srcTableAlias = [assocSourceQA.name.id, assocSourceQA._artifact];
    let tgtTableAlias = [assocQAT.QA.name.id, assocQAT.QA._artifact ];

    let assocElt = assocQAT.origin._artifact;

    if(assocElt._finalType.foreignKeys)
    {
      /*
        get both the source and the target column names for the eq term
        for the src side provide a path prefix for all paths that is the assocElement name itself preceded by
        the path up to the first lead artifact (usually the entity or view) (or in QAT speak: follow the parent
        QATs until a QA has been found)
      */
      let srcPaths = flattenElement(assocElt, true, assocElt.name.element.replace(/\./g, pathDelimiter));
      let tgtPaths = flattenElement(assocElt, false);

      if(srcPaths.length != tgtPaths.length)
        throw Error('srcPaths length ['+srcPaths.length+'] != tgtPaths length ['+tgtPaths.length+']');


      // put all src/tgt path siblings into the eq term and create the proper path objects with the src/tgt table alias path steps in front
      let args = [];
      for(let i = 0; i < srcPaths.length; i++)
      {
        args.push({op: {val: '=' },
          args: [ constructPathNode( [srcTableAlias, srcPaths[i]] ),
                  constructPathNode( [tgtTableAlias, tgtPaths[i]] ) ] });   // eslint-disable-line indent-legacy
      }
      // parenthesize each AND term
      node.on = [ (args.length > 1 ? { op: { val: 'and' }, args: [ ...args.map(a=>[a]) ] } : args[0] ) ];

    }
    else if (assocElt.onCond || assocElt.on)
    {
      node.on = clone(assocElt.onCond || assocElt.on);
      rewritePathsInExpression(node.on, function(pathNode)
      {
        let tableAlias;
        let path = pathNode.path;
        let [head, ...tail] = path;

        if(assocSourceQA.mixin)
        {
          if(head.id === '$projection')
            throw Error('Following mix-in association "' + assocElt.name.id + '" in defining view is not allowed with ON condition from projection: ' + pathAsStr(pathNode.path, '"'));
          return constructTableAliasAndTailPath(path);
        }
        else
        {
          if(head.id === assocQAT.name.id) // target side
          {
            // no element prefix on target side
            path = translateONCondPath(tail);
            tableAlias = tgtTableAlias;
          }
          else // source side
          {
            // eventually remove $self from path
            let isAbsolutePath = head.id === '$self';
            if(isAbsolutePath || head.id === '$projection')
              path = tail;

            tableAlias = srcTableAlias;
            // if path is not an absolute path, prepend element prefix
            path = translateONCondPath(path, !isAbsolutePath ? assocElt.elementPrefix : undefined);
          }
        }
        return [tableAlias, path];
      });
    }
    else
    {
      throw Error('assocQAT has neither foreign keys nor an on condition:' + assocElt.name.absolute + pathDelimiter + assocElt.name.element);
    }

    if(assocQAT._filter)
    {
      // filter conditions are unique for each JOIN, they don't need to be copied
      let filter = assocQAT._filter;
      rewritePathsInExpression(filter, function(pathNode) {
        return [ tgtTableAlias, pathNode.path ];
      });

      // if toplevel ON cond op is AND add filter condition to the args array,
      // create a new toplevel AND op otherwise
      let onCond = (Array.isArray(node.on) ? node.on[0] : node.on);

      if(onCond.op.val == 'and')
        onCond.args.push( [ filter ] ); // parenthesize filter
      else
        node.on = [ { op: { val: 'and' }, args: [ [ onCond ], [ filter ] ] } ]; // parenthesize onCond and filter
    }

    return node;
  }

  /*
    A QA (QueryArtifact) is a representative forn a table/view that must appear in the FROM clause
    either named directly or indirectly through an association
   */
  function createQA(env, artifact, parameters, alias)
  {
    if(alias === undefined)
      alias = artifact.name.id;

    let node = constructPathNode([ [ artifact.name.absolute, artifact ] ], alias);

    //TODO: add parameter list to path
    if(parameters)
      setProp(node, '_parameters', parameters);
    return node;
  }

  function incAliasCount(env, QA)
  {
    if(!QA.numberedAlias)
    {
      QA.name.id += '_$' + env.aliasCount++;
      QA.numberedAlias = true;
    }
  }
  /*
    recursively walk over expression and replace any found path against a new
    path consisting of two path steps.
    The first path step is the table alias and the second path step is
    the concatenated string of the original path steps. The leaf _artifact
    of pathNode is used as the leaf artifact of the new path string.

    Both the table alias and the original (remaining) path steps are
    returned from getTableAliasAndPathSteps()

    tableAlias = [ aliasName, _artifact ]
    path = [ { id: ..., _artifact: ... (unused) } ]
  */
  function rewritePathsInExpression(node, getTableAliasAndPathSteps)
  {
    let env = {
      walkover: {},
      callback: [
        function(pathNode) {
          let [ tableAlias, path ] = getTableAliasAndPathSteps(pathNode);
          let pathStr = path.map(ps => ps.id).join(pathDelimiter);
          replaceNodeContent(pathNode, constructPathNode([tableAlias, [pathStr, pathNode._artifact]]));
        } ]
    };
    walk(node, env);
  }

  /*
    Return a new CSN path object constructed from an array of pathSteps
    path steps is an array of [ 'pathStep id', _artifact reference ]
    Alias is optional
    The final _artifact ref is set as _artifact ref to the path
  */
  function constructPathNode(pathSteps, alias)
  {
    let node = {
      rewritten: true,
      path : pathSteps.map(p => {
        let o = Object.assign({}, { id: p[0] });
        setProp(o, '_artifact', p[1]);
        return o; })
    };

    if(alias)
      node.name = { id: alias }

    // set the leaf artifact
    setProp(node, '_artifact', pathSteps[pathSteps.length-1][1]);
    return node;
  }

  /*
    replace the content of the old node with the new one
  */
  function replaceNodeContent(oldNode, newNode)
  {
    Object.keys(oldNode).forEach(k => {
      delete oldNode[k] });
    delete oldNode._artifact;
    delete oldNode._status;
    Object.assign(oldNode, newNode);
  }

  /* collect all of paths to all leafs for a given element
    respecting the src or the target side of the ON condition

    return an array of column names and it's leaf element
   */
  function flattenElement(element, srcSide, prefix)
  {
    // terminate if element is unstructured
    if(!element._finalType.foreignKeys && !element.elements)
      return [ [ prefix, element ] ];

    let paths = [];
    // get paths of managed assocs (unmanaged assocs are not allowed in FK paths)
    if(element._finalType.foreignKeys)
    {
      for(let fkn in element._finalType.foreignKeys)
      {
        let fk = element._finalType.foreignKeys[fkn];
        // once a fk is to be followed, treat all sub patsh as srcSide, this will add fk.name.id only
        if(srcSide)
          paths = paths.concat(flattenElement(fk.targetElement._artifact, true,  fk.name.id));
        else
        {
          // consume path segments until the next assoc and substitute against fk alias until path is eaten up
          let [ assocStep, tail, fkPrefix ] = pathAsStringUpToAssoc(fk.targetElement.path);
          while(assocStep && tail.length)
          {
            [tail, fkPrefix] = substituteFKAliasForPath(assocStep, tail, fkPrefix);
            [assocStep, tail, fkPrefix] = pathAsStringUpToAssoc(tail, fkPrefix);
          }
          paths = paths.concat(flattenElement(fk.targetElement._artifact, true, fkPrefix));
        }
      }
    }
    // get paths of plain structured elemenents
    else if(element.elements)
    {
      for(let n in element.elements)
      {
        let elt = element.elements[n];
        paths = paths.concat(flattenElement(elt, true, elt.name.id));
      }
    }
    return paths.map(p => [(prefix ? prefix + pathDelimiter + p[0] : p[0]), p[1] ] );
  }


  /*
    construct both the TA path step and the path tail for a given path array from the AST
   */
  function constructTableAliasAndTailPath(path)
  {
    let [head, ...tail] = path;
    let QA = head._navigation.QA || head._navigation._parent.QA;

    // first path step is table alias, use it and pop it off
    if(head._navigation.QA)
      path = tail;

    let tableAlias = [ QA.name.id, QA._artifact ];
    return [ tableAlias, path ];
  }

  /*
  Translate ON cond paths and substitute FK aliases
  return array of [ [pathName, _artifact] ]
  */
  function translateONCondPath(path, prefix)
  {
    let [ assocStep, tail, fkPrefix ] = pathAsStringUpToAssoc(path);
    while(assocStep && tail.length)
    {
      [tail, fkPrefix] = substituteFKAliasForPath(assocStep, tail, fkPrefix);
      [assocStep, tail, fkPrefix] = pathAsStringUpToAssoc(tail, fkPrefix);
    }
    // artifact is not needed, return value must fit in rewritePath expectations (array of path objects with id }
    return [ { id: (prefix ? prefix + fkPrefix : fkPrefix) } ];
  }

  /*
    munch path steps and append them to a path string until an assoc step is found. The assoc path step is also
    appended to the path string. If no assoc path step has occured, all path steps are added to the path string
    and tail is empty.

    Return assocPathStep, the remaining tail path and the path string
  */
  function pathAsStringUpToAssoc(path, pathStr)
  {
    if(!pathStr)
      pathStr = '';
    let assocStep = path.find(ps => {
      if(pathStr.length > 0)
        pathStr += pathDelimiter;
      pathStr += ps.id;
      return (ps._artifact._finalType.target); // true if it has a target => is assoc => terminate find
    });
    return [ assocStep, path.slice(path.indexOf(assocStep)+1), pathStr ];
  }

  /*
    Substitute the n first path steps of a given path against a FK alias name.

    Resolve a foreign key of an (managaged) association by following the n first path steps of a given path.

    The longest path matches:
    Example: fk tuple { a.b, a.b.c, a.b.e },
    path: a.b.c.d.e.f: FK a.b.c is found, even if FK a.b is one level higher in the prefix tree.
    path: a.b.x.y.z: FK a.b is found, remaining tail path is x.y.z
    Add the FK alias name to the path string.

    Return remaining tail path and the path string
  */

  function substituteFKAliasForPath(assocStep, path, pathStr='')
  {
    let ppt = assocStep._artifact.fkPathPrefixTree.children;
    let fk = undefined; // last found FK
    let fkPs = undefined; // last path step that found FK
    path.forEach(ps => {
      if(ppt[ps.id])
      {
        if(ppt[ps.id]._fk)
        {
          fk = ppt[ps.id]._fk;
          fkPs = ps;
        }
        ppt = ppt[ps.id].children;
      }
      else if(!fk)
        // this should never happen if foreign key path could be resolved fully... Anyway, just in case
        throw Error('Could not find fkPrefixTree for ' + ps.id + ' from path ' + pathAsStr(path, '"'));
    });

    if(fk)
    {
      if(pathStr.length)
        pathStr += pathDelimiter;
      pathStr += fk.name.id;
    }

    let tail = path.slice(path.indexOf(fkPs)+1);
    // if foreign key is an association itself, apply substituteFKAliasForPath on tail
    if(fk && fk.targetElement._artifact.target && tail.length)
      return substituteFKAliasForPath(fk.targetElement, tail, pathStr);
    else
      return [ tail, pathStr ];
  }


  /* 
    Catch the most basic path constraint violations that are not yet covered elsewhere
  */
  function flyTrap(pathDict, env)
  {

    // all leaf type must be scalar in a query
    let path = pathDict.path;
    if(env.location === 'filter' || env.location === 'onCondFrom' || env.location === 'onCondAssoc')
    {
      if(pathDict._artifact._finalType.elements)
        signal(error`Only scalar types allowed in this location of a query: ' + pathAsStr(pathDict.path, "'")`);

      let [head, ...tail] = path;
      // pop head if it is a table alias or $projection
      if(env.tableAliases && env.tableAliases.includes(head.id) || head.id === '$projection')
        path = tail;

      path.forEach(ps => {
        if(ps._artifact._finalType.target)
        {
          if(ps._artifact._finalType.on)
          {
            if(env.location !== 'onCondAssoc')
              signal(error`Unmanaged associations not allowed in path: ${pathAsStr(pathDict.path)}`);
          }
          else // must be managed
          {
            let la1 = pathDict.path[pathDict.path.indexOf(ps)+1];
            if(la1 && !ps._artifact._finalType.fkPathPrefixTree.children[la1.id])
              signal(error`Pathstep ' + la1.id + ' is not foreign key of association ' + ps.id + ' in ON condition path: ' + pathAsStr(pathDict.path)`);
          }
        }
      });
    }
    if(env.location !== 'onCondFrom' && env.location !== 'onCondAssoc')
    {
      if(pathDict.path[0].id === '$projection')
        signal(error`'$projection' outside of ON conditions not supported: " + pathAsStr(pathDict.path)`);
    }
  }

  /*
  Create path prefix trees and merge paths into the trees depending on the path location.
  There are three prefix trees for FROM table paths, ON conditions (of either JOINs in FROM clause or
  of ad-hoc associations) and all other paths. It is not the job of this transformer to semantically
  check for illegal association path steps in the various clauses of the query.

  All prefix trees are located underneath the $tableAlias structure and are distinguished
  by their attribute $qat, $fqat and $nqat. Each path step appears exactly once for a given filter condition
  in the prefix tree and has a link to it's definition (origin). The default filter is an empty string ''.

  A special note on paths in filter conditions. Filter paths are treated like postfix
  paths to an association path step, meaning, they are inserted into the assoc's $qat or $fqat depending on where
  the association was traversed. As HANA CDS doesn't allow to traverse assocs in filter path, this is checked
  in flyTrap above.
  
  A node in the path prefix tree is abbreviated as QAT (which stands for query association tree, a term
  originating from way back in time).
  */
  function mergePathIntoQAT(pathDict, env)
  {
    let path = pathDict.path;

    if(path.length == 0)
      return;

    let qatChildrenName = '$qat';
    if(env.location == 'from')
      qatChildrenName = '$fqat';
    if(env.location == 'onCondFrom')
      return; //qatChildrenName = '$nqat'

    let [head, ...tail] = path;

    // qatParent is the node where the starting qat is attached to
    let qatParent = undefined;

    // FROM and filter paths do not have a _navigation, but for filter paths
    // the corresponding path step (to where the filter was attached to) is in env.pathStep
    if(!head._navigation)
    {
      // speciality for OrderBy: If path has no _navigation don't merge it. Path is alias to select item expression
      if(env.location === 'OrderBy')
        return;

      // env.pathStep is set in walkPath for walk on filter conditions
      if(env.pathStep)
        qatParent = env.pathStep._navigation;
      else if(pathDict.name) // from table path with its alias
        qatParent = env.lead.$tableAliases[pathDict.name.id];
      else
        // tableAlias not found yet, last resort is head.id => published Assoc
        qatParent = env.lead.$tableAliases[head.id];
      tail = path; // start with the full path
    }

    // all other paths have a _navigation attribute
    else if(head._navigation)
    {
      // Always start with QAT merge at $tableAlias, even if path doesn't start there:
      // First identify $tableAlias (must be either head or head's parent)
      // The resolver sets a _navigation at the very first path step that either points to
      // $tableAlias or to a top level element from $combined which itself parent's to $tableAlias).
      if(head._navigation.kind == '$navElement')
      {
        qatParent = head._navigation._parent;
        tail = path; // start with the full path (no table alias prefix)
      }
      else if(head._navigation.kind == 'element') // this is a mixin assoc
      {
        qatParent = head._navigation;
        tail = path;
      }
      else // head is a table alias already
      {
        qatParent = head._navigation;
      }
    }

    if(qatParent == undefined)
      throw Error('table alias/qathost not found for path: ' +  pathAsStr(path));

    let rootQat = qatParent;

    // create the very first QAT if it doesn't exist yet (no filter condition for table alias prefix)
    let qatChildren = createQATChildren(qatParent);
    let qat = undefined;
    for(let pathStep of tail)
    {
      // if the current path step has not yet been inserted into the child list of
      // the parent QAT, create a new QAT (linkToOrigin) and a dictionary for the
      // subsequent path steps (a separate one for each filter condition).
      let filterStr = '';
      if(pathStep.where)
        filterStr = JSON.stringify(compactCondOrExpr(pathStep.where));

      qat = qatChildren[pathStep.id + filterStr];
      if (!qat) 
      {
        qat = linkToOrigin(pathStep._artifact, pathStep.id, qatParent, undefined, pathStep.location);
        // this is for mixin associations: if a mixin assoc is traversed, it's definition already has a QA, attach it to the qat
        // to make sure that the same alias is used.
        if(qat.origin._artifact.QA)
          qat.QA = qat.origin._artifact.QA;
        if(pathStep.where)
          setProp(qat, '_filter', pathStep.where);
        qat.kind = '$navElement';
        qatChildren[pathStep.id+filterStr] = qat;
      }
      qatChildren = createQATChildren(qat);
      qatParent = qat; // now the current qat becomes parent to the next level of children
      setProp( pathStep, '_navigation', qat );
    }

    /* If this path terminates on either an entity or an association
       (from clause, published Ad-Hoc Assocs), create a QA and attach it
       to the (leaf) QAT and to the rootQAT (which is the tableAlias).
       This QA will later serve as the initial 'lastAssocQA'
       to all other join relevant paths of the query that originate from this alias.
       Also this is the only place where the from table path alias is accessible.
    */
    if(!qat)
      throw Error('No leaf qat for head: ' + head + ' tail: ' + pathAsStr(tail, '"') + ' produced');

    let art = qat.origin._artifact;
    if(!modelUtils.isArtifact(art))
      if(art.target)
        art = art.target._artifact;
      else
        art = undefined;

    if(art)
    {
        // if rootQat ($tableAlias) already has a QA, reuse it, otherwise create a new one
      if(!rootQat.QA)
      {
        let alias = pathDict.name ? pathDict.name.id : undefined;
        rootQat.QA = qat.QA = createQA(env, art, pathDict._parameters, alias);
      }
    }

    // return or create a new children dictionary for a given QAT
    // Children are grouped under the filter condition that precedes them.
    function createQATChildren(parentQat)
    {
      if(!parentQat[qatChildrenName])
        parentQat[qatChildrenName] = Object.create(null);
      return parentQat[qatChildrenName];
    }
  }

  // crawl all relevant sections of the AST for paths
  function walkQuery(query, env)
  {
    if(!query)
      return;

    if(!env.walkover)
      env.walkover = {};
    env.location = query.op;

    if(query.op.val === 'query')
    {
      env.lead = query;

      env.location = 'from';
      walkFrom(query.from);

      // maybe not very sharp: walkover=select will unlock
      // all generic paths
      env.location = 'select';
      if(env.walkover[env.location])
      {
        for(let alias in query.elements)
          walk(query.elements[alias].value, env);

        env.location = 'Where';
        walk(query.where, env);
        env.location = 'GroupBy';
        walk(query.groupBy, env);
        env.location = 'Having';
        walk(query.having, env);
        env.location = 'OrderBy';
        walk(query.orderBy, env);
        // outer orderBy's of anonymous union
        walk(query.$orderBy, env);
        env.location = 'Limit';
        walk(query.limit, env);
        env.location = 'Offset';
        walk(query.offset, env);
        // TODO: which clauses are missing
        // union, intersect, except?
      }
    }

    // finally apply walkQuery on all sub queries
    query.queries.map(q => walkQuery(q, env));

    function walkFrom(query)
    {
      let aliases = [];
      if(query) 
      {
        if(Array.isArray(query))
        {
          for(let q of query)
            aliases = aliases.concat(walkFrom(q));
        }
        else if(env.walkover[env.location] && walkPath(query, env))
        {
          if(query.name)
            aliases.push(query.name.id);
        }
        else
        {
          aliases = walkFrom(query.args);

          env.location = 'onCondFrom';
          if(env.walkover[env.location])
          {
            env.tableAliases = aliases;
            walk(query.on, env)
            delete env.tableAliases;
          }
          env.location = 'from';
        }
      }
      return aliases;
    }
  }

  /* node: any
    env: { callback: (array of) callback methods with signature(thing, env)
            ...:      any additional payload for the callback
          }
  */
  function walk(node, env)
  {
    // in some expressions queries can occur, do not follow them as they
    // are walked as member of the queries array
    if(!env || !node || (node && node.op && node.op.val == 'query'))
      return;

    if(typeof node === 'object' && !Array.isArray(node))
      if(walkPath(node, env))
        return;

    // ask for Array before typeof object (which would also be true for Array)
    if(Array.isArray(node)) 
      node.map(n => walk(n, env));
    // instanceof Object doesn't respect dictionaries...
    else if(typeof node === 'object')
      for(let n in node)
        walk(node[n], env);
  }

  function walkPath(node, env)
  {
    let path = node['path'];
    // don't bite into paths that that have no artifact (function calls etc)
    if(path && path[0]._artifact)
    {
      if(env.callback)
      {
        // an array of callbacks applied to the node
        if(Array.isArray(env.callback))
          env.callback.map(cb => cb(node, env));
        else
          env.callback(node, env);
      }

      let filterEnv = Object.assign({walkover: {} }, env);
      filterEnv.location = 'filter';
      if(filterEnv.walkover[filterEnv.location])
      {
        // walk over all filter expressions (not JOIN relevant,
        // cannot be detected in generic walk
        path.filter(pathStep=>pathStep.where).forEach(pathStep => {
          filterEnv.pathStep = pathStep;
          walk(pathStep.where, filterEnv) });
      }
      // TODO: Parameter expressions!
    }
    return path;
  }

  function pathAsStr(p, delim='')
  {
    return p.map(p => delim + p.id + delim).join(pathDelimiter);
  }

  // for debugging only
  // eslint-disable-next-line no-unused-vars
  function printPath(pathDict, env)
  {
    let alias = (pathDict.name && pathDict.name.id) || '<undefined>'
    let path = pathDict.path;
    let s = pathAsStr(path, '"');
    let me = env.lead && (env.lead.name.id || env.lead.op);
    // eslint-disable-next-line no-console
    console.log(me + ': ' + env.location + ": " + s + " alias: " + alias);
  }

  function clone(obj) {
    let newObj;
    if (typeof obj !== 'object' || obj === null) // return primitive type, note that typeof null === 'object'
      return obj;
    if (Array.isArray(obj))
      newObj = [];
    else if (obj.constructor) // important for classes, else prototype chain for inheritance will not be correct
      newObj = new obj.constructor()
    else if (!Object.getPrototypeOf(obj))
      newObj = Object.create(null);  // dictionary
    else
      newObj = {};

    let props =  Object.getOwnPropertyNames(obj);  // we clone only own properties, not inherited one's
    for (let p of props) {
      let pd = Object.getOwnPropertyDescriptor(obj, p);
      if (pd && pd.enumerable === false)
      {
        pd.value = obj[p]; // don't copy references
        Object.defineProperty(newObj, p, pd);
      }
      else
        newObj[p] = clone(obj[p]);
    }
    return newObj;
  }
} // end of translateAssocsToJoins


module.exports = { translateAssocsToJoins };
