'use strict';

const has = Object.prototype.hasOwnProperty;
const alerts = require('../base/alerts');

function getFunctionAndActionChecks(model) {
  const { error, signal } = alerts(model);
  let options = model.options;

  return {
    checkBoundActionOrFunction,
    checkUnboundActionOrFunction,
    checkActionOrFunctionParameter,
  };

  // Check a bound action or function (i.e. one that lives within an entity or view)
  function checkBoundActionOrFunction(act) {
    if (Array.isArray(act)) // duplicated declaration -> will be handle in some of the other steps of the compiler
      return undefined;
    checkParentIsService(act);
    // in ODATA v2 scalar types cannot be returned
    if (hasReturnType(act) && options.toOdata && options.toOdata.version == 'v2') {
      let typeAbs = getPropFromChain(act, ['returns', 'type', 'absolute']);
      if (typeAbs && isScalar(act, typeAbs))
        signal(error`Scalar return types are not allowed in OData V2`, act.location);
    }
    // check if return type is entity from the current service
    if (hasReturnType(act) && isArrayed(act.returns))
      checkReturnTypeArray(act);
    else if (getPropFromChain(act, ['returns', 'type', '_artifact', 'kind']) === 'entity')
      checkReturnEntity(act);
    else if (getPropFromChain(act, ['returns', 'type', '_artifact', 'kind']) === 'type' &&
      !getPropFromChain(act, ['returns', 'type', '_artifact', 'builtin']))
      checkReturnUserDefinedType(act);

    // FIXME: What is the semantics of the return value (here and elsewhere in this file?)
    return undefined;
  }

  function checkParentIsService(act) {
    // FIXME: Maybe we should try to avoid using blocks for this ?
    let kind = getPropFromChain(act, ['_parent', '_block', 'name', '_artifact', 'kind']);
    if (kind && kind !== 'service')
      return signal(error`The bound action '${act.name.id}' must be in an entity which is part of a service`, act.location);
    else if (getPropFromChain(act, ['_parent', '_block', 'kind']) === 'source') /* when the action is bound to a top level defined entity */
      return signal(error`The bound action '${act.name.id}' must be in an entity which is part of a service`, act.location);
    return undefined;
  }

  function checkReturnEntity(act) {
    let returnBlockName = getPropFromChain(act, ['returns', 'type', '_artifact', '_block', 'name', 'absolute']);
    let actBlockName = getPropFromChain(act, ['_block', 'name', 'absolute']);
    if (returnBlockName !== actBlockName)
      return signal(error`The return entity must be from the current service '${actBlockName}'`, act.location);
    return undefined;
  }

  function checkReturnTypeArray(act) {
    if (!(hasReturnType(act) && isArrayed(act.returns)))
      return undefined;
    let returnKind = getPropFromChain(act, ['returns', 'items', 'type', '_artifact', 'kind']);
    if (!returnKind || returnKind !== 'entity')
      return signal(error`The action '${act.name.id}' can only return an array of entities`, act.location);
    let returnTypeEntity = getPropFromChain(act, ['returns', 'items', 'type', '_artifact', '_block', 'name', 'absolute']);
    let actEntity = getPropFromChain(act, ['_parent', '_block', 'name', 'absolute']) /* when bound*/ || getPropFromChain(act, ['_block', 'name', 'absolute']) /* when unbound */;
    if (returnTypeEntity !== actEntity)
      return signal(error`The action '${act.name.id}' can only return an array of entities from the current service '${actEntity}'`, act.location);
    return undefined;
  }

  function checkReturnUserDefinedType(act) {
    let actParentName = getPropFromChain(act, ['_block', 'name', 'absolute']);
    let returnsBlockName = getPropFromChain(act, ['returns', 'type', '_artifact', '_block', 'name', 'absolute']);
    if (actParentName !== returnsBlockName)
      return signal(error`The user defined return type of action '${act.name.id}' must be from the current service '${actParentName}'`, act.location);
    return undefined;
  }

  // Check parameter 'param' of action or function 'act'
  function checkActionOrFunctionParameter(param, act) {
    let paramArtifact = getPropFromChain(param, ['type', '_artifact']);
    if (options.toOdata && options.toOdata.version == 'v4' && paramArtifact.kind && paramArtifact.kind === 'entity')
      checkEntityParam(act, paramArtifact);
    if (options.toOdata && options.toOdata.version == 'v2')
      if (!isScalar(act, getPropFromChain(param, ['type', 'absolute'])))
        signal(error`Only scalar type input parameters are allowed in OData V2`, act.location);
    // check when the parameter is of user defined type
    if (paramArtifact.kind && paramArtifact.kind === 'type') {
      checkUserDefinedTypeParam(act, paramArtifact, param.name.id);
    }

    function checkEntityParam(act, paramArtifact) {
      let actionBlock = getPropFromChain(act, ['_block', 'name', '_artifact']);
      let paramArtifactBlock = getPropFromChain(paramArtifact, ['_block']);
      if (paramArtifactBlock.kind && paramArtifactBlock.kind === 'source') /* param of type top-level entity */
        return signal(error`The parameter entity type must be from the current service`, act.location);
      if (getPropFromChain(paramArtifactBlock, ['name', 'absolute']) !== getPropFromChain(actionBlock, ['name', 'absolute']))
        return signal(error`The parameter entity type must be from the current service '${actionBlock.name.absolute}'`, act.location);
      return undefined;
    }

    function checkUserDefinedTypeParam(act, paramArtifact, paramName) {
      if (getPropFromChain(paramArtifact, ['_block', 'kind']) === 'source')
        return signal(error`The type of input parameter '${paramName}' must be from the current service`, act.location);
      else if (getPropFromChain(paramArtifact, ['_block', 'kind']) === 'block') {
        let paramArtParentName = getPropFromChain(paramArtifact, ['_block', 'name', 'absolute']);
        let actParentBlockName = getPropFromChain(act, ['_block', 'name', 'absolute']);
        if (paramArtParentName !== actParentBlockName)
          return signal(error`The type of input parameter '${paramName}' must be from the current service`, act.location);
      }
      return undefined;
    }
  }

  function isScalar(act, typeAbsolute) {
    if (['cds.Integer', 'cds.String', 'cds.Boolean',
      'cds.Date', 'cds.Time', 'cds.Binary',
      'cds.Integer64', 'cds.Decimal', 'cds.DecimalFloat',
      'cds.Double', 'cds.DateTime', 'cds.Timestamp'].includes(typeAbsolute))
      return true;
    return false;
  }

  // Check an unbound action or function (i.e. one that is not part of an entity but a definition of its own)
  function checkUnboundActionOrFunction(def) {
    if (Array.isArray(def)) // duplicated declaration -> will be handle in some of the other steps of the compiler
      return undefined;
    if (getPropFromChain(def, ['_block', 'kind']) === 'source')
      return signal(error`Functions and actions must be inside of a service or bound to an entity`, def.location);
    if (getPropFromChain(def, ['_block', 'name', '_artifact', 'kind']) !== 'service')
      return signal(error`Functions and actions must be declared in a service`, def.location);
    if (hasReturnType(def) && isArrayed(def.returns))
      checkReturnTypeArray(def);
    return undefined;
  }
}

function hasReturnType(obj) {
  return has.call(obj, 'returns');
}

function isArrayed(obj) {
  return has.call(obj, 'items');
}

function getPropFromChain(obj, chain) {
  if (!Array.isArray(chain))
    return undefined;
  let temp = obj;
  for (let i = 0; i < chain.length; i++) {
    if (!has.call(temp, chain[i])) {
      temp = undefined;
      break;
    }
    temp = temp[chain[i]];
  }
  return temp;
}

module.exports = getFunctionAndActionChecks;
