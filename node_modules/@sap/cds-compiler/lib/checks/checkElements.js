'use strict';

const has = Object.prototype.hasOwnProperty;
const alerts = require('../base/alerts');

// Check when there is a managed association 'm' without explicit declared foreign keys,
// that the target entity does specify at least one key
function checkManagedAssoc(m, model) {
  const { error, signal } = alerts(model);
  if (isManagedAssocWithoutKeys(m) && !m.redirected) {
    if(m.target.absolute !== undefined) { // non-resolved targets have no 'absolute'
      signal(error`The target ${m.target.absolute} of the association ${m.name.id} does not have key(s).`, m.target.location);
    }
  }
}

function isManagedAssocWithoutKeys(elem) {
  return elem.target && !elem.on && !elem.onCond && !elem.foreignKeys;
}

// Check element 'elem' for semantical errors involving virtual elements
function checkVirtualElement(elem, model) {
  const { error, signal } = alerts(model);
  // when the element itself is declared as virtual
  if (elem.virtual) {
    if (elem.key) {
      signal(error`Element cannot be virtual and key.`, elem.location);
    }
    if (isStruct(elem)) {
      signal(error`Element cannot be virtual and structured.`, elem.location);
    }
    if (isAssoc(elem)) {
      signal(error`Element cannot be virtual and an association.`, elem.location);
    }
  }
  if(isAssoc(elem))
    checkAssociation(elem, model);
}

function checkAssociation(elem, model) {
  const { error, signal } = alerts(model);
  // when virtual element is part of association
  if (elem.foreignKeys) {
    for (let k in elem.foreignKeys) {
      let key = elem.foreignKeys[k].targetElement;
      if (key && key._artifact && key._artifact.virtual && key._artifact.virtual.val === true) {
        signal(error`Virtual elements cannot be used as a foreign key for a managed association.`, key.location);
      }
    }
  }
  checkAssociationCondition(elem, model, elem.onCond);
}

function checkAssociationCondition(elem, model, onCond) {
  if(onCond===undefined)
    return;
  if(Array.isArray(onCond)) // condition in brackets results an array
    onCond.forEach(Cond => checkAssociationCondition(elem, model, Cond))
  else
    checkAssociationConditionArgs(elem, model, onCond.args, onCond.op)
}

function checkAssociationConditionArgs(elem, model, args, op) {
  if(!args)
    return;
  args.forEach(Arg => checkAssociationOnCondArg(elem, model, Arg, op));
}

function checkAssociationOnCondArg(elem, model, arg, op) {
  if(Array.isArray(arg)) {
    arg.forEach(Arg => checkAssociationOnCondArg(elem, model, Arg, op))
    return;
  } else {
    checkAssociationConditionArgs(elem, model, arg.args, arg.op);
  }

  singleCheckUnmanagedAssocCondArgumentNoFollowUnmanagedAssoc(elem, model, arg, op);
  singleCheckNoVirtualElementsInAssociationConditions(model, arg);
}

function singleCheckUnmanagedAssocCondArgumentNoFollowUnmanagedAssoc(elem, model, arg, op) {
  if(!arg.path)
    return;
  let path0=arg.path[0]
  if(!path0)
    return;
  if(path0.id=="$self") { // $self (backlink) checks
    checkAssociationArgumentStartingWithSelf();
    return;
  }
  if(!path0._artifact) // not resolved
    return;
  let artifactName = path0._artifact.name;
  if(artifactName.absolute && artifactName.element) {
    let argTarget = model.definitions[artifactName.absolute].elements[artifactName.element];
    //the check is valid for unmanaged associations
    //TODO clarify if the full resolved path to the target field should consist of managed associations or just the first
    if(isUnmanagedAssociation(argTarget)) {
      var same = path0.id === elem.name.element;
      if(!same) {
        const { error, signal } = alerts(model);
        signal(error`Unmanaged association condition can not follow another unmanaged association.`, path0.location);
      }
    }
  }

  function checkAssociationArgumentStartingWithSelf() {
    if(op && op.val==="xpr") // no check for xpr
      return;
    if(op && op.val!=="=") {
      const { error, signal } = alerts(model);
      signal(error`Backlink association condition requires an operator equation`, op.location);
    }
  }

}

function singleCheckNoVirtualElementsInAssociationConditions(model,arg) {
  if (arg && arg._artifact) {
    if (!arg._artifact) // name was not resolved -> _artifact: undefined - exception is thrown on the next steps of the compiler
      return;
    if (arg._artifact.virtual && arg._artifact.virtual.val === true) {
      const { error, signal } = alerts(model);
      signal(error`Virtual elements cannot be used in an ON-condition.`, arg.location);
    }
  }
}

function isStruct(obj) {
  return has.call(obj, 'elements');
}

function isAssoc(obj) {
  return obj && obj.type && obj.type.absolute && obj.type.absolute === 'cds.Association';
}

function isUnmanagedAssociation(obj) {
  return isAssoc(obj) && obj.onCond !== undefined;
}

// Check that required actual parameters on 'node.type' are set, that their values are in the correct range etc.
function checkTypeParameters(node, model) {
  const { error, signal } = alerts(model);

  if (node.type) {
    if (node.typeArguments) {
      signal(error`Too many parameters in type reference to '${node.type.absolute}'`,
        node.typeArguments[0].location);
    }
    let parameters = node.type._artifact? node.type._artifact.parameters : [];
    for (let name in parameters) {
      let param = parameters[name];
      if (!node[param] && node.type.absolute != "hana.ST_POINT" && node.type.absolute != "hana.ST_GEOMETRY")
        signal(error`Actual value for type parameter '${param}' missing in reference to type '${node.type.absolute}'`,
          node.type.location );
    }
    switch (node.type.absolute) {
      case "cds.String":
      case "cds.Binary":
      case "hana.VARCHAR": {
        checkTypeParamValue(node, 'length', 'positiveInteger', {min: 1, max: 5000});
        break;
      }
      case "cds.Decimal": {
        checkTypeParamValue(node, 'precision', 'positiveInteger', {max: 38});
        checkTypeParamValue(node, 'scale', 'positiveInteger', {max: node.precision && node.precision.val});
        break;
      }

      case "hana.BINARY":
      case "hana.NCHAR":
      case "hana.CHAR": {
        checkTypeParamValue(node, 'length', 'positiveInteger', {min: 1, max: 2000});
        break;
      }
      case "hana.ALPHANUM": {
        checkTypeParamValue(node, 'length', 'positiveInteger', {min: 1, max: 127});
        break;
      }
      case "hana.ST_POINT":
      case "hana.ST_GEOMETRY": {
        checkTypeParamValue(node, 'length', 'positiveInteger', {max: Number.MAX_SAFE_INTEGER});
        break;
      }
    }
  }

  // Check that the value of the type property `paramName` (e.g. length, precision, scale ...) is of `expectedType`
  // (which can currently only be 'positiveInteger') and (optional) the value is in a given range
  function checkTypeParamValue(node, paramName, expectedType, range = undefined) {
    let paramValue = node[paramName] && node[paramName].val;
    if (paramValue == undefined)
      return true;
    switch (expectedType) {
      case "positiveInteger":
        if (!(Number.isInteger(paramValue) && paramValue >= 0)) {
          signal(error`Actual parameter '${paramName}' for '${node.type.absolute}' must be positive integer`,
            node[paramName].location);
          return false;
        }
        break;
      default:
        throw 'Unknown "expectedType"';
    }
    if (range) {
      if (range.max && paramValue > range.max) {
        signal(error`Actual parameter '${paramName}' for '${node.type.absolute}' is larger than allowed (max: ${range.max})`,
          node[paramName].location);
        return false;
      }
      if (range.min && paramValue < range.min) {
        signal(error`Actual parameter '${paramName}' for '${node.type.absolute}' is smaller than allowed (min: ${range.min})`,
          node[paramName].location);
        return false;
      }
    }
    return true;
  }
}

module.exports = {
  checkManagedAssoc,
  checkVirtualElement,
  checkTypeParameters,
};
