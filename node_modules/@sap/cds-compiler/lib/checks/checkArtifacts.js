'use strict';

const alerts = require('../base/alerts');

// Semantic checks that are performed on artifacts

// For an artifact 'artifact' that has an 'implemented in' clause, check its legality
function checkArtifactImplementedIn(artifact, model) {
  const { error, signal } = alerts(model);
  if (!isAllowedId(artifact.impl.id)) {
    signal(error`'${artifact.impl.id}' is not an allowed id for the syntax 'entity <name> implemented in <id>'`, artifact.impl.location);
  }
}

// we reserve all ids that do not contain a ":" or that start with
//   CDS:, CDX:, HANA:, SQL:, CQL: (case insensitive)
// reserve means: we currently do not allow them, because we may relate
//   them with some special semantic at a later point in time
// temporarily we also allow "calcview" (although it doesn't contain a ":") for
//   compatibility reasons
function isAllowedId(id) {
  // temporarily allow "calcview" for compatibility reasons
  // id must contain a ":"
  // id must not start with CDS, CDX, ...
  return ( (id === 'calcview') ||
           (id.match(/^.+:.+$/g) !== null && id.match(/^(CDS|CDX|HANA|SQL|CQL):.+/ig) === null) );
}

// Check that artifact 'art' is not empty and does not contain only virtual elements
// (not applicable to abstract artifacts)
function checkNotEmptyOrOnlyVirtualElems(art, model) {
  const { error, signal } = alerts(model);
  if (!art.abstract && emptyOrOnlyVirtualElements(art)) {
    signal(error`A type or an entity definition cannot be empty or contain only virtual elements with '--to-hana'.`, art.location);
  }

  // Return true if artifact or element 'construct' is a virtual element or an empty structure
  // or a structure that (recursively) is empty or only contains virtual elements
  function emptyOrOnlyVirtualElements(construct) {
    // Structured type ?
    if ((construct._finalType || construct).elements) {
      construct = construct._finalType || construct;
      // No elements or all elements recursively empty, too ?
      return construct.elements.length == 0
          || Object.keys(construct.elements).map(k => construct.elements[k]).every(elm => emptyOrOnlyVirtualElements(elm));
    }
    // Non-structured type - just check for virtual-ness
    return construct.virtual;
  }
}

// Check that queries in 'art' do not contain unmanaged associations in GROUP BY or ORDER BY
function checkNoUnmanagedAssocsInGroupByOrderBy(art, model) {
  const { error, signal } = alerts(model);
  for (let query of art.queries || []) {
    for (let groupByEntry of query.groupBy || []) {
      if (groupByEntry._artifact && groupByEntry._artifact._finalType && groupByEntry._artifact._finalType.onCond) {
        // Unmanaged association - complain
        signal(error`"${art.name.absolute}": Unmanaged associations are not allowed in GROUP BY`, groupByEntry.location);
      }
    }
    for (let orderByEntry of query.orderBy || []) {
      if (orderByEntry.value && orderByEntry.value._artifact && orderByEntry.value._artifact._finalType && orderByEntry.value._artifact._finalType.onCond) {
        // Unmanaged association - complain
        signal(error`"${art.name.absolute}": Unmanaged associations are not allowed in ORDER BY`, orderByEntry.value.location);
      }
    }
  }
}

module.exports = {
  checkArtifactImplementedIn,
  checkNotEmptyOrOnlyVirtualElems,
  checkNoUnmanagedAssocsInGroupByOrderBy,
};
