// Wrapper around generated ANTLR parser

// To test the parser in the REPL
//   var parser = require( './lib/language/antlrParser' );
//   var ast    = parser.parse( 'FileContent', 'FileName' );

var antlr4 = require('antlr4');

var { CompileMessage } = require('../base/messages');
var errorStrategy = require('./errorStrategy');

var Parser = require('../gen/languageParser').languageParser;
var Lexer = require('../gen/languageLexer').languageLexer;

// Error listener used for ANTLR4-generated parser
class ErrorListener extends antlr4.error.ErrorListener {
  constructor(...args) {
    super(...args);
    this.messages = [];
  }

  // Push message `msg` with location `loc` to array of errors:
  message( msg, loc, severity ) {
    this.messages.push( new CompileMessage( loc, msg, severity ) );
  }
  // method which is called by generated parser:
  syntaxError( recognizer, offendingSymbol, line, column, msg, e ) {
    var loc = recognizer.tokenLocation( offendingSymbol );
    //console.log(e); throw new CompileMessage( loc, msg );
    var err = new CompileMessage( loc, msg[0].toUpperCase() + msg.slice(1) );
    if (e && e.expectedTokens)
      err.expectedTokens = e.expectedTokens;
    this.messages.push( err );
  }
}

class RewriteTypeTokenStream extends antlr4.CommonTokenStream {
  constructor(...args) {
    super(...args);
  }
  LT( k ) {
    let t = super.LT(k);
    if (!t || !t.type)
      return t;
    if (t.type === this.DOT) {
      let n = super.LT(k+1);
      if (n && n.type === this.BRACE)
        t.type = this.DOTbeforeBRACE;
    }
    else if (t.type === this.NEW) {
      let n = super.LT(k+1);
      if (n && n.type === this.Identifier && /^st_/i.test( n.text )) {
        let o = super.LT(k+2);
        if (o && o.type === this.PAREN)
          return t;
      }
      t.type = this.Identifier;
    }
    return t;
  }
}

function initTokenRewrite( recognizer, ts ) { // ts = tokenStream
  ts.DOTbeforeBRACE = Parser.DOTbeforeBRACE;
  ts.BRACE = tokenTypeOf( recognizer, "'{'" );
  ts.DOT = ts.DOTbeforeBRACE && ts.BRACE && tokenTypeOf( recognizer, "'.'" );
  ts.NEW = Parser.NEW;
  ts.Identifier = Parser.Identifier;
  ts.PAREN = tokenTypeOf( recognizer, "'('" );

  recognizer.tokenRewrite = [];
  if (Parser.Identifier) {
    if (ts.DOT && ts.DOTbeforeBRACE)
      recognizer.tokenRewrite[ ts.DOTbeforeBRACE - Parser.Identifier] = ts.DOT;
  }
  // console.log( ts.DOTbeforeBRACE, ts.BRACE, ts.DOT, recognizer.tokenRewrite );
}

function tokenTypeOf( recognizer, literalName ) {
  let r = recognizer.literalNames.indexOf( literalName );
  return (r>0) ? r : 0;
}

// Parse string `source` and return the AST (empty if serious parse error) with
// a property `messages` for the syntax errors.  Argument `filename` is used in
// the AST locations and error messages.  If provided, `options` are compile
// options.

const rules = {
  cdl: { func: 'start', returns: 'source', frontend: 'cdl' },
  query: { func: 'queryEOF', returns: 'query' },
  expr: { func: 'conditionEOF', returns: 'cond' } // yes, condition
}

function parse( source, filename = '<undefined>.cds', options = {}, rule = 'cdl' ) {
  var lexer = new Lexer( new antlr4.InputStream(source) );
  var tokenStream = new RewriteTypeTokenStream(lexer);
  var parser = new Parser( tokenStream );
  var errorListener = new ErrorListener();

  initTokenRewrite( parser, tokenStream );
  parser.options = options;
  parser.filename = filename;
  // comment the following 2 lines if you want to output the parser errors directly:
  parser.messageErrorListener = errorListener;
  parser._errHandler = new errorStrategy.KeywordErrorStrategy();
  parser.match = errorStrategy.match;
  // parser.consume = errorStrategy.consume;
  // parser.exitRule = errorStrategy.exitRule;
  // parser.epsilon = errorStrategy.epsilon; // for empty alts
  parser._interp.predictionMode = antlr4.atn.PredictionMode.SLL;
  // parser._interp.predictionMode = antlr4.atn.PredictionMode.LL_EXACT_AMBIG_DETECTION;

  if (options.traceParser) {
    parser.setTrace(true);
    // parser._interp.debug = true; // output too long
    parser._interp.debug_list_atn_decisions = true;
    parser._interp.dfa_debug = true;
    parser._interp.retry_debug = true;
    parser._interp.debug_add = true;
  }
  else if (options.traceParserAmb) {
    let listener = new antlr4.error.DiagnosticErrorListener();
    //listener.exactOnly = false;
    parser.addErrorListener( listener );
    parser._interp.predictionMode = antlr4.atn.PredictionMode.LL_EXACT_AMBIG_DETECTION;
  }
  else {
    parser.removeErrorListeners();
    parser.addErrorListener( errorListener );
  }

  if (options.parseListener) {
    parser.addParseListener(options.parseListener);
  }

  var rulespec = rules[rule];
  var tree = rule && parser[ rulespec.func ]();
  var ast = tree && tree[ rulespec.returns ] || {};
  if (rulespec.frontend)
    ast.$frontend = rulespec.frontend;

  ast.messages = errorListener.messages;
  if (options.attachTokens === true || options.attachTokens === filename)
    ast.tokenStream = tokenStream;
  // if (filename === '<condition>.cds') console.log(ast)
  return ast;
}

module.exports = parse;
