// ANTLR4 grammar to generate Parser and Lexer for CDS-Language

// To be built the parser by hand, install Java, download the ANTLR4 tool, then
//   antlr4 -no-listener -o ../gen language.g4
// Alternatively, install Java, and use
//   npm run download && npm run gen
//
// To test the parser in the REPL, see file './lib/language/antlrParser.js'.

// This grammar is built according to the following guidelines:
//
//  * Do not express every syntactical restriction by grammar rules, and do
//    not define a grammar which allows every nonsense.  We might specify
//    syntactical restrictions in a certain form inside actions or semantic
//    predicates to have them directly available for IDE code completion.
//
//  * Keep the number of token types small.  Thus, do not define different
//    token types for things which are not distinguished in the parser.
//    Examples: one token type for numbers (have a check if you just want to
//    allow integers at certain places), one token type for non-quoted and
//    quoted identifiers.
//
//  * Keep the number of keywords as small as possibile.  Thus, built-ins is a
//    topic for the semantic analysis, not the grammar.  Examples: no keywords
//    for built-in types or built-in SQL functions.  This also avoids noise in
//    the grammar and a huge/slow generated parser.  Add each new non-reserved
//    keyword to rule `ident`, but check for ambiguities!
//  ┌─────────────────────────────────────────────────────────────────────────┐
//    For our adapted ANTLR error strategy concerning (non-reserved) keywords,
//    make sure to define non-reserved keywords between the lexer rule `Number`
//    and `Identifier`.  The latter must be the second last rule, the last is
//    `IllegalToken`.  Do not rename these three rules.
//  └─────────────────────────────────────────────────────────────────────────┘
//
//  * Left-factor the parser grammar if the same initial part covers more than
//    one or two tokens.  ANTLRs adaptive predication allows to write "natural"
//    rules, but slows down parsing, especially if a long lookahead is need to
//    solve an LLk ambiguity.  Therefore, try to avoid it in rules which are
//    called often.  Unfortunately, we cannot use ANTLR3's grammar and subrule
//    option 'k' (lookahead depth) anymore...  Therefore...
//  ┌─────────────────────────────────────────────────────────────────────────┐
//    Before each alternative with LL1 ambiguities (looking at the next token
//    is not enough for a decision), write a comment starting with `#ATN:`
//    which describes the ambiguity.  Additionally, put a comment `/* #ATN n
//    */` INSIDE an (`@after`) action of a rule if the corresponding function
//    in '../gen/langageParser.js' contains `n` occurrences of
//    `adaptivePredict` calls.  This is checked in 'test/testCompiler.js',
//    which also counts the total number of `adaptivePredict` occurrences.
//  └─────────────────────────────────────────────────────────────────────────┘
//
//  * For fast parsing and lower memory consumption, we use ANTLR4 with SLL
//    prediction-mode only.  That means that ANTLR does not use the actual call
//    stack when deciding which alternative to choose in a rule.  You might
//    need to copy a rule manually to get less ambiguities - this might be a
//    good idea anyway to avoid calls to `adaptivePredict`, see the rules
//    starting with `annotationAssignment_`.
//
//  * Do not use actions in the lexer.  Examples: de-quote string literals not
//    in the lexer, but in the parser; do not throw errors, but produce error
//    tokens if necessary.
//
//  * Use actions in the parser to produce a Augmented CSN model.  To have it
//    also in the case of syntax errors, produce it by adding sub-nodes to a
//    parent node, not by returning the nodes (the latter is fine for secondary
//    attachments).
//
//  * Action code should be a one-liner (<100 chars); usually, just one action
//    is called per alternative (plus the @after action which sets the AST
//    location).  For more complicated code, define a method in file
//    './genericAntlrParser.js'.
//
//  * Do not write lexer rules for tokens like ';', use ';' directly in the
//    parser rule.  Advantage: better error messages; taste: more or less
//    readable grammar; disadvantage: debugging in generated code.
//
//  * Use all-upper token names for keywords (e.g. CONTEXT), capitalized ones
//    (e.g. Number) for others - EOF is the exception (is ANTLR-builtin).
//    Remember: parser rule names in ANTLR start with a lower-case letter.
//
//  * No useless parentheses in the grammar.  There are just two binary grammar
//    operators: alternative (`|`) and sequence.  It should not be too hard to
//    remember that sequence binds stronger than alternative.
//
//  * Use the following indentation rules:
//     - rule header: indentation 0 + 2* parentheses/braces depth
//     - rule colon (':' separating header & body): 2
//     - rule body: 4 + 2* parentheses/braces depth, -2 for certain chars at
//       beginning of line: '|', ')', ']' or '}'
//     - inside action: as for the action language, e.g. function argument
//       alignment
//     - rule semicolon (';' ending body, before exceptions): 2
//     - rule exceptions (seldomly used): 2 + 2* parentheses/braces depth

// Some practical info:
//
//  * The end location for the match of a rule is just available in the @after
//    action.  Use method `attachLocation` there on the produced AST.
//
//  * Be careful with the rule names: the methods in antlr4.Parser, the methods
//    in `./antlrParser' and the parser rule names share the same namespace.
//    Any shadowing lead to an exception when running 'test/testCompiler.js'.
//
//  * Be careful with names for rule arguments, returns, locals and rule
//    reference labels: the names `parser`, `parent` and `invokingState` cannot
//    be used (these are added by the generator).

grammar language;
options {
  language = JavaScript;
  superClass = genericAntlrParser;
}
tokens {
  DOTbeforeBRACE
}

// Top-Level -----------------------------------------------------------------

start returns [ source = { kind: 'source' } ]
@after{ /* #ATN 1 */ }
  :
    // #ATN: both package and other definition can start with DEFINE
    packageDef[$source]
    EOF
  |
    ( namespaceDeclaration[$source] inPackageDeclaration[$source]?
    | inPackageDeclaration[$source] namespaceDeclaration[$source]?
    )?
    usingDeclaration[$source]*
    artifactDef[$source]*
    EOF
  ;

queryEOF returns [ query ]
  :
    q=queryExpression { $query = $q.query; } EOF
  ;

conditionEOF returns [ cond ]
  :
    c=condition { $cond = $c.cond; } EOF
  ;

inPackageDeclaration[ source ] locals[ decl = {} ]
@after { $source.package = this.attachLocation($decl); }
  :
    IN p=PACKAGE simplePath[ $decl ] ';'
    { this.notYet('Packages', $p, ['hanaFlavor']); }
  ;

namespaceDeclaration[ source ] locals[ decl = {} ]
@after { $source.namespace = this.attachLocation($decl); }
  :
    NAMESPACE simplePath[ $decl ]
    (
      ';'
      { if (this.options.hanaFlavor) { $decl.dcPath = $decl.path; delete $decl.path; } }
    )
  |
    prefix=NAMEPREFIX simplePath[ $decl ] ';'
    { this.message( `Use keyword 'namespace' instead of 'nameprefix'`, this.tokenLocation($prefix), 'Warning' ); }
  ;

usingDeclaration[ source ] locals[ decl ]
@after { if ($decl) this.attachLocation($decl); }
  :
    USING
    (
      FROM str=String
       {
         if (!$source.dependencies) $source.dependencies = [];
         $source.dependencies.push( this.quotedLiteral( $str, 'string' ) );
      }
    |
      path=externalPath
      { $decl = this.addItem( $source, 'usings', 'using', [], { extern: $path.extern } ); }
      ( AS name=ident { $decl.name = $name.id; } )?
      ( FROM
        (
          str=String
          {
            if (!this.options.tntFlavor || this.options.tntFlavor.skipUsingFromIgnoring) {
              if (!$source.dependencies) $source.dependencies = [];
              $source.dependencies.push( this.quotedLiteral( $str, 'string' ) );
            }
          }
        |
          id=Identifier
          {
            if (!this.options.tntFlavor || this.options.tntFlavor.skipUsingFromIgnoring) {
              this.message( `Mismatched input Identifier expecting String`,
                            this.tokenLocation($id) );
            }
          }
        )
      )?
    |
      { $decl = this.addItem( $source, 'usings', 'using', [] ); }
      // We could just create "independent" USING declaration, but if we want
      // to have some check in the future whether the external artifacts are
      // really in the FROM source...
      '{'
      innerUsing[ $decl ] ( ',' innerUsing[ $decl ] )*
      '}'
      ( FROM str=String
        {
          if (!$source.dependencies) $source.dependencies = [];
          $source.dependencies.push( this.quotedLiteral( $str, 'string' ) );
        }
      )?
    )
    ';'
  ;

innerUsing[ using ] locals[ decl ]
@after { if ($decl) this.attachLocation($decl); }
  :
    path=externalPath
    { $decl = this.addItem( $using, 'usings', 'using', null, { extern: $path.extern } ); }
    ( AS name=ident { $decl.name = $name.id; } )?
  ;

externalPath returns [ extern = {} ]
  :
    simplePath[ $extern ]
    ( '::' { $extern.dcPath = $extern.path; delete $extern.path; }
      simplePath[ $extern ]
    )?
  ;

// We have two versions of the annotation assignment rule, because we do not
// want to let the ambiguity in select items (solution: "either" possibility)
// creep into all annotation assignments:
//   const value = 3
//   view V as select from E {    // either: anno value 3, select item -x
//     @anno :value - x as x;     // or: anno value true, select item 3-x
//   }

annotationAssignment_1[ annos ] locals[ assignment = { name: {} } ]
@after { $annos.push( this.attachLocation($assignment) ); }
  :
    simplePath[ $assignment.name ]
    ( '#' variant=ident { $assignment.name.variant = $variant.id; } )?
    ( ':' val=value { $assignment.value = $val.val; } )?
  ;

annotationAssignment_fix[ annos ] locals[ assignment ]
// no variant or value outside @(...)
@after { if ($assignment) $annos.push( this.attachLocation($assignment) ); }
  :
    '@'
    ( '('
      (
        annotationAssignment_1[ $annos ]
        ( ',' ( annotationAssignment_1[ $annos ] )? )*
      )?                        // TODO: this optional is strange
      ')'
    |
      { $assignment = { name: {} }; }
      simplePath[ $assignment.name ]
      ( '#' variant=ident { $assignment.name.variant = $variant.id; } )?
      {
        var t = this.getCurrentToken();
        if (t.text === ':')
          this.message( `Better use '@(...)' for annotation assignments before ':'`,
                        this.tokenLocation(t), 'Warning' );
      }
    )
  ;

annotationAssignment_fix_tntextra[ annos ] locals[ assignment ]
@after { if ($assignment) $annos.push( this.attachLocation($assignment) ); }
  :
    '@'
    ( '('
      (
        annotationAssignment_1[ $annos ]
        ( ',' ( annotationAssignment_1[ $annos ] )? )*
      )?                        // TODO: this optional is strange
      ')'
    |
      { $assignment = { name: {} }; }
      simplePath[ $assignment.name ]
      ( '#' variant=ident { $assignment.name.variant = $variant.id; } )?
      (
        t=':' val=value
        {
          $assignment.value = $val.val;
          if (!this.options.tntFlavor || this.options.tntFlavor.skipSloppyAnnoAssignments) {
            this.message( `Use '@(...)' for annotation assignments here`,
                          this.tokenLocation($t) );
          }
        }
      )?
    )
  ;

annotationAssignment_ll1[ annos ] locals[ assignment ]
@after { if ($assignment) $annos.push( this.attachLocation($assignment) ); }
  :
    '@'
    ( '('
      (
        annotationAssignment_1[ $annos ]
        ( ',' ( annotationAssignment_1[ $annos ] )? )*
      )?                        // TODO: this optional is strange
      ')'
    |
      { $assignment = { name: {} }; }
      simplePath[ $assignment.name ]
      ( '#' variant=ident { $assignment.name.variant = $variant.id; } )?
      ( ':' val=value { $assignment.value = $val.val; } )?
    )
  ;

annotationAssignment_atn[ annos ] locals[ assignment ]
@after { /* #ATN 2 */ if ($assignment) $annos.push( this.attachLocation($assignment) ); }
  :
    '@'
    ( '('
      (
        annotationAssignment_1[ $annos ]
        ( ',' ( annotationAssignment_1[ $annos ] )? )*
      )?                        // TODO: this optional is strange
      ')'
    |
      { $assignment = { name: {} }; }
      simplePath[ $assignment.name ]
      // #ATN: '#' can also start enum value, which can start an expression
      ( '#' variant=ident { $assignment.name.variant = $variant.id; } )?
      // #ATN: ':' is optional continuation, ':' can follow from queryPath
      ( ':' val=value { $assignment.value = $val.val; } )?
    )
  ;

// Main artifact definitions -------------------------------------------------

artifactDef[ outer, defOnly = false ] locals[ annos = [] ] // cannot use `parent` as parameter name!
@after{ /* #ATN 1 */ }
  :
    annotationAssignment_ll1[ $annos ]*
    (
      DEFINE?
      ( contextDef[ $outer, this.startLocation(), $annos, defOnly ]
      | entityDef[ $outer, this.startLocation(), $annos ]
      | typeDef[ $outer, this.startLocation(), $annos ]
      | annotationDef[ $outer, this.startLocation(), $annos ]
      | constDef[ $outer, this.startLocation(), $annos ]
      | viewDef[ $outer, this.startLocation(), $annos ]
      | accesspolicyDef[ $outer ] // sic! TODO: semantic error
      | actionFunctionMainDef[ $outer, this.startLocation(), $annos ]
      )
    |
      extend=EXTEND
      { if (defOnly) this.message( `No 'EXTEND artifact' within 'EXTEND ${defOnly.toUpperCase()}'`,
                                   this.tokenLocation($extend) ); }
      // #ATN: EXTEND elem, while CONTEXT, ENTITY etc are not reserved
      ( extendContext[ $outer, this.startLocation(), $annos ]
      | extendEntity[ $outer, this.startLocation(), $annos ]
      | extendProjection[ $outer, this.startLocation(), $annos ]
      | extendType[ $outer, this.startLocation(), $annos ]
      | extendAnnotation[ $outer, this.startLocation(), $annos ]
      | extendConst[ $outer, this.startLocation(), $annos ]
      | extendView[ $outer, this.startLocation(), $annos ]
        // TODO: what about extendAction
      | extendArtifact[ $outer, this.startLocation(), $annos ]
      )
    |
      annotate=ANNOTATE
      { if (defOnly) this.message( `No 'ANNOTATE artifact' within 'EXTEND ${defOnly.toUpperCase()}'`,
                                   this.tokenLocation($annotate) ); }
      annotateArtifact[ $outer, this.startLocation(), $annos ] // not kind-specific
    )
  ;

packageDef[ outer, loc, annos ] locals[ name = {}, art ]
@after { this.attachLocation($art); }
  :
    DEFINE? p=PACKAGE simplePath[ $name ]
    { $art = this.addDef( $outer, 'artifacts', 'package', $name );
      this.notYet('Packages', $p, ['hanaFlavor']); }
    (
      DEPENDS ON
      packageDependency[$art] ( ',' packageDependency[$art] )*
    )?
    ';'
  ;

packageDependency[ outer ] locals[ dep = {} ]
  :
    simplePath[ $dep, true ]
    { this.addItem( $outer, 'dependsOn', 'package', true, $dep ); }
  ;

contextDef[ outer, loc, annos, defOnly = false ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    ( CONTEXT | service=SERVICE ) simplePath[ $name ]
    // TODO: still unclear what a SERVICE is exactly
    { $art = this.addDef( $outer, 'artifacts', $service ? 'service' : 'context', $name, $annos,
                          { }, $loc ); }
    annotationAssignment_fix_tntextra[ $annos ]*
    (
      '{'
      artifactDef[ $art, defOnly ]*
      '}' ';'?
    |
      ';'
    )
  ;

extendContext[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    ( CONTEXT | service=SERVICE ) simplePath[ $name ]
    { $art = this.addItem( $outer, 'extensions', 'extend', $annos,
                           { name: $name, expectedKind: $service ? 'service' : 'context' },
                           loc );  }
    ( WITH { this.noSemicolonHere(); } )?
    annotationAssignment_ll1[ $annos ]*
    (
      '{'
      artifactDef[ $art, $service ? 'service' : 'context' ]*
      '}' ';'?
    |
      ';'
    )
  ;

entityDef[ outer, loc, annos ] locals[ art, name = {} ]
@after { /* #ATN 1 */ this.attachLocation($art); }
  :
    tmp=TEMPORARY? abs=ABSTRACT? ENTITY simplePath[ $name ]
    { $art = this.addDef( $outer, 'artifacts', 'entity', $name, $annos,
                          { temporary: $tmp, abstract: $abs }, $loc );
      if ($tmp) this.notYet('Temporary entities', $tmp, ['hanaFlavor']); }
    annotationAssignment_fix[ $annos ]*
    (
      /* WITH PARAMETERS */
      '('
      actionFunctionParamDef[ $art ]
      ( ',' actionFunctionParamDef[ $art ] )*
      ')'
    )?
    (
      ( ':'
        includeRef[ $art ] ( ',' includeRef[ $art ] )*
      )?
      '{'
      { $art.elements = Object.create(null); } // better for include and annotate
      (
        elementDef[ $art ]+
        // #ATN: element name can be SERIES
        ( seriesDef ';'? )?         // defined in a section below
      )?
      '}'
      // TODO: action definitions in a specific section?
      ( ACTIONS '{' actionFunctionDef[ $art ]+ '}' )?
      technicalConfiguration[ $art ]?     // defined in a section below
      ';'?
    |
      AS
      ( qe=queryExpression
        { $art.query = $qe.query; $art.kind = 'view'; } // TODO: re-think kind
      | qp=projectionSpec
        { $art.query = $qp.query; $art.projection = {}; } // TODO: remove `projection`?
      )
      (
        ACTIONS '{' actionFunctionDef[ $art ]+ '}'
        ';'?
      |
        ';'
      )
    )
  ;

projectionSpec returns[ query ] locals[ src = {} ]
@after { this.attachLocation($query); }
  :
    proj=PROJECTION ON               // FIXME: First draft only, details unclear/unspecified
    // now a simplified `tableTerm`:
    { $query = { op: this.tokenLocation( $proj, undefined, 'query' ), from: [ $src ] }; }
    simplePath[ $src, true ]
    ( AS aliasName=ident { $src.name = $aliasName.id } )?
    (
      '{'
      ( star='*'
        {
          $query.all = this.tokenLocation( $star, undefined, true );
          $query.elements = Object.create(null); // see comment in `initQueryExpression`
        }
      |
        projectionWithOptAlias[ $query ]
      )
      ( ',' projectionWithOptAlias[ $query ] )*
      '}'
    |
      // epsilon
      {
        $query.all = { val: 'implicit', location: $src.location };
        $query.elements = Object.create(null);
      }
    )
    (
      // syntax is less than ideal - EXCLUDING is only useful for `*` - with
      // this syntax, people wonder what happens with explicit select items
      EXCLUDING
      '{'
      projectionExclusion[ $query ]
      ( ',' projectionExclusion[ $query ] )*
      '}'
    )?
  ;

projectionExclusion[ outer ] locals[ art ]
@after { this.attachLocation($art); }
  :
    name=ident
    { $art = this.addDef( $outer, 'exclude', '', $name.id ); }
  ;

// TODO: restriction in comparison to `selectItemDef` completly unclear
projectionWithOptAlias[ outer ] locals[ art, alias, annos = [], item = {} ]
@after { this.attachLocation($art); }
  :
    annotationAssignment_ll1[ $annos ]*
    simplePath[ $item ]
    ( AS aident=ident { $alias=$aident.id } )?
    {
      $art = this.addDef( $outer, 'elements', 'element', $alias || $item.path,
                          $annos, { value: $item, name: $alias }); }
    annotationAssignment_fix[ $annos ]*
    ( ':' re=REDIRECTED to=TO
      { $art.redirected = this.tokenLocation($re,$to,true); $art.target = {}; }
      simplePath[ $art.target, true ]
      annotationAssignment_ll1[ $annos ]*
    )?
  ;

extendEntity[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    ENTITY simplePath[ $name ]
    { $art = this.addItem( $outer, 'extensions', 'extend', $annos,
                           { name: $name, expectedKind: 'entity' }, loc );  }
    ( WITH { this.noSemicolonHere(); } )?
    annotationAssignment_ll1[ $annos ]*
    (
      '{'
      elementDefOrExtend[ $art ]+
      '}'
      // TODO: action definitions in a specific section?
      ( ACTIONS '{' actionFunctionDef[ $art ]+ '}' )?
      technicalConfiguration[ $art ]?
      ';'?
    |
      // TODO: action definitions in a specific section?
      ACTIONS '{' actionFunctionDef[ $art ]+ '}'
      technicalConfiguration[ $art ]?
      ';'?
    |
      technicalConfiguration[ $art ]
      ';'?
    |
      ';'
    )
  ;


extendProjection[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    expected=PROJECTION simplePath[ $name ]
    { this.notYet('EXTEND PROJECTION', $expected);
      $art = this.addItem( $outer, 'extensions', 'extend', $annos,
                           { name: $name, expectedKind: 'entity' }, // or 'projection'?
                           loc );  }
    ( WITH { this.noSemicolonHere(); } )?
    annotationAssignment_ll1[ $annos ]*
    (
      '{'
      projectionWithOptAlias[ $art ]
      ( ',' projectionWithOptAlias[ $art ] )*
      '}'
      ( ACTIONS '{' actionFunctionDef[ $art ]+ '}' )?
      ';'?
    |
      ACTIONS '{' actionFunctionDef[ $art ]+ '}'
      ';'?
    |
      ';'
    )
  ;

// TODO: no action extension?
actionFunctionDef[ outer ] locals[ art, annos = [] ]
@after { this.attachLocation($art); }
  :
    annotationAssignment_ll1[ $annos ]*
    (
      ACTION name=ident
      { $art = this.addDef( $outer, 'actions', 'action', $name.id, $annos ); }
      annotationAssignment_fix[ $annos ]*
      '('
      ( actionFunctionParamDef[ $art ]
        ( ',' actionFunctionParamDef[ $art ] )* )?
      ')'
      (
        { $art.returns = {}; }
        returnTypeSpec[ $art.returns, $annos ]
      )?
      ';'
    |
      FUNCTION name=ident
      { $art = this.addDef( $outer, 'actions', 'function', $name.id, $annos ); }
      annotationAssignment_fix[ $annos ]*
      '('
      ( actionFunctionParamDef[ $art ]
        ( ',' actionFunctionParamDef[ $art ] )* )?
      ')'
      { $art.returns = {}; }
      returnTypeSpec[ $art.returns, $annos ]
      ';'
    )
  ;

actionFunctionMainDef[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    ACTION simplePath[ $name ]
    { $art = this.addDef( $outer, 'artifacts', 'action', $name, $annos ); }
    annotationAssignment_fix[ $annos ]*
    '('
    ( actionFunctionParamDef[ $art ]
      ( ',' actionFunctionParamDef[ $art ] )* )?
    ')'
    (
      { $art.returns = {}; }
      returnTypeSpec[ $art.returns, $annos ]
    )?
    ';'
  |
    FUNCTION simplePath[ $name ]
    { $art = this.addDef( $outer, 'artifacts', 'function', $name, $annos ); }
    annotationAssignment_fix[ $annos ]*
    '('
    ( actionFunctionParamDef[ $art ]
      ( ',' actionFunctionParamDef[ $art ] )* )?
    ')'

    { $art.returns = {}; }
    returnTypeSpec[ $art.returns, $annos ] // TODO: really annos hhere?
    ';'
  ;

actionFunctionParamDef[ outer ] locals[ art, annos = [] ]
@after { this.attachLocation($art); }
  :
    annotationAssignment_ll1[ $annos ]*
    name=ident
    { $art = this.addDef( $outer, 'params', 'param', $name.id, $annos ); }
    annotationAssignment_fix[ $annos ]*
    ':' typeRef[ $art ]
    nullability[ $art ]?
    annotationAssignment_ll1[ $annos ]*
  ;

typeDef[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    db=TABLE? TYPE simplePath[ $name ]
    { $art = this.addDef( $outer, 'artifacts', 'type', $name, $annos,
                          { dbType: $db }, $loc );
      if ($db) this.notYet('Table types', $db, ['hanaFlavor']); }
    annotationAssignment_fix[ $annos ]*
    typeSpecSemi[ $art, $annos ]
  ;

extendType[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    TYPE simplePath[ $name ]
    { $art = this.addItem( $outer, 'extensions', 'extend', $annos,
                           { name: $name, expectedKind: 'type' },
                           loc );  }
    extendWithOptElements[ $art, $annos ]
  ;

annotationDef[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    ANNOTATION simplePath[ $name ]
    { $art = this.addDef( $outer, 'artifacts', 'annotation', $name, $annos, {}, $loc ); }
    annotationAssignment_fix[ $annos ]*
    typeSpecSemi[ $art, $annos ]
  ;

extendAnnotation[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    ANNOTATION simplePath[ $name ]
    { $art = this.addItem( $outer, 'extensions', 'extend', $annos,
                           { name: $name, expectedKind: 'annotation' },
                           loc );  }
    extendWithOptElements[ $art, $annos ]
  ;

extendArtifact[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    simplePath[ $name ]
    { $art = this.addItem( $outer, 'extensions', 'extend', $annos,
                           { name: $name }, loc );  }
    extendWithOptElements[ $art, $annos ]
  ;

extendWithOptElements[ art, annos ]
  :
    ( WITH { this.noSemicolonHere(); } )?
    annotationAssignment_ll1[ $annos ]*
    (
      '{'
      elementDefOrExtend[ $art ]+
      '}'
      ';'?
    |
      ';'
    )
  ;

annotateArtifact[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    simplePath[ $name ]
    { $art = this.addItem( $outer, 'extensions', 'annotate', $annos, { name: $name }, loc ); }
    ( WITH { this.noSemicolonHere(); } )?
    annotationAssignment_ll1[ $annos ]*
    (
      '{'
      annotateElement[ $art ]*
      '}'
      (
        ACTIONS
        '{'
        annotateAction[ $art ]*
        '}'
      )?
      ';'?
    |
      ACTIONS
      '{'
      annotateAction[ $art ]*
      '}' ';'?
    |
      '('
      annotateParam[ $art ] ( ',' annotateParam[ $art ] )*
      ')'
      (
        RETURNS '{'
        annotateElement[ $art ]*
        '}' ';'?
      |
        ';'
      )
    |
      RETURNS '{'
      annotateElement[ $art ]*
      '}' ';'?
    |
      ';'
    )
  ;

annotateElement[ outer ] locals[ art, annos = [] ]
@after{ this.attachLocation($art); }
  :
    annotationAssignment_ll1[ $annos ]*
    name=ident
    { $art = this.addDef( $outer, 'elements', 'annotate', $name.id, $annos ); }
    annotationAssignment_ll1[ $annos ]*
    (
      '{'
      annotateElement[ $art ]*
      '}' ';'?
    |
      ';'
    )
  ;

annotateAction [ outer ] locals [ art, annos = [] ]
@after{ this.attachLocation($art); }
  :
    annotationAssignment_ll1[ $annos ]*
    name=ident
    { $art = this.addDef( $outer, 'actions', 'annotate', $name.id, $annos ); }
    annotationAssignment_ll1[ $annos ]*
    (
      '('
      annotateParam[ $art ] ( ',' annotateParam[ $art ] )*
      ')'
    )?
    (
      RETURNS '{'
      annotateElement[ $art ]*
      '}' ';'?
    |
      ';'
    )
  ;

annotateParam [ outer ] locals [ art, annos = [] ]
@after{ this.attachLocation($art); }
  :
    // annotate parameter
    annotationAssignment_ll1[ $annos ]*
    param=ident
    { $art = this.addDef( $outer, 'params', 'annotate', $param.id, $annos ); }
    annotationAssignment_ll1[ $annos ]*
  ;

// Constant and Element definition and its helpers ---------------------------

constDef[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    c=CONST simplePath[ $name ]
    { this.notYet('Constants', $c, ['hanaFlavor']);
      $art = this.addDef( $outer, 'artifacts', 'const', $name, $annos, {}, $loc ); }
    annotationAssignment_fix[ $annos ]*
    typeSpec[ $art, $annos ]?
    '=' expression
    ';'
  ;

extendConst[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    CONST simplePath[ $name ]
    { $art = this.addItem( $outer, 'extensions', 'extend', $annos,
                           { name: $name, expectedKind: 'const' },
                           loc );  }
    ( WITH { this.noSemicolonHere(); } )?
    annotationAssignment_ll1[ $annos ]*
    ';'
  ;

enumSymbolDef[ outer ] locals[ art, annos = [] ]
@after { this.attachLocation($art); }
  :
    annotationAssignment_ll1[ $annos ]*
    name=ident
    { $art = this.addDef( $outer, 'enum', 'enum', $name.id, $annos ); }
    annotationAssignment_ll1[ $annos ]*
    ( '=' val=value { $art.value = $val.val; }
      annotationAssignment_ll1[ $annos ]*
    )?
    ';'
  ;

elementDefOrExtend[ outer ] locals[ annos = [] ]
@after { /* #ATN 1 */ if ($ctx.art) this.attachLocation($art.art); }
// tool complains if I test for ($art)
  :
    annotationAssignment_ll1[ $annos ]*
    // #ATN: element name for definition can be EXTEND
    (
      EXTEND
      extendElement[ $outer, this.startLocation(), $annos ]
    |
      art = elementDefInner[ $outer, this.startLocation(), $annos, true ]
    )
  ;

elementDef[ outer ] locals[ annos = [] ]
@after { this.attachLocation($art.art); }
  :
    annotationAssignment_ll1[ $annos ]*
    art = elementDefInner[ $outer, this.startLocation(), $annos, false ]
  ;

mixinElementDef[ outer ] locals[ art ]
@after { /* #ATN 3 */ this.attachLocation($art); }
  :
    // #ATN: element name can be ELEMENT
    ELEMENT?
    name=ident
    { $art = this.addDef( $outer, 'mixin', 'element', $name.id ); }
    (
      ':'
      // #ATN: referenced type name can be ASSOCIATION or COMPOSITION
      (
        typeAssociationBase[ $art ]
        // #ATN: path could start with MANY or ONE - make sure a token follows in same rule!
        ( typeToMany[ $art ] | typeToOne[ $art ] | simplePath[ $art.target, true ] )
        typeAssociationCont[ $art ]
      |
        typeRef[ $art ]
        ( as='=' expression
          { this.notYet('Calculated fields', $as, ['hanaFlavor']); }
        )?
      )
    |
      as='=' expression
      { this.notYet('Calculated fields', $as, ['hanaFlavor']); }
    )
    ';'
  ;

elementDefInner[ outer, loc, annos, allowEq ] returns[ art ]
@after{ /* #ATN 5 */ }
  :
    // TODO: it would be excellent to remove ELEMENT...
    // or have a special ident rule without the ELEMENT
    // Reason: it would be good for error recover to start a major block without LL1 ambiguity
    // #ATN: element name can be VIRTUAL, MASKED or ELEMENT (3x)
    virtual=VIRTUAL? key=KEY? masked=MASKED?    // TODO: order?
    ELEMENT?
    name=ident
    { $art = this.addDef( $outer, 'elements', 'element', $name.id, $annos,
                          { virtual: $virtual, key: $key, masked: $masked },
                          $loc ); }
    annotationAssignment_fix[ $annos ]*
    // TODO: we can think of making the typeSpec optional and do checks instead:
    // type optional with '=', type required otherwise
    (
      typeStruct[ $art ] nullability[ $art ]?
    |
      ':'
      // #ATN: referenced type name can be ASSOCIATION or ARRAY or TYPE or LOCALIZED
      ( typeStruct[ $art ] nullability[ $art ]?
      | typeAssociationBase[ $art ]
        // #ATN: path could start with MANY or ONE - make sure a token follows in same rule!
        ( typeToMany[ $art ] | typeToOne[ $art ] | simplePath[ $art.target, true ] )
        typeAssociationContNullability[ $art ]
      | typeArray[ $art, $annos ]
      | typeTypeOf[ $art ] elementProperties[ $art ]?
      | l=LOCALIZED { $art.localized = this.tokenLocation( $l, undefined, true ); }
        typeSimple[ $art, $annos ] elementProperties[ $art ]?
      | typeSimple[ $art, $annos ] elementProperties[ $art ]?
      )
    |
      ( as=AS | eq='=' ) e=expression
      {
        if ($as || !$allowEq || $e.expr && !$e.expr.literal )
          this.notYet('Calculated fields', $as || $eq, ['hanaFlavor']);
        else if ($e.expr)
          $art.value = $e.expr;
      }
    )
    annotationAssignment_ll1[ $annos ]* // TODO: can we get rid of this?
    ';'
  ;

extendElement[ outer, loc, annos ] locals[ art ]
@after{ /* #ATN 1 */ this.attachLocation($art); }
  :
    // #ATN: element name can be ELEMENT
    expected=ELEMENT? name=ident
    { $art = this.addDef( $outer, 'elements', 'extend', $name.id, $annos,
                          { expectedKind: $expected && 'element' },
                          $loc ); }
    extendWithOptElements[ $art, $annos ]
  ;


selectItemDef[ outer ] locals[ art = {}, alias, annos = [], item = {} ] // AnnotatedQLSelectItem
@after{ /* #ATN 1 */ this.attachLocation($art); }
  :
    annotationAssignment_atn[ $annos ]*
    key=KEY?
    (
      e=expression
      ( AS n1=ident { $alias=$n1.id } | n2=ident { $alias=$n2.id } )?
      // path as p1 { x as x1 }  // is utterly wrong - if allowed, only:
      // path { x as x1 } as p1
      {
        if ($alias || $e.expr && $e.expr.path)
          $art = this.addDef( $outer, 'elements', 'element', $alias || $e.expr.path,
                              $annos, { value: $e.expr, name: $alias, key: $key });
        else if ($e.expr)
          this.message( 'Required alias name for select item', $e.expr.location );
      }
      (
        // TODO: only after simple path in expression
        selectItemInline        // "expand"
      |
        // TODO: only after simple path in expression, complain if AS had been used
        DOTbeforeBRACE selectItemInline // "inline"
      )?
    |
      selectItemInline
      ( AS n1=ident { $alias=$n1.id } | n2=ident { $alias=$n2.id } ) // AS name enforced with KEY
      {
        $art = this.addDef( $outer, 'elements', 'element', $alias,
                            $annos, { name: $alias, key: $key });
      }
    )
    annotationAssignment_fix[ $annos ]*
    ( ':'
      // #ATN: typeRef can start with TYPE
      ( re=REDIRECTED to=TO
        { $art.redirected = this.tokenLocation($re,$to,true); $art.target = {}; }
        simplePath[ $art.target, true ]
      | typeTypeOf[ $art ]
      | typeRef[ $art ]         // TODO: annos here?
      )
      {
        $art._typeIsExplicit = true; // FIXME: We probably need to deal with explicit vs. propagated in more places
      }
    )?
  ;

parameterDef[ outer ] locals[ art, annos = [] ]
@after { this.attachLocation($art); }
  :
    annotationAssignment_ll1[ $annos ]*
    inMode=IN?
    name=ident
    { $art = this.addDef( $outer, 'params', 'param', $name.id, $annos,
                          { mode: this.tokenLocation( $inMode, undefined, 'in' ) } ); }
    annotationAssignment_fix[ $annos ]*
    typeSpec[ $art, $annos ]
    ( DEFAULT expr=expression { $art.default = $expr.expr; } )?
  ;

nullability[ art ]
  :
    not=NOT n1=NULL
    { $art.notNull = this.tokenLocation($not,$n1,true); }
  |
    n2=NULL
    { $art.notNull = this.tokenLocation($n2,undefined,false); }
  ;

elementProperties[ elem ]
@after{ /* #ATN 1 */ }
  :
    nullability[$elem]
    (
      DEFAULT expr=expression
      { $elem.default = $expr.expr; }
    )?
  |
    (
      DEFAULT expr=expression
      { $elem.default = $expr.expr; }
    )
    nullability[$elem]?
  |
    gen=GENERATED
    { this.notYet('Generated fields', $gen, ['hanaFlavor']); }
    (
      ALWAYS AS
      // #ATN: expression can start with IDENTITY
      ( IDENTITY sequenceOptions[$elem]?
      | expression
      )
    |
      BY DEFAULT AS IDENTITY sequenceOptions[$elem]?
    )
  |
    ( as=AS | eq='=' ) { this.notYet('Calculated fields', $as || $eq, ['hanaFlavor']); } expression
  ;

sequenceOptions[ elem ] locals[ opts = {} ]
@after { $elem.sequenceOptions = this.attachLocation($opts); }
  :
    '('
    (
      tok=START swith=WITH swNum=value
      { this.setOnce( $opts, 'startWith', $swNum.val, $tok, $swith ); }
    |
      inc=INCREMENT by=BY ibNum=value
      { this.setOnce( $opts, 'incrementBy', $ibNum.val, $inc, $by ); }
    |
      min=MINVALUE minNum=value
      { this.setOnce( $opts, 'minvalue', $minNum.val, $min ); }
    |
      max=MAXVALUE maxNum=value
      { this.setOnce( $opts, 'maxvalue', $maxNum.val, $max ); }
    |
      cache=CACHE cacheNum=value
      { this.setOnce( $opts, 'cache', $cacheNum.val, $cache ); }
    |
      cycle=CYCLE
      { this.setOnce( $opts, 'cycle', true, $cycle ); }
    |
      no=NO
      ( nmin=MINVALUE { this.setOnce( $opts, 'minvalue', false, $no, $nmin ); }
      | nmax=MAXVALUE { this.setOnce( $opts, 'maxvalue', false, $no, $nmax ); }
      | ncache=CACHE { this.setOnce( $opts, 'cache', false, $no, $ncache ); }
      | ncycle=CYCLE { this.setOnce( $opts, 'cycle', false, $no, $ncycle ); }
      )
    )*
    (
      // Not the best idea to allow RESET BY query (without parens) also before
      // the other sequence options... now also done in HANA CDS
      reset=RESET rby=BY queryExpression//[ $opts, 'resetBy' ]
    )?
    ')'
  ;

// View definitions ----------------------------------------------------------

viewDef[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    v=VIEW simplePath[ $name ]
    { $art = this.addDef( $outer, 'artifacts', 'view', $name, $annos, {}, $loc ); }
    annotationAssignment_fix[ $annos ]*
    (
      { this.notYet('View Parameters', $v, ['hanaFlavor', 'betaMode']); }
      WITH PARAMETERS
      parameterDef[ $art ] ( ',' parameterDef[ $art ] )*
    )?
    AS qe=queryExpression { $art.query = $qe.query; } // beta-mode test now in definer
    // TODO check ANTLR: bad msg with 'view V as'<eof> but 'view V as FOO' is fine
    ( wspc=WITH STRUCTURED PRIVILEGE CHECK
      { this.notYet('WITH STRUCTURED PRIVILEGE CHECK', $wspc, ['hanaFlavor']); }
    )?
    ';'
  ;

// Currently, EXTEND is not reserved
//   extend view V { @SomeAnno extend item; }
// Possibility 1: extend existing select item `item` with anno
// Possibility 2: define new select item `item` selecting path `extend`
// Solution: reserve EXTEND (at least at that place)

// if we say that <kind> is optional after EXTEND, what is
//   extend V { element item: Integer; }
// Possibility 1: V is type/entity -> new element `item`
// Possibility 2: V is view -> new select item `item` selecting path `element`
// Solution 1: VIEW is not optional for EXTEND VIEW
// Solution 2: reserve ELEMENT
// Solution 3: drop (optional) ELEMENT from syntax
// Solution 4: resolve ambuity by special rule, e.g. is element def

extendView[ outer, loc, annos ] locals [o = {}]
  :
    v=VIEW simplePathTmp
    { this.notYet('Views', $v, ['hanaFlavor']); }
    ( WITH? '{'
      selectItemDef[$o] ( ',' selectItemDef[$o] )*
      '}'
    )?
    ';'
  ;

// Entity sections -----------------------------------------------------------

seriesDef
@after{ /* #ATN 2 */ }
  :
    s=SERIES '('
    { this.notYet('Series', $s, ['hanaFlavor']); var matchWildcard = this.matchWildcard.bind(this); }
    // #ATN: temporary use of wildcard - might match ')}' after SERIES!  Remove soon!
    .*?
    ')'
  ;

// Technical Configuration -----------------------------------------------------------

/*
TODO: If TCs for other DBMS than HANA shall be supported, split into sub rules
 */
technicalConfiguration[ outer ] locals [ tc = {} ]
  :
    t=TECHNICAL? backend=HANA? CONFIGURATION
    {
      this.notYet( 'Technical configuration', $t, ['hanaFlavor', 'betaMode'] );

      if ($backend.text)
        $tc.backend = this.tokenLocation($backend, undefined, $backend.text.toLowerCase() );
      else
        $tc.backend = { val: 'hana', calculated: true };
      $outer.technicalConfig = $tc;
    }
    '{'
    (
      migration[ $tc ]
    | storeType[ $tc ]
    | usingExtendedStorage[ $tc ]
    | index[ $tc, this.startLocation() ]
    | fullTextIndex[ $tc, this.startLocation() ]
    | fuzzyIndex[ $tc, this.startLocation() ]
    | partition[ $tc, this.startLocation() ]
    | tableGroup[ $tc ]
    | unloadPriority[ $tc ]
    | autoMerge[ $tc ]
    )*
    '}'
  ;

migration[ tc ]
  :
    mi=MIGRATION ed=(ENABLED|DISABLED)
    { this.setOnce( $tc, 'migration', this.tokenLocation( $ed, undefined, $ed.text.toLowerCase()), $mi ); }
    ';'
  ;

storeType[ tc ]
  :
    type=(ROW|COLUMN) store=STORE
    { this.setOnce( $tc, 'storeType', this.tokenLocation( $type, undefined, $type.text.toLowerCase() ), $type, $store ); }
    ';'
  ;

usingExtendedStorage[ tc ]
  :
    u=USING e=EXTENDED s=STORAGE ';'
    { this.setOnce( $tc, 'extendedStorage', this.tokenLocation($u, $s, true), $u, $e, $s ); }
  ;

index[ tc, loc ] locals [ idx, props = { columns: [] }, name = {}, annos = [] ]
@after { this.attachLocation($idx); }
  :
    ( u=UNIQUE { $props.unique = this.tokenLocation($u, undefined, true); } )?
    /*
    (   'BTREE'   { index->type = QPC_INDEX_BTREE; }
      | 'CPBTREE' { index->type = QPC_INDEX_CPBTREE; }
    )?
    */
    INDEX idxName=ident ON '(' simplePath[ $name ]
    ( o1=ascDesc { $name.sort = $o1.order; } )?
    { $props.columns.push($name); }
    (
      ',' { $name = {}; }
      simplePath[ $name ]
      ( on=ascDesc { $name.sort = $on.order; } )?
      { $props.columns.push($name); }
    )*
    ')'
    ( og=ascDesc { $props.sort = $og.order } )?
    ';'
    { $idx = this.addDef( $tc, 'indexes', 'index',
                          $idxName.id, $annos,
                          $props, $loc );
      delete $idx.annotationAssignments;
    }
  ;

ascDesc returns [ order ]
  :
    ad=(ASC|DESC)
    { $order = this.tokenLocation( $ad, undefined, $ad.text.toLowerCase() ); }
  ;

fullTextIndex[ tc, loc ] locals [ fti, props = { columns: [] }, name = {} ]
@after { this.attachLocation($fti); }
  :
    FULLTEXT INDEX ftiName=ident ON '(' simplePath[ $name ] ')'
    { $props.columns.push($name);
      $fti = this.addDef( $tc, 'indexes', 'fulltextindex',
                          $ftiName.id, false,
                          $props, $loc );
    }
    fulltextIndexParameters[ $fti ]* ';'
  ;

fulltextIndexParameters[ fti ] locals [ name = {}, val ]
  :
    l=LANGUAGE
    { if (!$fti.language) $fti.language = {}; }
    (
      c=COLUMN simplePath[ $name ]
      { this.setOnce( $fti.language, 'column', $name, $l, $c ); }
    | d=DETECTION
      { this.setOnce( $fti.language, 'detection',[], $l, $d ); }
      '(' s1=String
      { $fti.language.detection.push( this.quotedLiteral( $s1, 'string' ) ); }
      ( ',' sn=String
        { $fti.language.detection.push( this.quotedLiteral( $sn, 'string' ) ); }
      )*
      ')'
    )
  | m=MIME t=TYPE
    ( c=COLUMN simplePath[ $name ]
      { this.setOnce( $fti, 'mimeTypeColumn', $name, $m, $t, $c ); }
    | str=String
      { this.setOnce( $fti, 'mimeType', this.quotedLiteral( $str, 'string' ), $m, $t ); }
    )
  | f=FUZZY s=SEARCH i=INDEX sw=onOff
    { this.setOnce( $fti, 'fuzzySearchIndex', $sw.val, $f, $s, $i ); }
  | p=PHRASE i=INDEX r=RATIO tok=Number
    { this.setOnce( $fti, 'phraseIndexRatio', this.numberLiteral($tok), $p, $i, $r ); }
  | c=CONFIGURATION str=String
    { this.setOnce( $fti, 'configuration', this.quotedLiteral($str, 'string'), $c ); }
  | s=SEARCH o=ONLY sw=onOff
    { this.setOnce( $fti, 'searchOnly', $sw.val, $s, $o ); }
  | f=FAST p=PREPROCESS sw=onOff
    { this.setOnce( $fti, 'fastPreprocess', $sw.val, $f, $p ); }
  | t=TOKEN s=SEPARATORS str=String
    { this.setOnce( $fti, 'tokenSeparators', this.quotedLiteral( $str, 'string' ), $t, $s ); }
  | t=TEXT
    (
      a=ANALYSIS sw=onOff
      { this.setOnce( $fti, 'textAnalysis', $sw.val, $t, $a ); }
    |
      m=MINING
      { if (!$fti.textMining) $fti.textMining = {}; }
      ( sw=onOff
        { this.setOnce( $fti.textMining, 'state', $sw.val, $t, $m ); }
      | c=CONFIGURATION o=OVERLAY? s=String
        { if (!$o)
          this.setOnce( $fti.textMining, 'config', this.quotedLiteral( $s, 'string' ), $t, $m, $c );
          else
            this.setOnce( $fti.textMining, 'overlay', this.quotedLiteral( $s, 'string' ), $t, $m, $c, $o );
      }
      )
    )
  | fullTextChangeTracking[ $fti ]
  ;

onOff returns [ val ]
  :
    tok=(ON|OFF)
    { $val = this.tokenLocation( $tok, undefined, $tok.text.toLowerCase() ); }
  ;

fullTextChangeTracking[ fti ] locals [ ct = {} ]
  :
    tok=(SYNC|SYNCHRONOUS)
    {
      // copy token and rewrite text for setOnce()
      $ct = Object.assign({}, $tok);
      $ct.text = 'change tracking';
      this.setOnce( $fti, 'changeTracking',
                    { mode: this.tokenLocation( $tok, undefined, $tok.text.toLowerCase() ) }, $ct );
    }
  | tok=(ASYNC|ASYNCHRONOUS)
    {
      $ct = Object.assign({}, $tok);
      $ct.text = 'change tracking';
      this.setOnce( $fti, 'changeTracking',
                   { mode: this.tokenLocation( $tok, undefined, $tok.text.toLowerCase() ) }, $ct);
    }
    (
      spec=asyncSpec
      { $fti.changeTracking.asyncSpec = $spec.val; }
    )?
  ;

asyncSpec returns [ val ]
@init { $val = {}; }
  :
    FLUSH
    ( tok=QUEUE
      { $val.queue = this.tokenLocation( $tok, undefined, $tok.text.toLowerCase() ); }
    )?
    (
      EVERY min=Number MINUTES (OR AFTER doc=Number DOCUMENTS)?
      { $val.minutes = this.numberLiteral($min);
        $val.documents = this.numberLiteral($doc);
      }
    | AFTER doc=Number DOCUMENTS
      { $val.documents = this.numberLiteral($doc); }
    )
  ;

fuzzyIndex[ tc, loc ] locals [ idx, name = {} ]
@init { if(!$tc.fzindexes)
  $tc.fzindexes = [];
}
@after { this.attachLocation($idx);
         $tc.fzindexes.push($idx);
}
  :
    FUZZY SEARCH INDEX ON '(' simplePath[ $name ] ')'
    { $idx = { columns: [ $name ], location: $loc };  }
    ( f=FUZZY SEARCH m=MODE
      { $idx.fuzzy = this.tokenLocation($f, $m, true); }
      (s=String
        { $idx.fuzzy.mode = this.quotedLiteral($s, 'string'); }
      )?
    )?
    ';'
  ;

partition[ tc ]
  :
    p=PARTITION b=BY
    { this.setOnce( $tc, 'partition', { specs: [] }, $p, $b ); }
    (
      k=KEEPING e=EXISTING l=LAYOUT
      { $tc.partition.specs.push({ scheme: this.tokenLocation( $k, $l, 'keeping existing layout' ) }); }
    | ps1=partitionSpec
      { $tc.partition.specs.push($ps1.spec);
      }
      ( ',' psn=partitionSpec
        { $tc.partition.specs.push($psn.spec); }
      )?
    )
    ( WITH PARTITIONING ON ANY COLUMNS sw=onOff
      { $tc.partition.wpoac = $sw.val; }
    )?
    ';'
  ;

partitionSpec returns [ spec ]
@init { $spec = {} }
  :
    roundRobinPartition[ $spec ]
  | hashPartition[ $spec ]
  | rangePartition[ $spec ]
  ;


roundRobinPartition [ spec ]
  :
    s=ROUNDROBIN p=PARTITIONS np=numberPartitions
    { $spec.scheme = this.tokenLocation( $s, undefined, $s.text.toLowerCase());
      $spec.partitions = $np.val;
    }
  ;

hashPartition [ spec ]
  :
    s=HASH '(' cols=partitionColumns ')' p=PARTITIONS np=numberPartitions
    { $spec.scheme = this.tokenLocation( $s, undefined, $s.text.toLowerCase());
      $spec.columns = $cols.val;
      $spec.partitions = $np.val;
    }
  ;

partitionColumns returns [ val ]
@init { $val = []; }
  :
    p1=partitionColumn
    { $val.push($p1.val); }
    ( ',' pn=partitionColumn
      { $val.push($pn.val); }
    )*
  ;

partitionColumn returns [ val ]
@init { $val = {} }
@after{ /* #ATN 1 */ }
  :
    // ATN: the path can start with identifier YEAR or MONTH
    simplePath[ $val ]
  | mod=(YEAR|MONTH) '(' simplePath[ $val ] ')'
    { $val.unit = this.tokenLocation( $mod, undefined, $mod.text.toLowerCase() ); }
  ;


rangePartition [ spec ]
  :
    s=RANGE '(' expr=partitionColumns ')'
    { $spec.scheme = this.tokenLocation( $s, undefined, $s.text.toLowerCase() );
      $spec.columns = $expr.val;
      $spec.ranges = [];
    }
    '('
    ( partitionRanges[ $spec.ranges, 'default' ]
    | storePartitionRanges[ $spec ]
    )
    ')'
  ;

storePartitionRanges[ spec ]
  :
    storePartitionSpec[ $spec ] storePartitionSpec[ $spec ]*
  ;

storePartitionSpec[ spec ]
@init { $spec.withStorageSpec = true; }
  :
    USING tok=(DEFAULT|EXTENDED)
    STORAGE '(' partitionRanges[ $spec.ranges, $tok.text.toLowerCase() ] ')'
  ;

partitionRanges [ ranges, store ]
  :
    r1=rangeSpec
    { $r1.val.store = $store;
      $ranges.push( $r1.val);
    }
    ( ',' rn=rangeSpec
      { $rn.val.store = $store;
        $ranges.push($rn.val);
      }
    )*
  ;

rangeSpec returns [ val = {} ]
@after { this.attachLocation($val); }
  :
    p=PARTITION
    (
      min=rangeValue '<=' VALUES '<' max=rangeValue
      { $val.min = $min.val; $val.max = $max.val; }
    |
      (VALUE | VALUES) '=' min=rangeValue
      { $val.min = $min.val; }
      (
        IS CURRENT
        { $val.isCurrent = true; }
      )?
    | tok=OTHERS
      { $val.others = this.tokenLocation($p, $tok, $tok.text.toLowerCase()); }
    )
  ;

rangeValue returns [ val ]
  :
  | n=Number  { $val = this.numberLiteral($n); }
  | s=String  { $val = this.quotedLiteral($s, 'string'); }
  | b=Boolean { $val = { literal: 'boolean', val: $b.text.toLowerCase() != 'false' }; }
  ;

numberPartitions returns [ val ]
  :
    n=Number { $val = this.numberLiteral($n); }
  | g=GETNUMSERVERS '(' cb=')' { $val = this.tokenLocation($g, $cb, 'get_num_servers()'); }
  ;

tableGroup[ tc ]
  :
    tableGroupSpec[ $tc ]+ ';'
  ;

tableGroupSpec[ tc ]
  :
    g=GROUP
    {
      if(!$tc.group)
        $tc.group = {};
    }
    (
      n=NAME id=ident
      { this.setOnce( $tc.group, 'name', $id.id, $g, $n ); }
    | t=TYPE id=ident
      { this.setOnce( $tc.group, 'type', $id.id, $g, $t ); }
    | s=SUBTYPE id=ident
      { this.setOnce( $tc.group, 'subType', $id.id, $g, $s ); }
    )
  ;

unloadPriority[ tc ]
  :
    u=UNLOAD p=PRIORITY num=Number ';'
    {
      this.setOnce( $tc, 'unloadPrio', this.numberLiteral($num), $u, $p );
    }

  ;

autoMerge[ tc ] locals [ val ]
  :
    no=NO? a=AUTO m=MERGE ';'
    { if ($no.text)
      $val = this.tokenLocation($no, undefined, false);
      else
        $val = this.tokenLocation($a, undefined, true);
      this.setOnce( $tc, 'autoMerge', $val, $a, $m);
    }
  ;

// DCL constructs ------------------------------------------------------------

accesspolicyDef[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    ap=ACCESSPOLICY simplePath[ $name ]
    { this.notYet('DCL', $ap, ['hanaFlavor']); $art = this.addDef( $outer, 'artifacts', 'accesspolicy', $name, $annos, {}, $loc ); }
    '{'
    dclArtifactDef[ $art ]*
    '}' ';'?
  ;

dclArtifactDef[ outer ] locals[ annos = [] ] // cannot use `parent` as parameter name!
  :
    annotationAssignment_ll1[ $annos ]*
    DEFINE?
    ( dclRoleDef[ $outer, this.startLocation(), $annos ]
    | dclAspectDef[ $outer, this.startLocation(), $annos ]
    )
  ;

dclRoleDef[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    ROLE simplePath[ $name ]
    { $art = this.addDef( $outer, 'artifacts', 'role', $name, $annos, {}, $loc ); }
    '{'
    (
      dclGrant[ $art ]
    |
      def=DEFINE?
      dclAspectDef[ $outer, $def && this.startLocation($def), [] ]
    )+
    '}' ';'?
  ;

dclAspectDef[ outer, loc, annos ] locals[ art, name = {} ]
@after{ this.attachLocation($art); }
  :
    ASPECT simplePath[ $name ]
    { $art = this.addDef( $outer, 'artifacts', 'aspect', $name, $annos, {}, $loc ); }
    AS
    queryTerm //[ $art, 'query' ] // check: only SELECT, no '(' queryExpression ')'
    ';'
  ;

dclGrant[ outer ]
  :
    GRANT
    (
      SELECT ON queryPath
    |
      // not an ideal language syntax to avoid ambiguities
      queryPath
    )
    ( WHERE condition )?
    ';'
  ;

// Type references -----------------------------------------------------------

includeRef[ art ] locals[ incl = {} ]
  :
    simplePath[ $incl, true ]
    { if ($art.includes) $art.includes.push($incl); else $art.includes = [$incl]; }
  ;

typeSpec[ art, annos ]
@after{ /* #ATN 1 */ }
  :
    typeStruct[ $art ]
  |
    ':'
    // #ATN: typeSimple can start with ARRAY or TYPE
    ( typeStruct[ $art ]
    | typeArray[ $art, $annos ]
    | typeTypeOf[ $art ]
    | typeSimple[ $art, $annos ]
    )
  ;

returnTypeSpec[ art, annos ]    // probably just use typeSpecSemi
@after{ /* #ATN 1 */ }
  :
    RETURNS
    // #ATN: typeSimple can start with ARRAY or TYPE
    ( typeStruct[ $art ]
    | typeArray[ $art, $annos ]
    | typeTypeOf[ $art ]
    | typeSimple[ $art, $annos ]
    )
  ;


typeSpecSemi[ art, annos ]
@after{ /* #ATN 2 */ }
  :
    typeStruct[ $art ] ';'?
  |
    ':'
    // #ATN: typeSimpleSemi can start with ARRAY or ASSOCIATION or TYPE or LOCALIZED
    ( typeStruct[ $art ] ';'?
    | typeAssociationBase[ $art ]
      // #ATN: path could start with MANY or ONE - make sure a token follows in same rule!
      ( typeToMany[ $art ] | typeToOne[ $art ] | simplePath[ $art.target, true ] )
      typeAssociationCont[ $art ]
      ';'
    | typeArraySemi[ $art, $annos ]
    | typeTypeOf[ $art ] annotationAssignment_ll1[ $annos ]* ';'
    | l=LOCALIZED { $art.localized = this.tokenLocation( $l, undefined, true ); }
      typeSimpleSemi[ $art, $annos ]
    | typeSimpleSemi[ $art, $annos ]
    )
  ;

typeStruct[ art ]
  :
    { $art.elements = Object.create(null); } // we allow empty structures
    '{' elementDef[ $art ]* '}'
  ;

typeArraySemi[ art, annos ]
@init { $art.items = { location: this.startLocation() }; }
@after { /* #ATN 1 */ this.attachLocation($art.items); }
  :
    ARRAY OF
    // #ATN: typeRef can start with TYPE
    ( typeStruct[ $art.items ] ';'?
    | typeTypeOf[ $art.items ] annotationAssignment_ll1[ $annos ]* ';'
    | typeRef[ $art.items ]
      // TODO: should we allow LOCALIZED here?
      annotationAssignment_ll1[ $annos ]*
      (
        ENUM '{' enumSymbolDef[ $art.items ]+ '}'
        ';'?
      |
        ';'
      )
    )
  ;

typeArray[ art, annos ]
@init { $art.items = { location: this.startLocation() }; }
@after { /* #ATN 1 */ this.attachLocation($art.items); }
  :
    ARRAY OF
    // #ATN: typeSimple can start with TYPE
    ( typeStruct[ $art.items ]
    | typeTypeOf[ $art.items ]
    | typeSimple[ $art.items, $annos ]
    )
  ;

typeSimple[ art, annos ]
@after{ /* #ATN 2 */ }
  :
    typeRef[ $art ]
    // #ATN (loop: 2x) and real grammar ambiguity (no AST ambiguity):
    // annotation assignments after `typeSimple`, e.g. `elementDefInner`
    annotationAssignment_ll1[ $annos ]*
    ( ENUM '{' enumSymbolDef[ $art ]+ '}' )?
    // Using enumSymbolDef+? does not help to make loop stop at simple '}'.  It
    // gets even worse: the interpreter is called in the generated code
  ;

typeSimpleSemi[ art, annos ]    // well, not that simple...
  :
    { $art.type = {}; }
    simplePath[ $art.type, true ]
    (
      '('
      head=Number
      { $art.typeArguments = [ this.numberLiteral( $head ) ]; }
      ( ','
        tail=Number
        { $art.typeArguments.push( this.numberLiteral( $tail ) ); }
      )*
      ')'
      annotationAssignment_ll1[ $annos ]*
      ( ENUM '{' enumSymbolDef[ $art ]+ '}' ';'? | ';' )
    |
      annotationAssignment_ll1[ $annos ]*
      ( ENUM '{' enumSymbolDef[ $art ]+ '}' ';'? | ';' )
    |
      // TODO: complain if used in anno def?
      { $art.includes = [ $art.type ]; delete $art.type; }
      ( ',' includeRef[ $art ] )*
      typeStruct[ $art ] ';'?
    )
  ;

typeAssociationBase[ art ]          // including Composition
  :
    (
      assoc=ASSOCIATION cardinality[$art]? TO
      {{
        let location = this.tokenLocation($assoc);
        $art.type = { path: [{ id: 'cds.Association', location }], scope: 'global', location };
      }}
    |
      compo=COMPOSITION cardinality[$art]? OF
      {{
        let location = this.tokenLocation($compo);
        $art.type = { path: [{ id: 'cds.Composition', location }], scope: 'global', location };
      }}
    )
    { $art.target = {}; }
  ;

typeAssociationCont[ art ]
  :
    (
      '{'
      foreignKey[ $art ] ( ',' foreignKey[ $art ] )*
      '}'
    |
      ON cond=condition
      // FIXME: 'art.onCond' is what we actually want, but for now, we also take the plain text of the whole condition (including whitespace) into 'art.on'
      { $art.onCond=$cond.cond; $art.on = this._ctx.parser._input.tokenSource._input.strdata.substring($cond.start.start, $cond.stop.stop + 1); }
    )?
  ;

typeAssociationContNullability[ art ] // including Composition
// optional NULL / NOT NULL for managed association only
  :
    (
      '{'
      foreignKey[ $art ] ( ',' foreignKey[ $art ] )*
      '}'
      nullability[ $art ]?
    |
      ON cond=condition
      // FIXME: 'art.onCond' is what we actually want, but for now, we also take the plain text of the whole condition (including whitespace) into 'art.on'
      { $art.onCond=$cond.cond; $art.on = this._ctx.parser._input.tokenSource._input.strdata.substring($cond.start.start, $cond.stop.stop + 1); }
    |
      nullability[ $art ]
    )?
  ;

typeToOne[ art ]
  :
    one=ONE
    { $art.cardinality = { targetMin: this.numberLiteral( $one, null, '0' ),
                           targetMax: this.numberLiteral( $one, null, '1' ),
                           location: this.tokenLocation($one) }; }
    // TODO: complain about cardinality if alread provided
    simplePath[ $art.target, true ]
  ;

typeToMany[ art ]
  :
    many=MANY
    { $art.cardinality = { targetMin: this.numberLiteral( $many, null, '0' ),
                           targetMax: { literal: 'string', val: '*',
                                        location: this.tokenLocation($many) },
                           location: this.tokenLocation($many) }; }
    // TODO: complain about cardinality if alread provided
    simplePath[ $art.target, true ]
  ;

cardinality[ art ] locals[ card = {} ]
@after { /* #ATN 2 */ $art.cardinality = this.attachLocation($card); }
  :
    lbrack='['
    { $card.targetMax = { literal: 'string', val: '*',
                          location: this.tokenLocation($lbrack) }; }
    (
      // #ATN: simple lookahead behind Number
      (
        srcMax=Number  ','
        { $card.sourceMax = this.numberLiteral( $srcMax ); }
      |
        srcMaxStar='*' ','
        { $card.sourceMax = { literal: 'string', val: '*',
                              location: this.tokenLocation($srcMaxStar) }; }
      )?
      // #ATN: simple lookahead behind Number
      (
        trgMin=Number '..'
        { $card.targetMin = this.numberLiteral( $trgMin ); }
      )?
      (
        trgMax=Number
        { $card.targetMax = this.numberLiteral( $trgMax ); }
      |
        trgMaxStar='*'
        { $card.targetMax = { literal: 'string', val: '*',
                              location: this.tokenLocation($trgMaxStar) }; }
      )
    )?
    ']'
  ;

foreignKey[ outer ] locals[ art = {}, elem = {} ]
@after { this.attachLocation($art); }
  :
    simplePath[ $elem ]
    ( AS name=ident )?
    { $art = this.addDef( $outer, 'foreignKeys', 'key', ($ctx.name) ? $name.id : $elem.path,
                          undefined, { targetElement: $elem } ); }
  ;

typeTypeOf[ art ]
  :
    TYPE OF
    { $art.type = { resolveSemantics: 'typeOf' }; }
    simplePath[ $art.type ]
  ;

typeRef[ art ]
@init { $art.type = {}; }
  :
    simplePath[ $art.type, true ]
    ( '('
      head=Number
      { $art.typeArguments = [ this.numberLiteral( $head ) ]; }
      ( ','
        tail=Number
        { $art.typeArguments.push( this.numberLiteral( $tail ) ); }
      )*
      ')'
    )?
  ;

// Queries -------------------------------------------------------------------

queryExpression returns[ query ] locals[ op ] // QLSubqueryComplex, SubqueryComplex
@after{ this.attachLocation($query); }
  :
    qt1=queryTerm { $query = $qt1.query; }
    (
      ( un=UNION { $op = this.tokenLocation($un, undefined, 'union'); } ( DISTINCT | ALL { $op = this.tokenLocation($un, undefined, 'unionAll'); } )?
      | ex=EXCEPT DISTINCT ?    { $op = this.tokenLocation($ex, undefined, 'except'); }
      | mi=MINUS DISTINCT ?     { $op = this.tokenLocation($mi, undefined, 'except'); } // TODO: change to 'minus'
      )
      qt=queryTerm
      {
        $query = {
          op: $op, args: [$query, $qt.query],
          location: this.combinedLocation( $query, $qt.query) };
      }
    )*
    ( ob=ORDER BY
      {
        if ($query instanceof Array) // use 'subquery' as no-op operator
          $query = { op: this.tokenLocation( $ob, undefined, 'subquery' ), args: [$query], location: $query.location };
      }
      // TODO: create extra "nop" operator
      ob1=orderBySpec { $query.orderBy = [ $ob1.ob ]; }
      ( ',' obn=orderBySpec  { $query.orderBy.push( $obn.ob ); } )*
    )?
    ( limkw=LIMIT
      {
        if ($query instanceof Array) // use 'subquery' as no-op operator
          $query = { op: this.tokenLocation( $limkw, undefined, 'subquery' ), args: [$query], location: $query.location };
      }
      ( lim=Number   { $query.limit = this.numberLiteral( $lim ); }
      | limnull=NULL { $query.limit = { literal: 'null', val: null, location: this.tokenLocation($limnull) }; }
      )
      ( OFFSET off=Number { $query.offset = this.numberLiteral( $off ); } )? // unsigned integer
    )?
  ;

orderBySpec returns[ ob ]
  :
    e=expression { $ob = { value: $e.expr }; }
    ( asc=ASC   { $ob.sort = this.tokenLocation( $asc, undefined, 'asc' ); }
    | desc=DESC { $ob.sort = this.tokenLocation( $desc, undefined, 'desc' ); }
    )?
    ( nb=NULLS ne=( FIRST | LAST )
      { $ob.nulls = this.tokenLocation( $nb, $ne, $ne.text ); }
    )?
  ;

queryTerm returns[ query ]
@after{ this.attachLocation($query); }
  :
    qt1=queryPrimary { $query = $qt1.query; }
    (
      intersect=INTERSECT DISTINCT ?
      qt=queryPrimary
      {
        $query = {
          op: this.tokenLocation( $intersect, undefined, 'intersect' ), args: [$query, $qt.query],
          location: this.combinedLocation( $query, $qt.query) };
      }
    )*
  ;

queryPrimary returns[ query ]
@after { this.attachLocation($query); }
  :
    '(' qe=queryExpression ')'
    { $query = [$qe.query]; }
  |
    select=SELECT FROM
    t1=tableExpression
    { $query = { op: this.tokenLocation( $select, undefined, 'query' ), from: [$t1.query], location: this.startLocation() }; }
    (
      ',' tn=tableExpression { $query.from.push( $tn.query ); }
    )*
    (
      mixin=MIXIN '{'
      mixinElementDef[ $query ]*
      '}' INTO
    )?
    ( top=TOP Number { this.notYet('TOP', $top, ['hanaFlavor']); } )?

    ( ad=( ALL | DISTINCT )
      { $query.quantifier = this.tokenLocation( $ad, undefined, $ad.text.toLowerCase() ); }
    )?
    '{'
    ( star='*'
      {
        $query.all = this.tokenLocation( $star, undefined, true );
        $query.elements = Object.create(null); // see comment in `initQueryExpression`
      }
    |
      selectItemDef[ $query ]
    )
    ( ',' selectItemDef[ $query ] )*
    '}'
    (
      // syntax is less than ideal - EXCLUDING is only useful for `*` - with
      // this syntax, people wonder what happens with explicit select items
      EXCLUDING
      '{'
      projectionExclusion[ $query ]
      ( ',' projectionExclusion[ $query ] )*
      '}'
    )?
    ( WHERE cond=condition { $query.where = $cond.cond; } )?
    (
      GROUP BY
      e1=expression { $query.groupBy = [ $e1.expr ]; }
      ( ',' en=expression { $query.groupBy.push( $en.expr ); } )*
    )?
    ( HAVING having=condition { $query.having = $having.cond; } )?
  ;

tableExpression returns[ query ] locals[ join ] // TableOrJoin
  :
    qt=tableTerm { $query = $qt.query; }
    (
      ( JOIN              { $join = 'inner'; }
      | INNER JOIN        { $join = 'inner'; }
      | LEFT OUTER? JOIN  { $join = 'leftOuter'; } // left
      | RIGHT OUTER? JOIN { $join = 'rightOuter'; } // right
      | FULL OUTER? JOIN  { $join = 'fullOuter'; }  // full
      )
      te=tableExpression
      { $query = { op: this.tokenLocation( $query, undefined, 'join' ), join: $join, args: [$query, $te.query] }; }
      ON cond=condition
      {
        $query.on = $cond.cond;
        $query.location = this.combinedLocation( $query.args[0], $cond.cond );
      }
    |
      crj=CROSS JOIN tt=tableTerm
      {
        $query = {              // "," -> mit $ syntax:","
          op: this.tokenLocation( $crj, undefined, 'join' ), join: 'cross', args: [$query, $tt.query],
          location: this.combinedLocation( $query, $tt.query) };
      }
    )*
  ;

tableTerm returns [ query ]
@after{ /* #ATN 1 */ this.attachLocation($query); }
  :
    qp=fromPath { $query = $qp.qp; } // TODO: probably copy rule
    ( AS n1=ident { $query.name = $n1.id }
    | n2=identNoKeyword { $query.name = $n2.id }
    )?
  |
    '('
    // #ATN: The following alternative is not LL1, because both can start with
    // left-paren, but queryExpression has SELECT after initial left-parens
    (
      qe=queryExpression
      {
        $query = $qe.query;     // might be in array if in parens
        if ($query instanceof Array) // use 'subquery' as no-op operator
          $query = { op: this.tokenLocation( $query, undefined, 'subquery' ), args: [$query], location: $query.location };
      }
      ')'
      ( AS a1=ident { $query.name = $a1.id } // for defining table aliass
      | a2=identNoKeyword { $query.name = $a2.id }
      )?                        // TODO: really optional?
    |
      te=tableExpression { $query = [ $te.query ]; }
      ')'
    )
  ;

fromPath returns [ qp = { path: [], scope: 0 } ]
@after{ this.attachLocation($qp); }
  :
    id=ident { if ($id.id) $qp.path.push($id.id); else $qp.path.broken = true; }
    ( fromArguments[ $id.id ] cardinalityAndFilter[ $id.id ]?
    | cardinalityAndFilter[ $id.id ]
    )?
    (
      '.' id=ident { if ($id.id) $qp.path.push($id.id); else $qp.path.broken = true; }
      ( fromArguments[ $id.id ] cardinalityAndFilter[ $id.id ]?
      | cardinalityAndFilter[ $id.id ]
      )?
    )*
  ;

// Conditions and expressions ------------------------------------------------

// With "separate" `condition` and `expression` rules, we have long LL
// ambiguities (not so with LALR used in Bison) with initial left parentheses:
//   ( ( ( a.b.c + d.e.f
//       )     // now we know: 3rd left-paren for expression
//       =     // now we know: 1st and 2nd left-paren for condition
//       3 ) ) )
//
// To avoid expensive parsing, we "combine" both rules, i.e. inside '('…')' of
// rule `expressionTerm`, we recursively refer to `condition`, not
// `expression`.  With that, the existence of relations/predicates in rule
// `conditionTerm` must be optional.  Correct conditions and expressions must
// be then ensured by code (either in actions of the grammar or in a check
// phase - to be discussed).
//
// ANTLR4s left-recursion feature cannot be used as we will have rule
// arguments.

condition returns [ cond ] locals [ args = [], orl = [] ]
@after{
  $cond = ($args.length == 1)
    ? $args[0]
    : this.attachLocation({ op: $orl[0], args: $args });
}
  :
    c1=conditionAnd { $args.push($c1.cond); }
    ( or=OR c2=conditionAnd { $args.push($c2.cond); $orl.push(this.tokenLocation( $or, undefined, 'or' ))} )*
  ;

conditionAnd returns [ cond ] locals [ args = [], andl = [] ]
@after{
  $cond = ($args.length == 1)
    ? $args[0]
    : this.attachLocation({ op: $andl[0], args: $args });
}
  :
    c1=conditionTerm { $args.push($c1.cond); }
    ( and=AND c2=conditionTerm { $args.push($c2.cond); $andl.push(this.tokenLocation( $and, undefined, 'and' )) } )*
  ;

conditionTerm returns [ cond ]
@after{
  if ($cond) { this.attachLocation($cond); } else { $cond = $expr.expr; }
}
  :
    nt=NOT ct=conditionTerm
    // Remark: if the condition term starts with NULL, this does not work
    // anymore with the token rewrite (not a real issue...)
    { $cond = { op: this.tokenLocation( $nt, undefined, 'not' ), args: [ $ct.cond ] }; }
  |
    ex=EXISTS '(' qe=queryExpression ')'
    { $cond = { op: this.tokenLocation( $ex, undefined, 'exists' ), args: [ $qe.query ] }; }
  |
    expr=expression             // see @after
    (
      rel=( '=' | '<>' | '>'  | '>=' | '<' | '<=' | '!=' )
      { $cond = { op: this.tokenLocation( $rel, undefined, $rel.text), args: [ $expr.expr ] }; }
      ( asa=( ANY | SOME | ALL )
        { $cond.quantifier = this.tokenLocation($asa, undefined, $asa.text.toLowerCase()); }
      )?
      e2=expression { $cond.args.push($e2.expr); }
    |
      IS ( inn=NOT NULL | innu=NULL )
      { $cond = { op: $inn ? this.tokenLocation( $inn, undefined, 'isNotNull' ) : this.tokenLocation( $innu, undefined, 'isNull' ), args: [ $expr.expr ] }; }
    |
      { $cond = { args: [ $expr.expr ] }; }
      NOT predicate[ $cond, true ]
    |
      { $cond = { args: [ $expr.expr ] }; }
      predicate[ $cond, false ]
    )?                          // optional: for conditions in parentheses
  ;

predicate[ cond, negated ]
// As an alternative, we could have a `negated` properties for the operations
// `isNull`(!), `in`, `between` and `like` (or produce the same AST as for
//    NOT (a BETWEEN b AND c)
  :
    ino=IN e1=expression        // including ExpressionList
    { $cond.op = this.tokenLocation( $ino, undefined, (negated) ? 'notIn' : 'in'); $cond.args.push( $e1.expr ); }
  |
    bw=BETWEEN e2=expression
    { $cond.op = this.tokenLocation( $bw, undefined, (negated) ? 'notBetween' : 'between' ); $cond.args.push( $e2.expr ); }
    AND e3=expression { $cond.args.push( $e3.expr ); }
  |
    lk=LIKE e4=expression
    { $cond.op = this.tokenLocation( $lk, undefined, (negated) ? 'notLike' : 'like' ); $cond.args.push( $e4.expr ); }
    ( ESCAPE e5=expression { $cond.args.push( $e5.expr ); } )?
  ;

expression returns [ expr ]
  :
    e1=expressionSum { $expr = $e1.expr; }
    (
      or='||' e2=expressionSum
      {
        $expr = {
          op: this.tokenLocation( $or, undefined, '||' ), args: [$expr, $e2.expr],
          location: this.combinedLocation( $expr, $e2.expr ) };
      }
    )*
  ;

expressionSum returns [ expr ]
  :
    e1=expressionFactor { $expr = $e1.expr; }
    (
      op=( '+' | '-' ) e2=expressionFactor
      {
        $expr = {
          op: this.tokenLocation($op, undefined, $op.text), args: [$expr, $e2.expr],
          location: this.combinedLocation( $expr, $e2.expr ) };
      }
    )*
  ;

expressionFactor returns [ expr ]
  :
    e1=expressionTerm { $expr = $e1.expr; }
    (
      op=( '*' | '/' ) e2=expressionTerm
      {
        $expr = {
          op: this.tokenLocation($op, undefined, $op.text), args: [$expr, $e2.expr],
          location: this.combinedLocation( $expr, $e2.expr ) };
      }
    )*
  ;

expressionTerm returns [ expr ] locals [ op, args = [] ]
@after{ /* #ATN 1 */
  if ($expr) { this.attachLocation($expr); }
  else { $expr = $ctx.path ? $path.qp : $ctx.val && $val.val; }
}
  :
    // unary +-
    unary=( '+' | '-' ) e1=expressionTerm
    { $expr = { op: this.tokenLocation($unary, undefined, $unary.text), args: [ $e1.expr ] }; }
  |
    (
      val=literalValue          // see @after
    |
      sf=specialFunction
      { $expr = $sf.ret; }
    |
      ca=CASE
      { $expr = { op : this.tokenLocation( $ca, undefined, 'case' ), args: [] }; }
      (
        e2=expression { $expr.args.push($e2.expr); }
        ( ow=WHEN ew=expression THEN e3=expression
          { $expr.args.push( this.createPrefixOp( $ow, [ $ew.expr, $e3.expr ] ) ); }
        )+
      |
        ( ow=WHEN c=condition THEN e3=expression
          { $expr.args.push( this.createPrefixOp( $ow, [ $c.cond, $e3.expr ] ) ); }
        )+
      )
      ( el=ELSE e4=expression
        { $expr.args.push( this.createPrefixOp( $el, [ $e4.expr ] ) ); }
      )?
      END
    |
      ne=NEW nqp=queryPath      // token rewrite for NEW
      // please note: there will be no compiler-supported code completion after NEW
      { $expr = { op: this.tokenLocation( $ne, undefined, 'new' ), args: [] };
        this.notYet('NEW in expressions', $ne, ['hanaFlavor']);
      }
    |
      path=queryPath            // see @after
      {
        let path = $path.qp.path;
        if (path[0] && path[0].args) { // TODO: also arrowed args
          $expr = { op: this.tokenLocation( $path.qp, undefined, 'call' ), func: $path.qp, args: path[0].args };
          delete path[0].args;
        }
        if ($expr && path.length > 1 || path.some( s => s && s.args ))
        { this.notYet('Methods in expressions', $ctx.start, ['hanaFlavor']); }
      }
    |
      '('
      // #ATN: The following alternative is not LL1, because both can start with
      // left-paren, but queryExpression has SELECT after initial left-parens
      (
        qe=queryExpression { $expr = $qe.query; }
      |
        c1=condition { $expr = [ $c1.cond ]; }
        ( ',' cn=expression { $expr.push($cn.expr); } )*
      )
      ')'
    )
  ;

specialFunction returns [ ret = { } ] locals[ art = {} ]
@after{ /* #ATN 1 */ }
  :
    tr=TRIM '('
    { this.notYet('TRIM in expressions', $tr, ['hanaFlavor']); $ret.op = this.tokenLocation( $tr, undefined, 'special' ); $ret.args = []; }
    // #ATN: we do not want to reserve these three optional keywords
    (
      ( LEADING | TRAILING | BOTH ) expression ?
      FROM expression
    |
      expression
      ( FROM expression )?
    )
    ')'
  |
    ex=EXTRACT '('
    { this.notYet('EXTRACT in expressions', $ex, ['hanaFlavor']); $ret.op = this.tokenLocation( $ex, undefined, 'special' ); $ret.args = []; }
    ( YEAR | MONTH | DAY | HOUR | MINUTE | SECOND )
    FROM expression
    ')'
  |
    ca=CAST '('
    { this.notYet('CAST in expressions', $ca, ['hanaFlavor']); $ret.op = this.tokenLocation( $ca, undefined, 'special' ); $ret.args = []; }
    expression AS typeRef[ $art ]
    ')'
  ;

// query path includes aggregation:
// ( COUNT | MIN | MAX | SUM | AVG | STDDEV | VAR )
// '(' ( '*' | expression | ALL expression | DISTINCT expression_list ) ')'
// FIXME: Only simple paths are really digested so far, everything else results in a notYet error message
queryPath returns [ qp = { path: [] } ] // QLPath - TODO: rename to valuePath
@init { $qp.location = this.startLocation(); }
@after{ this.attachLocation($qp); }
  :
    ( dc=':' {
      $qp.param = this.tokenLocation($dc,undefined,true);
      this.notYet('Scope operator ":" in expressions', $dc, ['hanaFlavor']);
      }
    )?                         // conflicts with optional anno assignment value
    id=ident { if ($id.id) $qp.path.push($id.id); else $qp.path.broken = true; }
    ( pathArguments[ $id.id ] cardinalityAndFilter[ $id.id ]?
    | cardinalityAndFilter[ $id.id ]
    )?
    (
      '.' id=ident { if ($id.id) $qp.path.push($id.id); else $qp.path.broken = true; }
      ( pathArguments[ $id.id ] cardinalityAndFilter[ $id.id ]?
      | cardinalityAndFilter[ $id.id ]
      )?
    )*
  ;

// TODO: define fromPath (used in FROM and restricted after TYPE OF) because
// introducing A:B paths generally would create ambiguities with named argument
// versus positional argument with path A:B

fromArguments[ pathStep ]
  :
    paren='('
    { this.notYet('View arguments', $paren, ['hanaFlavor','betaMode']); }
    namedExpression[ $pathStep ] ( ',' namedExpression[ $pathStep ] )*
    ')'
  ;

pathArguments[ pathStep ]
@after{ /* #ATN 1 */ }
  :
    paren='('
    // ATN, LL2: Identifier can start both named arguments and the positional.
    // Make sure that we do not introduce A:B paths in expressions!
    (
      { this.notYet('View arguments', $paren, ['hanaFlavor','betaMode']); }
      namedExpression[ $pathStep ] ( ',' namedExpression[ $pathStep ] )*
    |
      { this.notYet('Function arguments with "=>"', $paren, ['hanaFlavor']); $pathStep.args = []; }
      arrowedExpression[ $pathStep ] ( ',' arrowedExpression[ $pathStep ] )*
    |
      e1=expression { $pathStep.args = [ $e1.expr ]; }
      ( ',' e2=expression { $pathStep.args.push( $e2.expr ); } )*
    |
      a=ALL
      { this.notYet('ALL in functions', $a, ['hanaFlavor']); }
      e1=expression { $pathStep.args = [ $e1.expr ]; }
    |
      d=DISTINCT
      { this.notYet('DISTINCT in functions', $d, ['hanaFlavor']);}
      e1=expression { $pathStep.args = [ $e1.expr ]; }
      ( ',' e2=expression { $pathStep.args.push( $e2.expr ); } )*
    |
      star='*'
      { this.notYet('* in functions', $a, ['hanaFlavor']); $pathStep.args = []; }
    |
      { $pathStep.args = []; }
    )
    ')'
  ;

namedExpression[ pathStep ]
  :
    name=ident ':' elem=expression
    { if ($name.id) this.addDef( $pathStep, 'namedArgs', 0, $name.id, true,
                                 ($ctx.elem) ? $elem.expr : { location: $name.id.location } ); }
  ;

arrowedExpression[ pathStep ]
  :
    name=ident a='=>' elem=expression
    { if ($name.id) this.addDef( $pathStep, 'arrowedArgs', 0, $name.id, true,
                                 ($ctx.elem) ? $elem.expr : { location: $name.id.location } ); }
  ;

cardinalityAndFilter[ pathStep ]
@after{ /* #ATN 1 */ }
  :
    '['
    // #ATN: simple lookahead behind Number
    ( trgMax=Number ':'
      { $pathStep.cardinality = { targetMax: this.numberLiteral( $trgMax ) } }
    )?
    co=condition { $pathStep.where = $co.cond; }
    ']'
  ;

selectItemInline locals[ o = {} ]
  :
    cb='{' { this.notYet('Inline select items', $cb, ['hanaFlavor']); }
    selectItemDef[$o] ( ',' selectItemDef[$o] )*
    '}'
  ;

simplePathTmp locals[ art = {} ]
  :
    simplePath[ $art ]
  ;

// Simple paths and values ---------------------------------------------------

value returns[ val ]
@after { this.attachLocation($val); }
  :
    { $val = { literal: 'struct', location: this.startLocation() }; }
    '{'
    namedValue[ $val ]
    // allow ',' at end - TODO, complain if LA(1) == ',' in epsilon-alt
    ( ',' ( namedValue[ $val ] )? )*
    '}'
  |
    { $val = { literal: 'array', location: this.startLocation(), val: [] }; }
    '['
    ( head=arrayValue { $val.val.push( $head.val ); }
      // allow ',' at end - TODO, complain if LA(1) == ',' in epsilon-alt
      ( ',' ( tail=arrayValue { $val.val.push( $tail.val ); } )? )*
    )?
    ']'
  |
    v1=literalValue { $val = $v1.val; }
  |
    ( plus='+' | min='-' ) num=Number
    { $val = this.numberLiteral( $num, $plus||$min ); }
  |
    { $val = {}; }              // TODO: think about expression value representation
    simplePath[ $val ]
  ;

namedValue[ struct ] locals[ namedVal = { name: {} } ]
  :
    simplePath[ $namedVal.name ]
    ( '#' variant=ident { $namedVal.name.variant = $variant.id; } )?
    ( ':' elem=value )?
    { this.addItem( $struct, '_struct', null, true,
                    ($ctx.elem) ? Object.assign($namedVal, $elem.val) : $namedVal ); }
  ;


arrayValue returns[ val ]
@after { this.attachLocation($val); }
  :
    { $val = { literal: 'struct', location: this.startLocation() }; }
    '{'
    namedValueInArray[ $val ]
    // allow ',' at end - TODO, complain if LA(1) == ',' in epsilon-alt
    ( ',' ( namedValueInArray[ $val ] )? )*
    '}'
  |
    { $val = { literal: 'array', location: this.startLocation(), val: [] }; }
    '['
    ( head=arrayValue { $val.val.push( $head.val ); }
      // allow ',' at end - TODO, complain if LA(1) == ',' in epsilon-alt
      ( ',' ( tail=arrayValue { $val.val.push( $tail.val ); } )? )*
    )?
    ']'
  |
    v1=literalValue { $val = $v1.val; }
  |
    ( plus='+' | min='-' ) num=Number
    { $val = this.numberLiteral( $num, $plus||$min ); }
  |
    { $val = {}; }              // TODO: think about expression value representation
    simplePath[ $val ]
  ;

namedValueInArray[ struct ]
  :
    name=ident ( ':' elem=arrayValue )? // $name.id can be null with parse error
    { if ($name.id) this.addDef( $struct, 'struct', null, $name.id, true,
                                 ($ctx.elem) ? $elem.val : { location: $name.id.location } ); }
  ;

literalValue returns[ val ] locals[ $tok ]
@init{ $tok = this.getCurrentToken(); }
@after { this.attachLocation($val); }
  :
    '#' name=ident
    { $val = { literal: 'enum', symbol: $name.id } }
  |
    NULL
    { $val = { literal: 'null', val: null }; }
  |
    Boolean
    { $val = { literal: 'boolean', val: $tok.text.toLowerCase() != 'false' }; }
  |
    Number
    { $val = this.numberLiteral( $tok ); }
  |
    String
    { $val = this.quotedLiteral( $tok, 'string' ); }
  |
    QuotedLiteral               // x'12', date'...', time'...', timestamp'...'
    { $val = this.quotedLiteral( $tok ); }
  ;

simplePath[ art, attachScope = false ] locals[ LeaveLoop = true ]
@after { this.attachLocation($art); }
// Due to error recovery, rule `ident` can return with value `null`.  Set the
// path as broken in this case.
  :
    head=ident
    { $art.path = [ $head.id ];
      if ($attachScope) $art.scope = 0;
      if (!$head.id) $art.path.broken = true;
    }
    (
      '.' tail=ident
      { $art.path.push ( $tail.id ); if (!$tail.id) $art.path.broken = true; }
    )*
  ;


// Identifier and non-reserved keywords --------------------------------------

identNoKeyword returns[ id ]    // for aliases without AS
@after{ $id = this.identAst( $tok ); }
  :
    tok=Identifier
  ;

// The `ident` rule matches `Identifier` and all non-reserved keywords.  List
// all non-reserved keywords directly, do not use an indirection via a rule
// like `nonReservedKeywords`.
ident returns[ id ]
// The following double-";" is a ANTLR4/JavaScript bug workaround:
@after{ $id = this.identAst( $stop );; $stop.isIdentifier = true; }
  :
    Identifier
  | ABSTRACT
  | ACCESSPOLICY
  | ACTION
  | ACTIONS
  | AFTER
  | ALWAYS
  | ANALYSIS
  | AND
  | ANNOTATE
  | ANNOTATION
  | ARRAY
  | ASC
  | ASPECT
  | ASSOCIATION
  | ASYNC
  | ASYNCHRONOUS
  | AUTO
  | BETWEEN
  | BOTH
  | CACHE
  | CHECK
  | COLUMN
  | COLUMNS
  | COMPOSITION
  | CONFIGURATION
  | CONST
  | CONTEXT
  | CURRENT
  | CROSS
  | CYCLE
  | DAY
  | DEFAULT
  | DEFINE
  | DEPENDS
  | DESC
  | DETECTION
  | DISABLED
  | DOCUMENTS
  | ELEMENT
  | ELSE
  | ENABLED
  | END
  | ENTITY
  | ENUM
  | ESCAPE
  | EVERY
  | EXCEPT
  | EXCLUDING
  | EXISTING
  | EXTEND
  | EXTENDED
  | FAST
  | FIRST
  | FLUSH
  | FULL
  | FULLTEXT
  | FUNCTION
  | FUZZY
  | GENERATED
  | GETNUMSERVERS
  | GRANT
  | GROUP
  | HANA
  | HASH
  | HAVING
  | HOUR
  | IDENTITY
  | INCREMENT
  | INDEX
  | INNER
  | INTERSECT
  | INTO
  | IS
  | JOIN
  | KEEPING
  | LANGUAGE
  | LAST
  | LAYOUT
  | LEADING
  | LEFT
  | LIKE
  | LIMIT
  | LOCALIZED
  | MANY
  | MASKED
  | MAXVALUE
  | MERGE
  | MIGRATION
  | MINING
  | MINUS
  | MINUTE
  | MINUTES
  | MINVALUE
  | MIME
  | MIXIN
  | MODE
  | MONTH
  | NAME
  | NAMEPREFIX
  | NAMESPACE
  | NO
  | NULLS
  | OFF
  | OFFSET
  | ONE
  | ONLY
  | OR
  | ORDER
  | OTHERS
  | OUTER
  | OVERLAY
  | QUEUE
  | PACKAGE
  | PARAMETERS
  | PARTITION
  | PARTITIONING
  | PARTITIONS
  | PHRASE
  | PREPROCESS
  | PRIORITY
  | PRIVILEGE
  | PROJECTION
  | RANGE
  | RATIO
  | REDIRECTED
  | RESET
  | RETURNS
  | RIGHT
  | ROLE
  | ROUNDROBIN
  | ROW
  | SEARCH
  | SECOND
  | SEPARATORS
  | SERIES
  | SERVICE
  | START
  | STORAGE
  | STORE
  | STRUCTURED
  | SUBTYPE
  | SYNC
  | SYNCHRONOUS
  | TABLE
  | TECHNICAL
  | TEMPORARY
  | TEXT
  | THEN
  | TOKEN
  | TOP
  | TRAILING
  | UNION
  | UNIQUE
  | UNLOAD
  | TO
  | TYPE
  | USING
  | VALUE
  | VALUES
  | VIEW
  | VIRTUAL
  | WHERE
  | YEAR
  ;

//----------------------------------------------------------------------------

WhiteSpace                      // like \s in JavaScript RegExp
  :                             // LineTerminator | [\t\f\v\u00A0\uFEFF] | Zs
    [\r\n\u2028\u2029 \t\f\u000B\u00A0\u1680\u180e\u2000-\u200A\u202F\u205F\u3000\uFEFF]+
    -> skip ;

Comment : '/*' .*? '*/' -> channel(HIDDEN);

LineComment : '//' ~[\r\n\u2028\u2029]* -> channel(HIDDEN);

// Values --------------------------------------------------------------------

String
  :
    ( '\'' ~[\u0027\n\r\u2028\u2029]* '\'' )+ // \u0027 = '\''
  ;

QuotedLiteral
  :
    ( [xX] | [dD][aA][tT][eE] | [tT][iI][mM][eE] ( [sS][tT][aA][mM][pP] )? )
    ( '\'' ~[\u0027\n\r\u2028\u2029]* '\'' )+ // \u0027 = '\''
  ;

Boolean                         // TMP?
  : [tT][rR][uU][eE] | [fF][aA][lL][sS][eE]
  ;

// Reserved keywords (are case-insensitive): ---------------------------------

ALL : [aA][lL][lL] ;
ANY : [aA][nN][yY] ;
AS : [aA][sS] ;
BY : [bB][yY] ;
CASE : [cC][aA][sS][eE] ;
CAST : [cC][aA][sS][tT] ;
DISTINCT : [dD][iI][sS][tT][iI][nN][cC][tT] ;
EXISTS : [eE][xX][iI][sS][tT][sS] ;
EXTRACT : [eE][xX][tT][rR][aA][cC][tT] ;
// FALSE: see Boolean
FROM : [fF][rR][oO][mM] ;
IN : [iI][nN] ;
KEY : [kK][eE][yY] ;
NEW : [nN][eE][wW] ;            // token rewrite for NEW -> not reserved
NOT : [nN][oO][tT] ;
NULL : [nN][uU][lL][lL] ;
OF : [oO][fF] ;
ON : [oO][nN] ;
SELECT : [sS][eE][lL][eE][cC][tT] ;
SOME : [sS][oO][mM][eE] ;
WHEN : [wW][hH][eE][nN] ;
TRIM : [tT][rR][iI][mM] ;
// TRUE: see Boolean
WITH : [wW][iI][tT][hH] ;

// Fixed Token which is defined DIRECTLY BEFORE the unreserved keywords ------

Number                          // DO NOT RENAME OR MOVE THIS RULE !!!
  : [0-9]+                      // no initial sign
    ( '.' [0-9]+ )?
    ( [eE] ('+'|'-')? [0-9]+ )?
  ;

// Unreserved keywords (are case-insensitive): -------------------------------

ABSTRACT : [aA][bB][sS][tT][rR][aA][cC][tT] ;
ACCESSPOLICY : [aA][cC][cC][eE][sS][sS][pP][oO][lL][iI][cC][yY] ;
ACTION : [aA][cC][tT][iI][oO][nN] ;
ACTIONS : [aA][cC][tT][iI][oO][nN][sS] ;
AFTER : [aA][fF][tT][eE][rR] ;
ALWAYS : [aA][lL][wW][aA][yY][sS] ;
ANALYSIS : [aA][nN][aA][lL][yY][sS][iI][sS] ;
AND : [aA][nN][dD] ;
ANNOTATE : [aA][nN][nN][oO][tT][aA][tT][eE] ;
ANNOTATION : [aA][nN][nN][oO][tT][aA][tT][iI][oO][nN] ;
ARRAY : [aA][rR][rR][aA][yY] ;
ASC : [aA][sS][cC] ;
ASPECT : [aA][sS][pP][eE][cC][tT] ;
ASSOCIATION : [aA][sS][sS][oO][cC][iI][aA][tT][iI][oO][nN] ;
ASYNC : [aA][sS][yY][nN][cC] ;
ASYNCHRONOUS : [aA][sS][yY][nN][cC][hH][rR][oO][nN][oO][uU][sS] ;
AUTO : [aA][uU][tT][oO] ;
BETWEEN : [bB][eE][tT][wW][eE][eE][nN] ;
BOTH : [bB][oO][tT][hH] ;
CACHE : [cC][aA][cC][hH][eE] ;
CHECK : [cC][hH][eE][cC][kK] ;
COLUMN: [cC][oO][lL][uU][mM][nN] ;
COLUMNS: [cC][oO][lL][uU][mM][nN][sS] ;
COMPOSITION : [cC][oO][mM][pP][oO][sS][iI][tT][iI][oO][nN] ;
CONFIGURATION : [cC][oO][nN][fF][iI][gG][uU][rR][aA][tT][iI][oO][nN] ;
CONST : [cC][oO][nN][sS][tT] ;
CONTEXT : [cC][oO][nN][tT][eE][xX][tT] ;
CROSS : [cC][rR][oO][sS][sS] ;
CURRENT : [cC][uU][rR][rR][eE][nN][tT] ;
CYCLE : [cC][yY][cC][lL][eE] ;
DAY : [dD][aA][yY] ;
DEFAULT : [dD][eE][fF][aA][uU][lL][tT] ;
DEFINE : [dD][eE][fF][iI][nN][eE] ;
DEPENDS : [dD][eE][pP][eE][nN][dD][sS] ;
DESC : [dD][eE][sS][cC] ;
DETECTION: [dD][eE][tT][eE][cC][tT][iI][oO][nN] ;
DISABLED : [dD][iI][sS][aA][bB][lL][eE][dD] ;
DOCUMENTS : [dD][oO][cC][uU][mM][eE][nN][tT][sS] ;
ELEMENT : [eE][lL][eE][mM][eE][nN][tT] ;
ELSE : [eE][lL][sS][eE] ;
ENABLED : [eE][nN][aA][bB][lL][eE][dD] ;
END : [eE][nN][dD] ;
ENTITY : [eE][nN][tT][iI][tT][yY] ;
ENUM : [eE][nN][uU][mM] ;
EVERY : [eE][vV][eE][rR][yY] ;
ESCAPE : [eE][sS][cC][aA][pP][eE] ;
EXCEPT : [eE][xX][cC][eE][pP][tT] ;
EXCLUDING : [eE][xX][cC][lL][uU][dD][iI][nN][gG] ;
EXISTING : [eE][xX][iI][sS][tT][iI][nN][gG] ;
EXTEND : [eE][xX][tT][eE][nN][dD] ;
EXTENDED : [eE][xX][tT][eE][nN][dD][eE][dD] ;
FAST : [fF][aA][sS][tT] ;
FIRST : [fF][iI][rR][sS][tT] ;
FLUSH : [fF][lL][uU][sS][hH] ;
FULL : [fF][uU][lL][lL] ;
FULLTEXT : [fF][uU][lL][lL][tT][eE][xX][tT] ;
FUNCTION : [fF][uU][nN][cC][tT][iI][oO][nN] ;
FUZZY : [fF][uU][zZ][zZ][yY] ;
GENERATED : [gG][eE][nN][eE][rR][aA][tT][eE][dD] ;
GETNUMSERVERS : [gG][eE][tT][_][nN][uU][mM][_][sS][eE][rR][vV][eE][rR][sS] ;
GRANT : [gG][rR][aA][nN][tT] ;
GROUP : [gG][rR][oO][uU][pP] ;
HANA : [hH][aA][nN][aA] ;
HASH : [hH][aA][sS][hH] ;
HAVING : [hH][aA][vV][iI][nN][gG] ;
HOUR : [hH][oO][uU][rR] ;
IDENTITY : [iI][dD][eE][nN][tT][iI][tT][yY] ;
INCREMENT : [iI][nN][cC][rR][eE][mM][eE][nN][tT] ;
INDEX : [iI][nN][dD][eE][xX] ;
INNER : [iI][nN][nN][eE][rR] ;
INTERSECT : [iI][nN][tT][eE][rR][sS][eE][cC][tT] ;
INTO : [iI][nN][tT][oO] ;
IS : [iI][sS] ;
JOIN : [jJ][oO][iI][nN] ;
KEEPING : [kK][eE][eE][pP][iI][nN][gG] ;
LANGUAGE : [lL][aA][nN][gG][uU][aA][gG][eE];
LAST : [lL][aA][sS][tT] ;
LAYOUT : [lL][aA][yY][oO][uU][tT] ;
LEADING : [lL][eE][aA][dD][iI][nN][gG] ;
LEFT : [lL][eE][fF][tT] ;
LIKE : [lL][iI][kK][eE] ;
LIMIT : [lL][iI][mM][iI][tT] ;
LOCALIZED: [lL][oO][cC][aA][lL][iI][zZ][eE][dD];
MANY : [mM][aA][nN][yY] ;
MASKED : [mM][aA][sS][kK][eE][dD] ;
MAXVALUE : [mM][aA][xX][vV][aA][lL][uU][eE] ;
MERGE : [mM][eE][rR][gG][eE] ;
MIGRATION: [mM][iI][gG][rR][aA][tT][iI][oO][nN] ;
MINING : [mM][iI][nN][iI][nN][gG] ;
MINUS : [mM][iI][nN][uU][sS] ;
MINUTE : [mM][iI][nN][uU][tT][eE] ;
MINUTES : [mM][iI][nN][uU][tT][eE][sS] ;
MINVALUE : [mM][iI][nN][vV][aA][lL][uU][eE] ;
MIME : [mM][iI][mM][eE] ;
MIXIN : [mM][iI][xX][iI][nN] ;
MODE : [mM][oO][dD][eE] ;
MONTH : [mM][oO][nN][tT][hH] ;
NAME : [nN][aA][mM][eE] ;
NAMEPREFIX : [nN][aA][mM][eE][pP][rR][eE][fF][iI][xX] ;
NAMESPACE : [nN][aA][mM][eE][sS][pP][aA][cC][eE] ;
NO : [nN][oO] ;                 // or make reserved? (is in SQL-92)
NULLS : [nN][uU][lL][lL][sS] ;
OFF : [oO][fF][fF] ;
OFFSET : [oO][fF][fF][sS][eE][tT] ;
ONE : [oO][nN][eE] ;
ONLY : [oO][nN][lL][yY] ;
OR : [oO][rR] ;
ORDER : [oO][rR][dD][eE][rR] ;
OTHERS : [oO][tT][hH][eE][rR][sS] ;
OUTER : [oO][uU][tT][eE][rR] ;
OVERLAY : [oO][vV][eE][rR][lL][aA][yY] ;
QUEUE : [qQ][uU][eE][uU][eE] ;
PACKAGE : [pP][aA][cC][kK][aA][gG][eE] ;
PARAMETERS : [pP][aA][rR][aA][mM][eE][tT][eE][rR][sS] ;
PARTITION : [pP][aA][rR][tT][iI][tT][iI][oO][nN] ;
PARTITIONING : [pP][aA][rR][tT][iI][tT][iI][oO][nN][iI][nN][gG] ;
PARTITIONS : [pP][aA][rR][tT][iI][tT][iI][oO][nN][sS] ;
PHRASE : [pP][hH][rR][aA][sS][eE] ;
PREPROCESS : [pP][rR][eE][pP][rR][oO][cC][eE][sS][sS] ;
PRIORITY: [pP][rR][iI][oO][rR][iI][tT][yY] ;
PRIVILEGE : [pP][rR][iI][vV][iI][lL][eE][gG][eE] ;
PROJECTION : [pP][rR][oO][jJ][eE][cC][tT][iI][oO][nN] ;
RANGE : [rR][aA][nN][gG][eE] ;
RATIO : [rR][aA][tT][iI][oO] ;
REDIRECTED : [rR][eE][dD][iI][rR][eE][cC][tT][eE][dD] ;
RESET : [rR][eE][sS][eE][tT] ;
RETURNS : [rR][eE][tT][uU][rR][nN][sS] ;
RIGHT : [rR][iI][gG][hH][tT] ;
ROLE : [rR][oO][lL][eE] ;
ROUNDROBIN : [rR][oO][uU][nN][dD][rR][oO][bB][iI][nN] ;
ROW : [rR][oO][wW] ;
SEARCH : [sS][eE][aA][rR][cC][hH] ;
SECOND : [sS][eE][cC][oO][nN][dD] ;
SEPARATORS : [sS][eE][pP][aA][rR][aA][tT][oO][rR][sS] ;
SERIES : [sS][eE][rR][iI][eE][sS] ;
SERVICE : [sS][eE][rR][vV][iI][cC][eE] ;
START : [sS][tT][aA][rR][tT] ;
STORAGE : [sS][tT][oO][rR][aA][gG][eE] ;
STORE : [sS][tT][oO][rR][eE] ;
STRUCTURED : [sS][tT][rR][uU][cC][tT][uU][rR][eE][dD] ;
SUBTYPE : [sS][uU][bB][tT][yY][pP][eE] ;
SYNC : [sS][yY][nN][cC] ;
SYNCHRONOUS : [sS][yY][nN][cC][hH][rR][oO][nN][oO][uU][sS] ;
TABLE : [tT][aA][bB][lL][eE] ;
TECHNICAL : [tT][eE][cC][hH][nN][iI][cC][aA][lL] ;
TEMPORARY : [tT][eE][mM][pP][oO][rR][aA][rR][yY] ;
TEXT : [tT][eE][xX][tT] ;
THEN : [tT][hH][eE][nN] ;
TOKEN : [tT][oO][kK][eE][nN] ;
TOP : [tT][oO][pP] ;
TRAILING : [tT][rR][aA][iI][lL][iI][nN][gG] ;
TO : [tT][oO] ;                 // or make reserved? (is in SQL-92)
TYPE : [tT][yY][pP][eE] ;
UNION : [uU][nN][iI][oO][nN] ;
UNIQUE : [uU][nN][iI][qQ][uU][eE] ;
UNLOAD : [uU][nN][lL][oO][aA][dD] ;
USING : [uU][sS][iI][nN][gG] ;
VALUE : [vV][aA][lL][uU][eE] ;
VALUES : [vV][aA][lL][uU][eE][sS] ;
VIEW : [vV][iI][eE][wW] ;
VIRTUAL: [vV][iI][rR][tT][uU][aA][lL] ;
WHERE : [wW][hH][eE][rR][eE] ;
YEAR : [yY][eE][aA][rR] ;

// Identifiers, must BE LAST, DIRECTLY AFTER the unreserved keywords ---------

Identifier                      // DO NOT RENAME OR MOVE THIS RULE !!!
  : [$_a-zA-Z][$_a-zA-Z0-9]*    // i.e. including $param
  | ( '"' ~[\u0022\n\r\u2028\u2029]* '"' )+ // \u0022 = '"'
  ;

IllegalToken : . ;

// Local Variables:
// c-basic-offset: 2
// End:
