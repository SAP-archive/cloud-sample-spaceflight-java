// Generic ANTLR parser class with AST-building functions

// To have an AST also in the case of syntax errors, produce it by adding
// sub-nodes to a parent node, not by returning sub-ASTs (the latter is fine
// for secondary attachments).

var antlr4 = require('antlr4');
var { addToDictWithIndexNo } = require('../base/dictionaries');


// Class which is to be used as grammar option with
//   grammar <name> options { superclass = genericAntlrParser; }
//
// The individual AST building functions are to be used with
//   this.<function>(...)
// in the actions inside the grammar.
//
function GenericAntlrParser( ...args ) {
  // ANTLR restriction: we cannot add parameters to the constructor.
  antlr4.Parser.call( this, ...args );
  this.buildParseTrees = false;
  return this;
}

// When we define this class with the ES6 `class` syntax, we get
//   TypeError: Class constructors cannot be invoked without 'new'
// Reason: the generated ANTLR constructor calls its super constructor via
// old-style `<super>.call(this,...)`, not via `super(...)`.

GenericAntlrParser.prototype = Object.assign(
  Object.create( antlr4.Parser.prototype ), {
    message,
    attachLocation,
    startLocation,
    tokenLocation,
    combinedLocation,
    identAst,
    numberLiteral,
    quotedLiteral,
    pathName,
    addDef,
    addItem,
    assignProps,
    createPrefixOp,
    setOnce,
    notYet,
    noSemicolonHere,
    constructor: GenericAntlrParser // keep this last
  });

// Patterns for literal token tests and creation.  The value is a map from the
// `prefix` argument of function `quotedliteral` to the following properties:
//  - `test_msg`: error message which is issued if `test_fn` or `test_re` fail.
//  - `test_fn`: function called with argument `value`, fails falsy return value
//  - `test_re`: regular expression, fails if it does not match argument `value`
//  - `unexpected_msg`: error message which is issued if `unexpected_char` matches
//  - `unexpected_char`: regular expression matching an illegal character in `value`,
//    the error location is only correct for a literal <prefix>'<value>'
//  - `literal`: the value which is used instead of `prefix` in the AST
//  - `normalized`: function called with argument `value`, return value is used
//    instead of `value` in the AST
// TODO: think about laxer regexp for date/time/timestamp - normalization?
var quotedLiteralPatterns = {
  x: {
    test_msg: 'A binary literal must have an even number of characters',
    test_fn: (str => Number.isInteger(str.length / 2)),
    unexpected_msg: 'A binary literal must only contain characters 0-9, a-f and A-F',
    unexpected_char: /[^0-9a-f]/i,
    literal: 'hex'
  },
  time: {
    test_msg: 'Expected time\'HH:MM:SS\' where H, M and S are numbers and \':SS\' is optional',
    test_re: /^[0-9]{1,2}:[0-9]{1,2}(:[0-9]{1,2})?$/
  },
  date: {
    test_msg: 'Expected date\'YYYY-MM-DD\' where Y, M and D are numbers',
    test_re: /^[0-9]{1,4}-[0-9]{1,2}-[0-9]{1,2}$/
  },
  timestamp: {
    test_msg: 'Expected timestamp\'YYYY-MM-DD HH:MM:SS.u…u\' where Y, M, D, H, S and u are numbers (optional 1-7×u)',
    test_re: /^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}(:[0-9]{2}(\.[0-9]{1,7})?)?$/
  }
};


// Push message `msg` with location `loc` to array of errors:
function message( msg, loc, severity ) {
  if (!this.options.parseOnly)  // TODO: remove this test
    this.messageErrorListener.message( msg, loc, severity );
}

// Push a message to the array of errors complaining that language construct
// 'feature' is not yet supported (using the location `loc`, which can also be a token for its locatio'), unless
// option 'parseOnly' or any of the options from 'optionsArray' are set.
function notYet( feature, loc, optionsArray=[] ) {
  if (this.options.parseOnly) {
    // Generally ignore if only parsing
    return;
  }
  for (let option of optionsArray) {
    // Grammar says to ignore for this option
    if (this.options[option]) {
      return;
    }
  }
  this.messageErrorListener.message( `${feature} not supported yet`,
                                     (loc instanceof antlr4.CommonToken) ? this.tokenLocation(loc) : loc );
}

function noSemicolonHere() {
  var t = this.getCurrentToken();
  if (t.text === ';')
    this.messageErrorListener.message( `Unexpected ';' - previous keyword 'with' is ignored`,
                                       this.tokenLocation(t), 'Warning' );
  // TODO remove ';' from set of expected tokens
}

// Attach location matched by current rule to node `art`.  If a location is
// already provided, only set the end location.  Use this function only
// in @after actions of parser rules, as the end position is only available
// there.
function attachLocation( art ) {
  if (!art)
    return art;
  if (!art.location)
    art.location = this.startLocation();
  let stop = this._ctx.stop;
  art.location.end = {
    offset: stop.stop + 1,      // after the last char (special for EOF?)
    line: stop.line,
    column: stop.stop - stop.start + stop.column + 2
  }
  return art;
}

// Return start location of `token`, or the first token matched by the current
// rule if `token` is undefined
function startLocation( token = this._ctx.start ) {
  return {
    filename: this.filename,
    start: { offset: token.start, line: token.line, column: token.column + 1}
  };
}

// Return location of `token`.  If `endToken` is provided, use its end
// location as end location in the result.
function tokenLocation( token, endToken = token, val ) {
  if (!token)
    return undefined;
  let r = {
    filename: this.filename,
    start: { offset: token.start, line: token.line, column: token.column + 1},
    end: {                       // we only have single-line tokens
      offset: endToken.stop + 1, // after the last char (special for EOF?)
      line: endToken.line,
      column: endToken.stop - endToken.start + endToken.column + 2
    }
  };
  if (val !== undefined)
    return { location: r, val };
  return r;
}

// Create a location with location properties `filename` and `start` from
// argument `start`, and location property `end` from argument `end`.
function combinedLocation( start, end ) {
  return {
    filename: start.location.filename,
    start: start.location.start,
    end: end && end.location && end.location.end
  };
}

// Return AST for identifier token `token`.  Also do validilty check on
// identifer (TODO: check for dots etc/ here).
function identAst( token ) {
  var id = token.text;
  if (token.text[0] !== '"')
    return { id, location: this.tokenLocation( token ) };
  // quoted:
  id = id.slice( 1, -1 ).replace( /""/g, '"' );
  if (!id) {
    this.message( "Quoted identifier must contain at least one character",
                  this.tokenLocation( token ) );
  }
  return { id, quoted: true, location: this.tokenLocation( token ) };
}

// Return AST for number token `token` with optional token `sign`.  Represent
// the number as number in property `val` if the number can safely be
// represented as an integer.  Otherwise, represent the number by a string, the
// token lexeme.
function numberLiteral( token, sign, text = token.text ) {
  var location = this.tokenLocation( token );
  if (sign) {
    let end = location.end;
    location = this.startLocation( sign );
    location.end = end;
    text = sign.text + text;
  }
  var num = Number.parseFloat( text ); // not Number.parseInt() !
  var val = (Number.isSafeInteger(num)) ? num : text;
  return { literal: 'number', val, location };
}

// Create AST node for quoted literals like string and e.g. date'2017-02-22'.
// This function might issue a message and might change the `literal` and
// `val` property according to `quotedLiteralPatterns` above.
function quotedLiteral( token, literal ) {
  var location = this.tokenLocation( token );
  var pos = token.text.search( '\'' ) + 1; // pos of char after quote
  var val = token.text.slice( pos, -1 ).replace( /''/g, '\'' );

  if (!literal)
    literal = token.text.slice( 0, pos-1 ).toLowerCase();
  var p = quotedLiteralPatterns[ literal ] || {};

  if (p.test_fn && !p.test_fn(val) || p.test_re && !p.test_re.test(val))
    this.message( p.test_msg, location );

  if (p.unexpected_char)
  {
    let idx = val.search(p.unexpected_char);
    if (~idx) {
      this.message( p.unexpected_msg, {
        filename: location.filename,
        start: atChar( idx ),
        end: atChar( idx + (val[idx] == '\'' ? 2 : 1) )
      } );
    }
  }
  return {
    literal: p.literal || literal,
    val: p.normalize && p.normalize(val) || val,
    location
  };

  function atChar(i) {
    return {
      line: location.start.line,
      column: location.start.column + pos + i,
      offset: location.start.offset + pos + i
    };
  }
}

function pathName( path, brokenName ) {
  return (path && !path.broken) ? path.map( id => id.id ).join('.') : brokenName;
}

// Add new definition to dictionary property `env` of node `parent` and return
// that definition.  Also attach the following properties to the new definition:
//  - `name`: argument `name`, which is used as key in the dictionary
//  - `kind`: argument `kind` if that is truthy
//  - `location`: argument `location` or the start location of source matched by
//    current rule
//  - properties in argument `props` which are no empty (undefined, null, {},
//    []), ANTLR tokens are replaced by their locations
//
// Hack: if argument `location` is exactly `true`, do not set `location`
// (except if part of `props`), but also include the empty properties of
// `props`.
function addDef( parent, env, kind, name, annos, props, location ) {
  if (name instanceof Array) {
    let last = name.length && name[ name.length-1 ];
    if (last && last.id)        // // A.B.C -> 'C'
      name = { id: last.id, location: last.location, calculated: true, $inferred: 'as' };
  }
  else if (name && name.id == null) {
    name.id = pathName (name.path ); // A.B.C -> 'A.B.C'
  }
  var art = this.assignProps( { name }, annos, props, location );
  if (kind)
    art.kind = kind;
  if (!parent[env])
    parent[env] = Object.create(null);
  if (!art.name || art.name.id == null) {
    // no id was parsed, but with error recovery: no further error
    env = env + '_';            // could be tested in name search - TODO: fails with --test-mode
    if (!parent[env])
      parent[env] = [art];
    else
      parent[env].push(art);
  }
  else if (kind) {
    addToDictWithIndexNo( parent, env, art.name.id, art );
  }
  else {
    addToDictWithIndexNo( parent, env, art.name.id, art, ( name, loc ) => {
      // do not use function(), otherwise `this` is wrong:
      if (kind === 0)
        this.message( `Duplicate value for view parameter "${name}"`, loc );
      else if (kind === '')
        this.message( `Duplicate EXCLUDING for source element "${name}"`, loc );
      else
        this.message( `Duplicate assignment for structure property "${name}"`, loc );
    } );
  }
  return art;
}

// Add new definition to array property `env` of node `parent` and return
// that definition.  Also attach the following properties to the new definition:
//  - `kind`: argument `kind` if that is truthy
//  - `location`: argument `location` or the start location of source matched by
//    current rule
//  - properties in argument `props` which are no empty (undefined, null, {},
//    []); ANTLR tokens are replaced by their locations
//
// Hack: if argument `location` is exactly `true`, do not set `location`
// (except if part of `props`), but also include the empty properties of
// `props`.
function addItem( parent, env, kind, annos, props, location ) {
  var art = this.assignProps( {}, annos, props, location );
  if (kind)
    art.kind = kind;
  if (!parent[env])
    parent[env] = [ art ];
  else
    parent[env].push( art );
  return art;
}

// Assign all non-empty (undefined, null, {}, []) properties in argument
// `props` and argument `annos` as property `annotationAssignments` to `target`
// and return it.  Hack: if argument `annos` is exactly `true`, return
// `Object.assign( target, props )`.  ANTLR tokens are replaced by their
// locations.
function assignProps( target, annos = [], props, location ) {
  if (annos === true)
    return Object.assign( target, props );
  target.location = location || this.startLocation( this._ctx.start );
  // Object.assign without "empty" elements/properties and with mappings:
  //  - token instanceof antlr4.CommonToken => location of token
  for (var key in props) {
    var val = props[key];
    if (val instanceof antlr4.CommonToken)
      val = this.tokenLocation( val, undefined, true);
    // only copy properties which are not undefined, null, {} or []
    if (val != null &&
        (typeof val !== "object" ||
         (val instanceof Array ? val.length : Object.getOwnPropertyNames(val).length) ) ) {
      target[key] = val;
    }
  }
  if (annos)
    target.annotationAssignments = annos;
  return target;
}

// Create AST node for prefix operator `op` and arguments `args`
function createPrefixOp( token, args ) {
  let op = this.tokenLocation( token, undefined, token.text.toLowerCase() );
  return { op, args, location: this.combinedLocation( op, args[ args.length-1 ] ) };
}

// Set property `prop` of `target` to value `value`.  Issue error if that
// property has been set before, while mentioning the keywords previously
// provided (as arguments `tokens`).
function setOnce( target, prop, value, ...tokens ) {
  var loc = this.tokenLocation( tokens[0], tokens[tokens.length-1] );
  var prev = target[prop];
  if (prev) {
    this.message( `Option ${prev.option} has already been specified`, loc );
  }
  if (typeof value === 'boolean') {
    if (!value)
      loc.value = false;
    value = loc;
  }
  value.option = tokens.map( t => t.text.toUpperCase() ).join(' ');
  target[prop] = value;
}


module.exports = {
  genericAntlrParser: GenericAntlrParser
};
