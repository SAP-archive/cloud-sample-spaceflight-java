'use strict'

// Low-level utility functions to work with augmented CSN.

// Return true if 'node' is a projection entity
function isProjection(node) {
  // FIXME: Looking at 'source' is probably not correct here?
  return node.kind == 'entity' && node.source != undefined;
}

// Return true if 'node' is a view entity
function isView(node) {
  // FIXME: Do we really have to consider 'kind' or is it sufficient to look at 'queries'?
  return node.kind == 'view' && node.queries != undefined;
}

// Return true if 'node is a managed association element
function isManagedAssociationElement(node) {
  return node.kind == 'element' && node.target != undefined && node.on == undefined;
}

// Return true if 'type' is an association type
function isAssociation(type) {
  return type && (type.absolute == 'cds.Association' || type.absolute == 'cds.Composition');
}

// Return true if 'elem' is an element (plus sanity check: must have _finalType)
function isElement(elem) {
  if (elem.kind != 'element') {
    return false;
  }
  // Sanity checks
  if (!elem._finalType) {
    throw Error('Expecting element ' + printableName(elem) + ' to have _finalType');
  }
  return true;
}

// Return true if 'elem' is a structured element
function isStructuredElement(elem) {
  return isElement(elem) && elem._finalType.elements != undefined;
}

// Return true if 'elem' is an array-typed element
function isArrayElement(elem) {
  return isElement(elem) && elem._finalType.items != undefined;
}

// Return true if 'elem' is an association or composition element
function isAssociationElement(elem) {
  return isElement(elem) && elem._finalType.target != undefined;
}

// Return true if 'elem' is a scalar element (i.e. a primitive type, possibly an enum,
// not structured, not an array, not an association/composition)
function isScalarElement(elem) {
  return isElement(elem) && elem._finalType.type != undefined;
}

// Return true is 'elem' is an alement that has a type (in contrast e.g. to expression
// elements in views which don't)
function isElementWithType(elem) {
  return isScalarElement(elem) || isAssociationElement(elem) || isArrayElement(elem) || isStructuredElement(elem);
}

// Return true if 'node' has an artifact kind (i.e. may potentially live in 'definitions')
function isArtifact(node) {
  if (!node) {
    return false;
  }
  switch (node.kind) {
    case 'context':
    case 'service':
    case 'namespace':
    case 'entity':
    case 'view':
    case 'type':
    case 'annotation':
    case 'action':
    case 'function':
    case 'const':
    case 'role':
    case 'aspect':
    case 'accesspolicy':
      return true;
    case 'element':
    case 'query':
    case 'param':
    case 'enum':
      return false;
    default:
      throw new Error('Unknown artifact kind: ' + node.kind);
  }
}

// Return true if 'node' is an artifact that may contain other artifacts
function isContainerArtifact(node) {
  if (!isArtifact(node)) {
    return false;
  }
  switch (node.kind) {
    case 'context':
    case 'service':
    case 'namespace':
    case 'accesspolicy':
      return true;
    default:
      return false;
  }
}

// Produce a printable name (for error messages) for element or artifact 'node'
function printableName(node) {
  let name = node.name && node.name.absolute ||
             node._main && node._main.name && node._main.name.absolute;
  let element = node.name && node.name.element;
  if (name && element) {
    name += ', ' + element;
  }
  return (node.kind || '<kind>') + '(' + name + ')';
}

// Add an annotation with absolute name 'absoluteName' (including '@') and string value 'theValue' to 'node'
function addStringAnnotationTo(absoluteName, theValue, node) {
  // Sanity check
  if (!absoluteName.startsWith('@')) {
    throw Error('Annotation name should start with "@": ' + absoluteName);
  }
  // Assemble the annotation
  node[absoluteName] = {
    name: {
      absolute: absoluteName.substring(1),
    },
    val: theValue,
    literal: 'string',
  };
}

// Rename annotation 'fromName' in 'node' to 'toName' (both names including '@')
function renameAnnotation(node, fromName, toName) {
  let annotation = node && node[fromName];
  // Sanity checks
  if (!fromName.startsWith('@')) {
    throw Error('Annotation name should start with "@": ' + fromName);
  }
  if (!toName.startsWith('@')) {
    throw Error('Annotation name should start with "@": ' + toName);
  }
  if (annotation == undefined) {
    throw Error('Annotation ' + fromName + ' not found in ' + printableName(node));
  }
  // FIXME: We leave the path as it was here and only adapt the absolute name - does that make sense?
  annotation.name.absolute = toName.substring(1);
  delete node[fromName];
  node[toName] = annotation;
  // FIXME: Should we try to resolve the annotation (but currently it does not seem to have a _artifact ?)
}

// Copy all annotations from 'fromNode' to 'toNode'. Overwrite existing ones only if 'overwrite' is true
function copyAnnotations(fromNode, toNode, overwrite=false) {
  // Ignore if no toNode (in case of errors)
  if (!toNode) {
    return;
  }
  for (let prop in fromNode) {
    if (prop.startsWith('@')) {
      if (toNode[prop] == undefined || overwrite) {
        toNode[prop] = fromNode[prop];
      }
    }
  }
}

// Return true if 'node' has a bool annotation 'name' with (explicit or implicit) value 'true'
function hasBoolAnnotation(node, name) {
  // Sanity check
  if (!name.startsWith('@')) {
    throw Error('Annotation name should start with "@": ' + name);
  }
  return node[name] && (node[name].val === undefined || node[name].val === true);
}

// For each property named 'path' in 'node' (recursively), call callback(path, node)
function foreachPath(node, callback) {
  if (node == null || typeof node !== 'object') {
    // Primitive node
    return;
  }
  for (let name in node) {
    // If path found within a non-dictionary, call callback
    if (name == 'path' && Object.getPrototypeOf(node)) {
      callback(node.path, node);
    }
    // Descend recursively
    foreachPath(node[name], callback);
  }
}

// Merge multiple 'options' objects (from right to left, i.e. rightmost wins). Structured option values are
// merged deeply. Structured option value from the right may override corresponding bool options on the left,
// but no other combination of struct/scalar values is allowed. Array options are not merged, i.e. their
// content is treated like scalars.
// Returns a new options object.
function mergeOptions(...optionsObjects) {
  let result = {};
  for (let options of optionsObjects) {
    result = mergeTwo(result, options, 'options');
  }
  return result;

  // Recursively used for scalars, too
  function mergeTwo(left, right, name) {
    let result;
    // Copy left as far as required
    if (isArray(left)) {
      // Shallow-copy left array
      result = left.slice();
    } else if (isObject(left)) {
      // Deep-copy left object (unless empty)
      result = Object.keys(left).length ? mergeTwo({}, left, name) : {};
    } else {
      // Just use left scalar
      result = left;
    }
    // Check against improper overwriting
    if (isObject(left) && !isArray(left) && (isArray(right) || isScalar(right))) {
      throw new Error(`Cannot overwrite structured option "${name}" with array or scalar value`);
    }
    if ((isScalar(left) && typeof left != 'boolean' || isArray(left)) && isObject(right) && !isArray(right)) {
      throw new Error(`Cannot overwrite non-boolean scalar or array option "${name}" with structured value`);
    }

    // Copy or overwrite properties from right to left
    if (isArray(right)) {
      // Shallow-copy right array
      result = right.slice();
    } else if (isObject(right)) {
      // Object overwrites undefined, scalars and arrays
      if (result === undefined || isScalar(result) || isArray(result)) {
        result = {};
      }
      // Deep-copy right object into result
      for (let key of Object.keys(right)) {
        result[key] = mergeTwo(result[key], right[key], `${name}.${key}`);
      }
    } else {
      // Right scalar wins (unless undefined)
      result = (right !== undefined) ? right : result;
    }
    return result;
  }

  // Return true if 'o' is a non-null object or array
  function isObject(o) {
    return typeof o == 'object' && o !== null
  }

  // Return true if 'o' is a non-null array
  function isArray(o) {
    return isObject(o) && o instanceof Array;
  }

  // Return true if 'o' is a non-undefined scalar
  function isScalar(o) {
    return o !== undefined && !isObject(o);
  }
}

// Return the name of the top-level artifact surrounding the artifact 'name'
// in 'model'.
// We define "top-level artifact" to be an artifact that has either no parent or only
// ancestors of kind 'namespace'. Note that it is possible for a non-top-level artifact
// to have a namespace as parent and e.g. a context as grandparent (weird but true).
// Will return the artifact 'name' if it is a top-level artifact itself, and 'undefined'
// if there is no artifact surrounding 'name' in the model
function getTopLevelArtifactNameOf(name, model) {
  let dotIdx = name.indexOf('.');
  if (dotIdx == -1) {
    // No '.' in the name, i.e. no parent - this is a top-level artifact (if it exists)
    return model.definitions[name] ? name : undefined;
  }
  // If the first name part is not in the model, there is nothing to find
  if (!model.definitions[name.substring(0, dotIdx)]) {
    return undefined;
  }
  // Skip forward through '.'s until finding a non-namespace
  while (dotIdx != -1 && model.definitions[name.substring(0, dotIdx)].kind == 'namespace') {
    dotIdx = name.indexOf('.', dotIdx + 1);
  }
  if (dotIdx == -1) {
    // This is a top-level artifact
    return name;
  }
  // The skipped part of 'name' is the top-level artifact name
  return name.substring(0, dotIdx);
}

// Return the last part of 'name'.
// Examples:
//   'foo.bar.wiz' => 'wiz'
//   'foo' => 'foo';
//   'foo::bar' => 'bar'
function getLastPartOf(name) {
  return name.substring(name.search(/[^.:]+$/));
}

// Return the last part of reference array 'ref'
// Examples:
//   ['foo.bar', 'wiz'] => 'wiz'
//   ['foo.bar.wiz'] => 'wiz'
//   ['foo'] => 'foo';
//   ['foo::bar'] => 'bar'
function getLastPartOfRef(ref) {
  let lastPathStep = ref[ref.length - 1];
  return getLastPartOf(lastPathStep.id || lastPathStep);
}

// Return the name of the parent artifact of the artifact 'name' or
// '' if there is no parent.
function getParentNameOf(name) {
  return name.substring(0, name.lastIndexOf('.'));
}

// Return an array of parent names of 'name' (recursing into grand-parents)
// Examples:
//   'foo.bar.wiz' => [ 'foo.bar', 'foo' ]
//   'foo' => []
//   'foo::bar.wiz' => 'foo::bar'
//   'foo::bar' => []
function getParentNamesOf(name) {
  let remainder = name.slice(0, -getLastPartOf(name).length);
  if (remainder.endsWith('.')) {
    let parentName = remainder.slice(0, -1);
    return [parentName, ...getParentNamesOf(parentName)];
  } else {
    return [];
  }
}

module.exports = {
  isProjection,
  isView,
  isManagedAssociationElement,
  isAssociation,
  isStructuredElement,
  isArrayElement,
  isAssociationElement,
  isScalarElement,
  isElementWithType,
  isArtifact,
  isContainerArtifact,
  printableName,
  addStringAnnotationTo,
  renameAnnotation,
  copyAnnotations,
  hasBoolAnnotation,
  foreachPath,
  mergeOptions,
  getTopLevelArtifactNameOf,
  getLastPartOf,
  getLastPartOfRef,
  getParentNameOf,
  getParentNamesOf,
}
