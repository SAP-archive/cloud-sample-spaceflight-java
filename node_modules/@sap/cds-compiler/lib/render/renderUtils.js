"use strict";

const compactor = require('../json/compactor');

// Return render utility functions
//   renderExpressionOrCondition(x, env, inline=true)
//   renderJoinOp(joinOp)
// for augmented CSN 'model' with 'options', using the following callbacks for rendering
//   renderPathOrValue(v, env, inline=true)
//   renderQuery(query, art, isLeadingQuery, env)
//   increaseIndent(env)
//   decreaseIndent(env)


function getRenderUtils(model, options, callbacks) {
  // Sanity checks
  if (!callbacks || !callbacks.renderPathOrValue || !callbacks.renderQuery || !callbacks.increaseIndent || !callbacks.decreaseIndent ) {
    throw new Error('Incomplete callbacks for getOutputUtils: ' + callbacks);
  }

  const { compactCondOrExpr } = compactor.getCompactors(options);

  return {
    renderExpressionOrCondition,
    renderJoinOp,
  }

  // Render an expression (including paths and values) or condition 'x'.
  // (no trailing LF, don't indent if inline)
  function renderExpressionOrCondition(x, env, inline=true) {
    // If this is really a condition or expression, assemble a string from its op and args
    if (x.op) {
      // FIXME: Needs to be adapted when new operators are introduced into the grammar
      if (x.op.val == 'call' && x.func) {
        return `${inline ? '' : env.indent}${x.func.path.map(step => step.id).join('.')}${renderExpressionOrCondition(x.args)}`;
      } else if (x.op.val == 'case') {
        let result = `${inline ? '' : env.indent}case `;
        x.args.forEach(a => {
          if (a.op && a.op.val === 'when')
            // assuming that when statement will have 2 args representing the 2 sides of the THEN in the expression
            result = result.concat(`when ${a.args.map(wArg => renderExpressionOrCondition(wArg, env)).join(' then ')} `);
          else if (a.op && a.op.val === 'else')
            result = result.concat(`else ${a.args.map(arg => renderExpressionOrCondition(arg, env)).join('')} `);
          else
            result = result.concat(`${callbacks.renderPathOrValue(a, env)} `);
        });
        result = result.concat('end');
        return result;
      }
      else if (isUnaryOperator(x.op.val) && x.args.length == 1) {
        return x.op.val + (x.op.val == 'not' ? ' ' : '')
             + renderExpressionOrCondition(x.args[0], env);
      } else if (isBinaryOperator(x.op.val) && x.args.length == 2) {
        return renderExpressionOrCondition(x.args[0], env)
             + ' ' + x.op.val + ' '
             + (x.quantifier ? x.quantifier.val + ' ' : '')
             + renderExpressionOrCondition(x.args[1], env);
      } else if (isInfixOperator(x.op.val)) {
        return x.args.map(arg => renderExpressionOrCondition(arg, env)).join(' ' + x.op.val + ' ');
      } else if ((x.op.val == 'isNull' || x.op.val == 'isNotNull') && x.args.length == 1) {
        return renderExpressionOrCondition(x.args[0], env)
               + ' is' + (x.op.val == 'isNotNull' ? ' not' : '')
               + ' null';
      } else if ((x.op.val == 'between' || x.op.val == 'notBetween') && x.args.length == 3) {
        return renderExpressionOrCondition(x.args[0], env)
             + (x.op.val == 'notBetween' ? ' not' : '')
             + ' between '
             + renderExpressionOrCondition(x.args[1], env)
             + ' and '
             + renderExpressionOrCondition(x.args[2], env);
      } else if ((x.op.val == 'in' || x.op.val == 'notIn') && x.args.length == 2) {
        return renderExpressionOrCondition(x.args[0], env)
             + (x.op.val == 'notIn' ? ' not' : '')
             + ' in '
             + renderExpressionOrCondition(x.args[1], env);
      } else if ((x.op.val == 'like' || x.op.val == 'notLike') && (x.args.length == 2 || x.args.length == 3)) {
        return renderExpressionOrCondition(x.args[0], env)
             + (x.op.val == 'notLike' ? ' not' : '')
             + ' like '
             + renderExpressionOrCondition(x.args[1], env)
             + (x.args.length == 3 ? ' escape ' + renderExpressionOrCondition(x.args[2], env) : '');
      } else if (x.op.val == 'exists' && (x.args.length == 1)) {
        return 'exists ' + renderExpressionOrCondition(x.args[0], callbacks.increaseIndent(env));
      } else if (x.op.val == 'query' || x.op.val == 'subquery') {
        // FIXME: Actually, we should pass the surrounding artifact and not null, but we don't have that here
        // (and it is not yet used except being passed to renderAbsoluteNameWithQuotes, which currently ignores it)
        return '(' + callbacks.renderQuery(x, null, false, env) + '\n' + callbacks.decreaseIndent(env).indent + ')';
      }
      throw new Error('Unknown operator "' + x.op.val + '" in expression or condition: ' + JSON.stringify(compactCondOrExpr(x)));
    } else if (x instanceof Array) {
      // A list, to be rendered in parentheses with commas
      return '(' + x.map(entry => renderExpressionOrCondition(entry, env)).join(', ') + ')';
    }
    // Everything else is a path or value
    return callbacks.renderPathOrValue(x, env, inline);

    // Return true if 'op' is an infix operator
    // (with an arbitrary number of arguments)
    function isInfixOperator(op) {
      return op in {
        'and': true,
        'or': true,
        '||': true,
      };
    }

    // Return true if 'op' is a binary operator
    // (See below for '+' and '-')
    function isBinaryOperator(op) {
      return op in {
        '=': true,
        '<>': true,
        '>': true,
        '>=': true,
        '<': true,
        '<=': true,
        '!=': true,
        '+': true,
        '-': true,
        '*': true,
        '/': true,
      };
    }

    // Return true if 'op' is an unary operator
    // Special case: '-' and '+' can be both unary and binary operators - we don't bother to distinguish
    // them other than simply counting the arguments above
    function isUnaryOperator(op) {
      return op in {
        '+': true,
        '-': true,
        'not': true,
      };
    }
  }

  // Render a join operator 'joinOp' (i.e. just something like 'LEFT INNER' etc.)
  function renderJoinOp(joinOp) {
    switch(joinOp) {
      case 'inner':
        return 'inner join';
      case 'leftOuter':
        return 'left outer join';
      case 'rightOuter':
        return 'right outer join';
      case 'fullOuter':
        return 'full outer join';
      case 'cross':
        return 'cross join';
      default:
        throw new Error('Unknown join operation: ' + joinOp);
    }
  }
}

module.exports = {
  getRenderUtils
};
