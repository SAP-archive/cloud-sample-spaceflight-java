
"use strict";

const { CompilationError, hasErrors, sortMessages } = require('../base/messages');
const { isAssociation, getTopLevelArtifactNameOf, getParentNameOf } = require('../model/modelUtils');
const renderUtils = require('./renderUtils');
const keywords = require('../base/keywords');
const alerts = require('../base/alerts');

// Render the CSN model 'model' to SQL DDL statements. One statement is created
// per top-level artifact, without trailing semicolon. Return a dictionary of top-level
// artifacts by their names, like this:
// { "foo" : "CREATE TABLE foo ...",
//   "bar::wiz" : "CREATE VIEW \"bar::wiz\" AS SELECT FROM ..."
// }
function toSqlDdl(model) {
  const { error, signal } = alerts(model);

  // Use model options
  let options = model.options;
  let result = Object.create(null);

  const { renderExpressionOrCondition, renderJoinOp } = renderUtils.getRenderUtils(model, options, {
    renderPathOrValue,
    renderQuery,
    increaseIndent,
    decreaseIndent,
  });

  // FIXME: Currently requires 'options.forHana', because it can only render HANA-ish SQL dialect
  if (!options.forHana) {
    throw new Error('toSql can currently only be used with HANA preprocessing');
  }

  // Render each artifact on its own
  for (let artifactName in model.definitions) {
    // This environment is passed down the call hierarchy, for dealing with
    // indentation issues
    let env = {
      // Current indentation string
      indent: '',
    }
    let sourceStr = renderArtifact(model.definitions[artifactName], env);

    if (sourceStr != '') {
      result[artifactName] = sourceStr;
    }
  }
  // Throw up if we have errors
  if (hasErrors(model.messages)) {
    throw new CompilationError(sortMessages(model.messages), model);
  }
  return result;

  // Render an artifact. Return the resulting source string.
  function renderArtifact(art, env) {
    // Ignore whole artifacts if forHana says so
    if (art._ignore) {
      return '';
    }
    switch (art.kind) {
      case 'entity':
        if (art.source) {
          return renderProjection(art, env);
        } else {
          return renderEntity(art, env);
        }
      case 'view':
        return renderView(art, env);
      case 'type':
        return renderType(art, env);
      case 'context':
      case 'service':
      case 'namespace':
      case 'annotation':
      case 'action':
      case 'function':
        // Ignore: not SQL-relevant
        return '';
      default:
        throw new Error('Unknown artifact kind: ' + art.kind);
    }
  }

  // Render a (non-projection) entity. Return the resulting source string.
  function renderEntity(art, env) {
    // FIXME: Took this from toCdl, but do entities have parameters yet at all? Views apparently don't ... I am confused  
    if (art.params && Object.keys(art.params)[0]) {
      let firstParam = art.params[Object.keys(art.params)[0]];
      signal(error`"${art.name.absolute}": Entities with parameters are not supported for conversion to SQL`, firstParam.location);
    }
    let childEnv = increaseIndent(env);

    let tc = art.technicalConfig;
    let storeType = (tc && tc.storeType) ? renderPathOrValue(tc.storeType) + ' ': '';

    let result = env.indent + 'CREATE ' + storeType + 'TABLE ' + quoteSqlId(absoluteCdsName(art.name.absolute));
    result += ' (\n';
    result += Object.keys(art.elements).map(name => renderElement(art.elements[name], childEnv))
                                       .filter(s => s != '')
                                       .join(',\n');
    let primaryKeys = Object.keys(art.elements).filter(name => art.elements[name].key)
                                               .map(name => quoteSqlId(name))
                                               .join(', ');
    if (primaryKeys != '') {
      result += ',\n' + childEnv.indent + 'PRIMARY KEY(' + primaryKeys + ')\n'
    } else {
      result += '\n'
    }
    result += env.indent + ')' + renderTechnicalConfiguration(tc, childEnv);

    let associations = Object.keys(art.elements).map(name => renderAssociationElement(art.elements[name], childEnv))
                                                .filter(s => s != '')
                                                .join(',\n');
    if (associations != '') {
      result += env.indent + ' WITH ASSOCIATIONS (\n' + associations + '\n';
      result += env.indent + ')';
    }
    result += ';';

    result += renderIndexes(tc, childEnv);

    return result;
  }

  // Render an element (of an entity or type, not a projection or view).
  // Ignore association elements (those are rendered later by renderAssociationElement)
  // Return the resulting source string (no trailing LF).
  function renderElement(elm, env) {
    // Ignore if forHana says so, or if it is an association
    if (elm._ignore) {
      return '';
    }
    if (isAssociation(elm._finalType.type)) {
      return '';
    }
    let result = env.indent + quoteSqlId(elm.name.id) + ' '
                            + renderTypeReference(elm)
                            + renderNullability(elm);
    if (elm.default) {
      result += ' DEFAULT ' + renderPathOrValue(elm.default, env);
    }

    if(elm._fzindex) {
      result += ' FUZZY SEARCH INDEX ON';
      if(elm._fzindex.fuzzy) {
        result += ' FUZZY SEARCH MODE';
        if(elm._fzindex.fuzzy.mode) {
          result += ' ' + renderPathOrValue(elm._fzindex.fuzzy.mode);
        }
      }
    }
    return result;
  }

  // Render those elements from 'elements' that are associations, in the style required for
  // HANA native associations (e.g. 'MANY TO ONE JOIN "source" AS "assoc" ON (condition)').
  // Return a string with one line per association, or an empty string if there are none
  function renderAssociationElement(elm, env) {
    let result = '';
    if (isAssociation(elm._finalType.type)) {
      result += env.indent + 'MANY TO ';
      if (elm.cardinality && elm.cardinality.targetMax && (elm.cardinality.targetMax.val == '*' || Number(elm.cardinality.targetMax.val) > 1)) {
        result += 'MANY';
      } else {
        result += 'ONE';
      }
      result += ' JOIN ';
      result += quoteSqlId(absoluteCdsName(elm.target.absolute)) + ' AS ' + quoteSqlId(elm.name.id) + ' ON (';
      result += renderExpressionOrCondition(elm.onCond, env, true) + ')';
    }
    return result;
  }

  // Render the 'technical configuration { ... }' section of an entity.
  // Return the resulting source string.
  function renderTechnicalConfiguration(tc, env) {
    let childEnv = increaseIndent(env);
    let result = '';
    if (!tc) {
      return result;
    }
    if (tc.migration) {
      result += '\n' + env.indent + 'MIGRATION ' + renderPathOrValue(tc.migration, env);
    }
    if (tc.extendedStorage) {
      result += '\n' + env.indent + 'USING EXTENDED STORAGE';
    }
    if (tc.unloadPrio) {
      result += '\n' + env.indent + 'UNLOAD PRIORITY ' + renderPathOrValue(tc.unloadPrio, env);
    }
    if (tc.autoMerge) {
      result += '\n' + env.indent + (tc.autoMerge.val == false ? 'NO ' : '') + 'AUTO MERGE';
    }

    if (tc.group) {
      result += '\n' + env.indent;
      if (tc.group.name) {
        result += 'GROUP NAME ' + quoteSqlId(tc.group.name.id);
      }
      if (tc.group.name && tc.group.type) {
        result += ' ';
      }
      if (tc.group.type) {
        result += 'GROUP TYPE ' + quoteSqlId(tc.group.type.id);
      }
      if ((tc.group.name || tc.group.type) && tc.group.subType) {
        result += ' ';
      }
      if (tc.group.subType) {
        result += 'GROUP SUBTYPE ' + quoteSqlId(tc.group.subType.id);
      }
    }

    if (tc.partition) {
      result += '\n' + env.indent + 'PARTITION BY \n';
      let i = 0;
      tc.partition.specs.forEach(p => {
        if (i > 0) {
          result += ',\n';
        }
        result += childEnv.indent + renderPartition(p, env);
        i++;
      });
      if (tc.partition.wpoac) {
        result += '\n' + childEnv.indent + 'WITH PARTITIONING ON ANY COLUMNS ' + renderPathOrValue(tc.partition.wpoac, env);
      }
    }
    return result;

    // Render a partition spec of a technical configuration.
    function renderPartition(partition, env) {
      let env2 = increaseIndent(increaseIndent(env));
      let result = renderPathOrValue(partition.scheme, env);
      if (partition.columns) {
        result += ' (';
        let i = 0;
        partition.columns.filter(column => !column._ignore).forEach(column => {
          if (i > 0) {
            result += ',\n' + env2.indent;
          }
          if (column.unit) {
            result += renderPathOrValue(column.unit, env) + '(';
          }
          result += renderPathOrValue(column, env);
          if (column.unit) {
            result += ')';
          }
          i++;
        });
        result += ')';
      }
      if (partition.partitions) {
        result += ' PARTITIONS ' + renderPathOrValue(partition.partitions, env);
      }
      if (partition.ranges) {
        result += '\n' + env2.indent + '(';
        let oppStore = (partition.ranges[0].store == 'default' ? 'extended' : 'default');
        let delimiter = false;

        partition.ranges.forEach((range, env) => {
          if (range.store != oppStore) {
            if (partition.withStorageSpec) {
              if (delimiter) {
                result += ')\n' + env2.indent;
              }
              result += 'USING ' + range.store.toUpperCase() + ' STORAGE (';
            }
            delimiter = false;
            oppStore = range.store;
          }
          if (delimiter) {
            result += ', ';
          }
          result += renderPartitionRange(range, env);
          delimiter = true;
        });
        if (partition.withStorageSpec) {
          result += ')';
        }
        result += ')';
      }
      return result;

      function renderPartitionRange(range, env) {
        let result = 'PARTITION ';
        if (range.others) {
          return result + renderPathOrValue(range.others, env);
        }
        if (!range.max) {
          result += 'VALUE = '
        }
        result += renderPathOrValue(range.min, env);
        if (range.isCurrent) {
          result += ' IS CURRENT';
        }
        if (range.max) {
          result += ' <= VALUES < ' + renderPathOrValue(range.max, env);
        }
        return result;
      }
    }
  }

  function renderIndexes(tc, env) {
    let result = '';
    if (tc && tc.indexes) {
      for (let idxName in tc.indexes) {
        let idx = tc.indexes[idxName];
        if (Array.isArray(idx)) {
          idx.forEach(i => result += renderIndex(i, env));
        }
        else {
          result += renderIndex(idx, env);
        }
      }
    }
    return result;

    function renderIndex(idx, env) {
      let childEnv = increaseIndent(env);
      let result = '\nCREATE ';
      if (idx.kind === 'index') {
        if (idx.unique) {
          result += 'UNIQUE ';
        }
        result += 'INDEX ' + quoteSqlId(idx.name.id) + ' ON (' + renderArray(idx.columns) + ')';
        if (idx.sort) {
          result += ' ' + renderPathOrValue(idx.sort, env);
        }
      }
      else if (idx.kind === 'fulltextindex') {
        result += 'FULLTEXT INDEX ' + quoteSqlId(idx.name.id) + ' ON (' + renderArray(idx.columns) + ')';
        if (idx.language) {
          if (idx.language.column) {
            result += '\n' + childEnv.indent + 'LANGUAGE COLUMN ' + renderPathOrValue(idx.language.column, env);
          }
          if (idx.language.detection) {
            result += '\n' + childEnv.indent + 'LANGUAGE DETECTION (' + renderArray(idx.language.detection) + ')'
          }
        }
        if (idx.mimeTypeColumn) {
          result += '\n' + childEnv.indent + 'MIME TYPE COLUMN ' + renderPathOrValue(idx.mimeTypeColumn, env);
        }
        if (idx.fuzzySearchIndex) {
          result += '\n' + childEnv.indent + 'FUZZY SEARCH INDEX ' + renderPathOrValue(idx.fuzzySearchIndex, env);
        }
        if (idx.phraseIndexRatio) {
          result += '\n' + childEnv.indent + 'PHRASE INDEX RATIO ' + renderPathOrValue(idx.phraseIndexRatio, env);
        }
        if (idx.configuration) {
          result += '\n' + childEnv.indent + 'CONFIGURATION ' + renderPathOrValue(idx.configuration, env);
        }
        if (idx.textAnalysis) {
          result += '\n' + childEnv.indent + 'TEXT ANALYSIS ' + renderPathOrValue(idx.textAnalysis, env);
        }
        if (idx.searchOnly) {
          result += '\n' + childEnv.indent + 'SEARCH ONLY ' + renderPathOrValue(idx.searchOnly, env);
        }
        if (idx.fastPreprocess) {
          result += '\n' + childEnv.indent + 'FAST PREPROCESS ' + renderPathOrValue(idx.fastPreprocess, env);
        }
        if (idx.mimeType) {
          result += '\n' + childEnv.indent + 'MIME TYPE ' + renderPathOrValue(idx.mimeType, env);
        }
        if (idx.tokenSeparators) {
          result += '\n' + childEnv.indent + 'TOKEN SEPARATORS ' + renderPathOrValue(idx.tokenSeparators, env);
        }
        if (idx.textMining) {
          if (idx.textMining.state) {
            result += '\n' + childEnv.indent + 'TEXT MINING ' + renderPathOrValue(idx.textMining.state, env);
          }
          if (idx.textMining.config) {
            result += '\n' + childEnv.indent + 'TEXT MINING CONFIGURATION ' + renderPathOrValue(idx.textMining.config, env);
          }
          if (idx.textMining.overlay) {
            result += '\n' + childEnv.indent + 'TEXT MINING CONFIGURATION OVERLAY ' + renderPathOrValue(idx.textMining.overlay, env);
          }
        }
        if (idx.changeTracking) {
          let ct = idx.changeTracking;
          result += '\n' + childEnv.indent + renderPathOrValue(ct.mode);
          if (ct.asyncSpec) {
            let asp = ct.asyncSpec;
            result += ' FLUSH ';
            if (asp.queue) {
              result += renderPathOrValue(asp.queue, env) + ' ';
            }
            if (asp.minutes) {
              result += 'EVERY ' + renderPathOrValue(asp.minutes, env) + ' MINUTES';
              if (asp.documents) {
                result += ' OR ';
              }
            }
            if (asp.documents) {
              result += 'AFTER ' + renderPathOrValue(asp.documents, env) + ' DOCUMENTS';
            }
          }
        }
      }
      result += ';'
      return result;

      function renderArray(arr) {
        let r = '', i = 0;
        arr.filter(v => !v._ignore).forEach(v => {
          if (i > 0) {
            r += ',\n' + increaseIndent(childEnv).indent;
          }
          r += renderPathOrValue(v, env);
          if (v.sort) {
            r += ' ' + renderPathOrValue(v.sort, env);
          }
          i++;
        });
        return r;
      }
    }
  }


  // Render a projection entity. Return the resulting source string.
  // NOTE: Not actually used for now, because forHana is always applied first, converting projections to views.
  function renderProjection(art, env) {
    let childEnv = increaseIndent(env);
    let result = env.indent + 'CREATE VIEW ' + quoteSqlId(absoluteCdsName(art.name.absolute)) + ' AS SELECT\n';
    result += Object.keys(art.elements).map(name => renderViewOrProjectionElement(art.elements[name], childEnv))
                                       .filter(s => s != '')
                                       .join(',\n') + '\n';
    result += env.indent + 'FROM ' + renderSourcePathWithAlias(art.source, art) + ';';
    return result;
  }

  // Render the source of a query, which may either be a path with an alias or a join operation,
  // as seen from artifact 'art'.
  // Returns the source as a string.
  function renderViewSource(source, art, env) {
    if (source instanceof Array) {
      // Join operations in parentheses
      if (source.length != 1) {
        throw new Error('Expecting only one join operation: ' + source);
      }
      return `${renderViewSource(source[0], art, env)}`;
    } else if (source.op && source.op.val == 'join') {
      // One join operation, possibly with ON-condition
      let result = `${renderViewSource(source.args[0], art, env)} ${renderJoinOp(source.join).toUpperCase()} ${renderViewSource(source.args[1], art, env)}`;
      if (source.on) {
        result += ` ON ${renderExpressionOrCondition(source.on)}`;
      }
      // Always put parentheses around joins for readability (other than toCdl)
      return `(${result})`;
    } else if (source.op && source.op.val == 'query') {
      // sub-select
      let result = `(${renderQuery(source, art, false, increaseIndent(env))})`;
      if (source.name && !source.name.calculated) {
        // Source had an alias - render it
        result += ' as ' + quoteSqlId(source.name.id);
      }
      return result;
    } else {
      // Ordinary path, possibly with an alias
      return renderSourcePathWithAlias(source, art);
    }
  }

  // Render the source path of a projection or query, possibly with an alias, as seen from artifact 'art'.
  // Expects an object 'source' that has a 'path' and (in case of an alias) a 'name'.
  // Returns the name and alias as a string.
  function renderSourcePathWithAlias(source, art) {
    // Sanity checks
    if (!source.path || source.path.length < 1) {
      throw new Error('Expecting path in source of ' + art.name.absolute + ': ' + JSON.stringify(source, null, 2));
    }
    if (!source.path[0]._artifact) {
      throw new Error('Expecting first path step in source of ' + art.name.absolute + ' to be resolved: ' + JSON.stringify(source, null, 2));
    }
    if (source.path[0].where) {
      signal(error`"${art.name.absolute}": Filters in FROM are not supported for conversion to SQL`, source.location);
      return '';
    }
    // Start with the absolute name of the first path step
    let result = absoluteCdsName(source.path[0]._artifact.name.absolute);
    // Add any paths that may follow after that (separating the artifact name from the rest by ':' !)
    for (let i = 1; i < source.path.length; i++) {
      if (source.path[i]._artifact && source.path[i]._artifact.kind != 'element') {
        // Still part of the artifact name, just append with dots
        result += '.' + source.path[i].id;
      } else {
        // Path continues with elements - complain if it has a filter
        if (source.path[i].where) {
          signal(error`"${art.name.absolute}": Filters in FROM are not supported for conversion to SQL`, source.location);
          return '';
        }
        if (result.includes(':')) {
          // We are already in the elements part of a path - append '.' and quoted id
          result += '.' + quoteSqlId(source.path[i].id);
        } else {
          // We have just left the artifact and entered elements - quote artifact name, append ':' and quoted id
          result = quoteSqlId(result) + ':' + quoteSqlId(source.path[i].id);
        }
      }
    }
    // Quote if not yet done so
    if ((options.toSql.names !== 'flat' && !result.startsWith('"'))
      || (result.includes('.') && !result.includes(':'))) {
      result = quoteSqlId(result);
    }

    if (source.name && !source.name.calculated) {
      // Source had an alias - render it
      result += ' AS ' + quoteSqlId(source.name.id);
    }
    return result;
  }

  // Render a single view or projection element 'elm', as it occurs in a select list or projection list,
  // possibly with annotations. Return the resulting source string (no trailing LF).
  function renderViewOrProjectionElement(elm, env) {
    // Ignore if forHana says so, or if it is an association
    if (elm._ignore) {
      return '';
    }
    if (isAssociation((elm._finalType || elm).type)) {
      return '';
    }
    let elementPath = renderExpressionOrCondition(elm.value, env, true);
    if (elm._typeIsExplicit) {
      // FIXME: We may want to wrap a cast around 'elementPath' in this case?
    }
    let result = env.indent + elementPath
    if (!elm.viaAll && !elm.name.calculated) {
      result += ' AS ' + quoteSqlId(elm.name.id);
    }
    return result;
  }

  // Render a view
  function renderView(art, env) {
    let result = env.indent + 'CREATE VIEW ' + quoteSqlId(absoluteCdsName(art.name.absolute))
           + ' AS ' + renderQuery(art.query, art, true, env);
    let childEnv = increaseIndent(env);
    let associations = Object.keys(art.elements).filter(name => isAssociation(art.elements[name].type))
                                                .map(name => renderAssociationElement(art.elements[name], childEnv))
                                                .filter(s => s != '')
                                                .join(',\n');
    if (associations != '') {
      result += env.indent + '\nWITH ASSOCIATIONS (\n' + associations + '\n';
      result += env.indent + ')';
    }
    result += ';';
    return result;
  }

  // Render a query 'query', i.e. a select statement with where-condition etc, possibly as part of artifact 'art'.
  // If 'isLeadingQuery' is true, mixins of 'art' are also rendered into the query.
  // FIXME: No support for MIXINs yet.
  // FIXME: currently only selection from multiple sources is supported, no JOIN yet, no UNION yet
  function renderQuery(query, art, isLeadingQuery, env) {
    let result = '';
    if(Array.isArray(query)) {
      result = `(${renderQuery(query[0], art, isLeadingQuery, env)})`;
    } else if (query.op && query.op.val == 'query') {
      let childEnv = increaseIndent(env);
      result += 'SELECT' + ((query.quantifier && query.quantifier.val) ? ` ${ query.quantifier.val.toUpperCase() }\n` : '\n');
      result += Object.keys(query.elements).map(name => renderViewOrProjectionElement(query.elements[name], childEnv))
                                           .filter(s => s != '')
                                           .join(',\n') + '\n';
      result += `${env.indent}FROM ${query.from.map(source => renderViewSource(source, art, env)).join(', ')}`;
    } else if (query.op && query.op.val == 'subquery') {
      // Magic special case: Subquery in parentheses can have ORDER BY, LIMIT and OFFSET outside the parentheses.
      result += `(${renderQuery(query.args[0][0], art, isLeadingQuery, env)})`;
    } else if (query.op && ['union', 'unionAll', 'intersect', 'except'].includes(query.op.val)) {
      // Ordinary query operators (first may be leading query)
      result += `${renderQuery(query.args[0], art, isLeadingQuery, env)}`
      result += `\n${env.indent}${query.op.val.replace('All', ' all').toUpperCase()} ${renderQuery(query.args[1], art, false, env)}`;
    } else {
      throw new Error('Unexpected query operation ' + query.op.val);
    }
    if (query.where) {
      result += `\n${env.indent}WHERE ${renderExpressionOrCondition(query.where, env)}`;
    }
    if (query.groupBy) {
      result += `\n${env.indent}GROUP BY ${query.groupBy.map(exprOrCond => renderExpressionOrCondition(exprOrCond, env)).join(', ')}`;
    }
    if (query.having) {
      result += `\n${env.indent}HAVING ${renderExpressionOrCondition(query.having, env)}`;
    }
    if (query.orderBy) {
      result += `\n${env.indent}ORDER BY ${query.orderBy.map(entry => renderOrderByEntry(entry, env)).join(', ')}`;
    }
    if (query.limit) {
      result += `\n${env.indent}LIMIT ${renderPathOrValue(query.limit, env)}`;
    }
    if (query.offset) {
      result += `\n${env.indent}OFFSET ${renderPathOrValue(query.offset, env)}`;
    }
    return result;
  }

  // Render one entry of a query's ORDER BY clause (which always has a 'value' expression, and may
  // have a 'sort' property for ASC/DESC and a 'nulls' for FIRST/LAST
  function renderOrderByEntry(entry, env) {
    let result = renderExpressionOrCondition(entry.value, env);
    if (entry.sort) {
      result += ` ${entry.sort.val.toUpperCase()}`;
    }
    if (entry.nulls) {
      result += ` NULLS ${entry.nulls.val.toUpperCase()}`;
    }
    return result;
  }

  // Render a type.
  // Return the resulting source string.
  function renderType(art, env) {
    // Only HANA table types are SQL-relevant
    if (!art.dbType) {
      return '';
    }
    let result = env.indent + 'CREATE TYPE ' + quoteSqlId(absoluteCdsName(art.name.absolute)) + ' AS TABLE (\n';
    let childEnv = increaseIndent(env);
    if (art._finalType.elements) {
      // Structured type or annotation with anonymous struct type
      result += Object.keys(art._finalType.elements).map(name => renderElement(art._finalType.elements[name], childEnv))
                                                    .filter(s => s != '')
                                                    .join(',\n') + '\n';
      result += env.indent + ');';
    } else {
      // Non-structured HANA table type
      signal(error`"${art.name.absolute}": HANA table types must have structured types for conversion to SQL`, art.location);
      return '';
    }
    return result;
  }

  // Render a reference to the final type used by 'elm' (named or inline)
  function renderTypeReference(elm) {
    let result = '';

    // Array type: Not supported with SQL
    if (elm._finalType.items) {
      signal(error`"${elm._main.name.absolute}.${elm.name.element}": Array types are not supported for conversion to SQL`, elm.location);
      return result;
    }

    // Anonymous structured type: Not supported with SQL (but shouldn't happen anyway after forHana flattened them)
    if (!elm._finalType.type) {
      if (!elm._finalType.elements) {
        throw new Error('Missing type of: ' + elm.name.id);
      }
      signal(error`"${elm._main.name.absolute}.${elm.name.element}": Anonymous structured types are not supported for conversion to SQL`, elm.location);
      return result;
    }

    // Association type
    if (elm._finalType.type.absolute == 'cds.Association' || elm._finalType.type.absolute == 'cds.Composition') {
      // We can't do associations yet
      signal(error`"${elm._main.name.absolute}.${elm.name.element}": Association and composition types are not yet supported for conversion to SQL`, elm.location);
      return result;
    }

    // If we get here, it must be a primitive (i.e. builtin) type
    if (elm._finalType.type._artifact.builtin) {
      // Special magic: For members of derived type chains ending in 'cds.UUID', '_finalType'
      // points directly to 'UUID' and not to the derived type _having_ type 'UUID'. Although
      // 'forHana' has adapted the last type in the chain to now have type 'String(36)',
      // the other members of the chain don't benefit from that, so we have to check here again.
      if (elm._finalType.type._artifact.name.absolute == 'cds.UUID') {
        return 'NVARCHAR(36)';
      }
      // cds.Integer => render as INTEGER (no quotes)
      result += renderBuiltinType(elm._finalType.type._artifact);
    } else {
      throw new Error('Unexpected non-primitive type of: ' + elm._main.name.absolute + '.' + elm.name.element);
    }
    result += renderTypeParameters(elm._finalType);
    return result;
  }

  // Render the name of a builtin CDS type
  function renderBuiltinType(type) {
    const cdsToSql = {
      // CDS builtin types
      'cds.String': 'NVARCHAR',
      'cds.LargeString' : 'NCLOB',
      'cds.Binary': 'VARBINARY',
      'cds.LargeBinary': 'BLOB',
      'cds.Decimal': 'DECIMAL',
      'cds.DecimalFloat': 'DECIMAL',
      'cds.Integer64': 'BIGINT',
      'cds.Integer': 'INTEGER',
      'cds.Double': 'DOUBLE',
      'cds.Date': 'DATE',
      'cds.Time': 'TIME',
      'cds.DateTime': 'SECONDDATE',
      'cds.Timestamp': 'TIMESTAMP',
      'cds.Boolean': 'BOOLEAN',
      // HANA specific builtin types
      'hana.ALPHANUM': 'ALPHANUM',
      'hana.SMALLINT': 'SMALLINT',
      'hana.TINYINT': 'TINYINT',
      'hana.SMALLDECIMAL': 'SMALLDECIMAL',
      'hana.REAL': 'REAL',
      'hana.CHAR': 'CHAR',
      'hana.NCHAR': 'NCHAR',
      'hana.VARCHAR': 'VARCHAR',
      'hana.CLOB': 'CLOB',
      'hana.BINARY': 'BINARY',
      'hana.ST_POINT': 'ST_POINT',
      'hana.ST_GEOMETRY': 'ST_GEOMETRY',
      // Obsolete names from HANA CDS, for downward compatibility
      'cds.BinaryFloat': 'DOUBLE',
      'cds.LocalDate': 'DATE',
      'cds.LocalTime': 'TIME',
      'cds.UTCDateTime': 'SECONDDATE',
      'cds.UTCTimestamp': 'TIMESTAMP',
    };

    let result = cdsToSql[type.name.absolute];
    if (!result) {
      throw Error('Unknown primitive type: ' + JSON.stringify(type));
    }
    return result;
  }

  // Render the nullability of an element or parameter (can be unset, true, or false) 
  function renderNullability(obj /* , env */) {
    if (!obj.notNull) {
      // Attribute not set at all
      return '';
    }
    return obj.notNull.val ? ' NOT NULL' : ' NULL';
  }

  // Render (primitive) type parameters of element 'elm', i.e. 
  // length, precision and scale (even if incomplete), plus any other unknown ones.
  function renderTypeParameters(elm) {
    let params = [];
    // Length, precision and scale (even if incomplete)
    if (elm.length) {
      params.push(elm.length.val);
    }
    if (elm.precision) {
      params.push(elm.precision.val);
    }
    if (elm.scale) {
      params.push(elm.scale.val);
    }
    // Additional type parameters
    for (let arg of elm.typeArguments || []) {
      params.push(arg.val);
    }
    return params.length == 0 ? '' : '(' + params.join(', ') + ')';
  }

  // Render a single value (i.e. something that has 'path' or 'literal' and 'val')
  // (no trailing LF, don't indent if inline)
  function renderPathOrValue(v, env, inline=true) {
    let result = inline ? '' : env.indent;
    if (v.path) {
      // E.i
      return result + renderPath(v.path, env, v);
    } else if (v.literal == 'string') {
      // 'foo', with proper escaping
      return result + "'" + v.val.replace(/'/g, "''") + "'";
    } else if (v.literal == 'enum') {
      // #foo
      // FIXME: We can't do enums yet because they are not resolved (and we don't bother finding their value by hand)
      signal(error`Enum values are not yet supported for conversion to SQL`, v.location);
      return '';
    } else if (v.literal == 'hex') {
      // x'f000'
      return result + "x'" + v.val + "'";
    } else if (v.literal == 'date' || v.literal == 'time' || v.literal == 'timestamp') {
      // date'2017-11-02'
      return result + v.literal + "'" + v.val + "'";
    } else if (v.literal == 'struct') {
      // { foo: 1 }
      // We can't do structs yet
      // FIXME: Can that happen at all outside of annotations?
      signal(error`: Struct values are not supported for conversion to SQL`, v.location);
      return '';
    } else if (v.literal == 'array') {
      // [ 'foo', 'bar' ]
      // We can't do arrays yet
      // FIXME: Can that happen at all outside of annotations?
      signal(error`: Array values are not supported for conversion to SQL`, v.location);
      return '';
    } else {
      // 17.42, null, true
      return result + String(v.val).toUpperCase();
    }
  }

  // Render a path or query path (provided as an array of path steps, possibly with filters)
  function renderPath(path, env, art) {
    // Magic special case: SQL functions that have no parentheses (CURRENT_*) are not recognized as
    // function expressions by the parser - instead they appear here as paths of length 1 with a
    // 'builtin' artifact.
    if (path.length == 1 && path[0]._artifact && path[0]._artifact.kind == 'builtin') {
      if (options.forHana) {
        // HANA-specific translation of '$now' and '$user'
        // FIXME: This should rather happen in forHana, but it is non-trivial to catch all the different
        // flavors in which a path can be used there (e.g. for 'foo.origin.path', we would have to modify
        // 'foo' to have a 'foo.value'). So much easier to do it here...
        if (path[0].id == '$now') {
          return 'CURRENT_TIMESTAMP';
        } else if (path[0].id == '$user') {
          return "SESSION_CONTEXT('XS_APPLICATIONUSER')";
        }
      }
      return String(path[0].id).toUpperCase();
    }

    // FIXME: Not the most elegant solution to do that here: filter out initial '$projection' (because SQL
    // neither understands nor needs it).
    if (options.forHana && path[0].id === '$projection') {
      return renderPath(path.slice(1), env);
    }

    // transform $self in the beginning of a path to the current artifact absolute name in case of forHana
    if (options.forHana && path[0].id === '$self' && path.length > 1) {
      return `${quoteSqlId(absoluteCdsName(art.absolute))}.${renderPath(path.slice(1), env)}`
    }
    return path.map(step => {
      let result = quoteSqlId(step.id);
      if (step.where) {
        result += '[' + (step.cardinality ? step.cardinality.targetMax.val + ': ' : '') + renderExpressionOrCondition(step.where, env, true) + ']';
      }
      return result;
    }).join('.');
  }

  // Returns a copy of 'env' with increased indentation
  function increaseIndent(env) {
    return Object.assign({}, env, { indent: env.indent + '  ' });
  }

  // Returns a copy of 'env' with decreased indentation
  function decreaseIndent(env) {
    return Object.assign({}, env, { indent: env.indent.substring(2) });
  }

  // Return 'name' in the form of an absolute CDS name - for the 'hdbcds' naming convention,
  // this means converting '.' to '::' on the border between namespace and top-level artifact.
  // For all other naming conventions, this is a no-op.
  function absoluteCdsName(name) {
    if (options.toSql.names != 'hdbcds') {
      return name;
    }
    let topLevelName = getTopLevelArtifactNameOf(name, model);
    let namespaceName = getParentNameOf(topLevelName);
    if (namespaceName) {
      return `${namespaceName}::${name.substring(namespaceName.length + 1)}`;
    }
    return name;
  }

  // Return 'name' with appropriate "-quotes.
  // FIXME: Should only quote where necessary (examining the id for magic characters and reserved
  // keywords) - for now, simply quote everything
  // Additionally perform the following conversions on 'name'
  // If 'options.toSql.names' is 'flat'
  //   - replace '.' or '::' by '_' and convert to uppercase
  // else if 'options.toSql.names' is 'deep'
  //   - replace '::' by '.'
  function quoteSqlId(name) {
    if (options.toSql.names == 'flat') {
      name = name.replace(/(\.|::)/g, '_');
      if (name.match(/\W/g)
        || name.match(/^\d/) || name.match(/^_/)
        || keywords.sql92.includes(name.toUpperCase())
        || keywords.functions.includes(name.toUpperCase()))
        return `"${name.replace(/"/g, '""').toUpperCase()}"`
      else
        return name;
    }
    else if (options.toSql.names == 'deep') {
      name = name.replace(/::/g, '.');
    }  
    return `"${name.replace(/"/g, '""')}"`;
  }
}

module.exports = {
  toSqlDdl,
};
