"use strict";

const { CompilationError, hasErrors, sortMessages } = require('../base/messages');
const { mergeOptions, getTopLevelArtifactNameOf, getParentNameOf, getLastPartOf,
        getLastPartOfRef, getParentNamesOf } = require('../model/modelUtils');
const { compactModel } = require('../json/to-csn');
const keywords = require('../base/keywords');

// Render the CSN model 'model' to CDS source text. One source is created per
// top-level artifact. Return a dictionary of top-level artifacts
// by their names, like this:
// { "foo" : "using XY; context foo {...};",
//   "bar::wiz" : "namespace bar::; entity wiz {...};"
// }
// If 'options.toHana' is set, render HANA-ish source dialect (currently
// only affects translation of '$self.foo' in paths and ::-ish namespace declarations)
// FIXME: This comment no longer tells the whole truth
function toCdsSourceNew(model, options) {
  // Merge options (arguments first, then model options)
  options = mergeOptions(model.options, options);
  let flatNames = options.forHana && options.forHana.names == 'flat';
  let hdbcdsNames = options.forHana && options.forHana.names == 'hdbcds';
  let result = Object.create(null);

  // FIXME: This should happen in the caller
  let csn = compactModel(model);

  // Create artificial namespace objects, so that each artifact has parents up to top-level.
  // FIXME: This should actually only be necessary for toHana (because that wants hierarchical
  // rendering). For CDL, we could just render each artifact top-level, with a dotted name.
  for (let artifactName in csn.definitions) {
    for (let parentName of getParentNamesOf(artifactName)) {
      if (!csn.definitions[parentName]) {
        csn.definitions[parentName] = {
          kind : 'namespace',
        };
      }
    }
  }

  // Render each top-level artifact on its own
  for (let artifactName in getTopLevelArtifacts()) {
    // This environment is passed down the call hierarchy, for dealing with
    // indentation and name resolution issues 
    let env = createEnv();
    let sourceStr = renderArtifact(artifactName, csn.definitions[artifactName], env); // Must come first because it populates 'env.topLevelAliases'
    if (sourceStr != '') {
      result[flatNames ? uppercaseAndUnderscore(artifactName) : artifactName]
        = renderNamespaceDeclaration(artifactName, env) + renderUsings(artifactName, env) + sourceStr;
    }
  }
  
  // If there are unapplied 'extend' and 'annotate' statements, render them separately
  // FIXME: Clarify if we should also do this for HANA (probably not?)
  if (csn.extensions) {
    let env = createEnv();
    let sourceStr = renderUnappliedExtensions(csn.extensions, env);
    result.unappliedExtensions = renderUsings('', env) + sourceStr;
  }

  // Throw up if we have errors
  if (hasErrors(model.messages)) {
    throw new CompilationError(sortMessages(model.messages), model);
  }
  return result;

  // Render unapplied 'extend' and 'annotate' statements from the 'extensions array'
  function renderUnappliedExtensions(extensions, env) {
    return extensions.map(ext => {
      // Top-level annotations of the artifact
      let result = renderAnnotationAssignments(ext, env);
      result += `annotate ${ext.annotate}`;
      // Element extensions and annotations (possibly nested)
      if (ext.elements) {
        result += renderElementExtensions(ext.elements, env);
      }
      // Action annotations
      if (ext.actions) {
        result += ' actions {\n';
        let childEnv = increaseIndent(env);
        for (let name in ext.actions) {
          let action = ext.actions[name];
          result += renderAnnotationAssignments(action, childEnv) + childEnv.indent + quoteId(name);
          // Action parameter annotations
          if (action.params) {
            result += '(\n';
            let grandChildEnv = increaseIndent(childEnv);
            let paramAnnotations = []
            for (let paramName in action.params) {
              paramAnnotations.push(renderAnnotationAssignments(action.params[paramName], grandChildEnv) + grandChildEnv.indent + quoteId(paramName));
            }
            result += paramAnnotations.join(',\n') + '\n' + childEnv.indent + ')'
          }
          result += ';\n'
        }
        result += env.indent + '}'
      }
      result += ';';
      return result;
    }
    ).join('\n');
  }

  // Render the elements-specific part of an 'extend' or 'annotate' statement for an element dictionary
  // 'elements' (assuming that the surrounding parent has just been rendered, without trailing newline).
  // Return the resulting source string, ending without a trailing newline, too.
  function renderElementExtensions(elements, env) {
    let result = ' {\n';
    let childEnv = increaseIndent(env);
    for (let name in elements) {
      let elem = elements[name];
      result += renderAnnotationAssignments(elem, childEnv) + childEnv.indent + quoteId(name);
      if (elem.elements) {
        result += renderElementExtensions(elem.elements, childEnv);
      }
      result += ';\n'
    }
    result += env.indent + '}'
    return result;
  }

  // Render an artifact. Return the resulting source string.
  function renderArtifact(artifactName, art, env) {
    // Ignore whole artifacts if toHana says so
    if (art._ignore) {
      return '';
    }
    switch (art.kind) {
      case 'entity':
      case 'view':
        // FIXME: For HANA CDS, we need to replace $self at the beginning of paths in association ON-condition
        // by the full name of the artifact we are rendering (should actually be done by forHana, but that is
        // somewhat difficult because this kind of absolute path is quite unusual). In order not to have to pass
        // the current artifact name down through the stack to renderExpr, we just put it nto the env.
        env.currentArtifactName = artifactName;
        if (art.query) {
          // FIXME: Handle projections separately for now if they have actions or functions
          // (because views can't have those yet). Unless we are rendering for HANA, which doesn't have actions, anyway
          if (art.actions && !options.forHana) {
            return renderProjection(artifactName, art, env);
          }
          let select = leadingQuerySelect(art.query);
          if (!select.columns) {
            return renderProjection(artifactName, art, env);
          }
          else {
            return renderView(artifactName, art, env);
          }
        } else {
          return renderEntity(artifactName, art, env);
        }
      case 'context':
      case 'service':
        return renderContext(artifactName, art, env);
      case 'namespace':
        return renderNamespace(artifactName, art, env);
      case 'type':
      case 'annotation':
        return renderTypeOrAnnotation(artifactName, art, env);
      case 'action':
      case 'function':
        return renderActionOrFunction(artifactName, art, env);
      default:
        throw new Error('Unknown artifact kind: ' + art.kind);
    }
  }

  // Return a dictionary with the direct sub-artifacts of the artifact with name 'artifactName' in the csn
  function getSubArtifacts(artifactName) {
    let prefix = artifactName + '.';
    let result = Object.create(null);
    for (let name in csn.definitions) {
      // We have a direct child if its name starts with prefix and contains no more dots
      if (name.startsWith(prefix) && !name.substring(prefix.length).includes('.')) {
        result[getLastPartOf(name)] = csn.definitions[name];
      }
    }
    return result;
  }
/* FIXME: Not yet required
  // Returns the artifact or element that constitutes the final type of
  // construct 'node', i.e. the object in which we would find type properties for
  // 'node'. Note that this may well be 'node' itself.
  function getFinalTypeOf(node) {
    if (node && node.type) {
      if (isBuiltinType(node.type)) {
        return node;
      }
      return getFinalTypeOf(node.type);
    }
    return node;
  }

  // Resolve path array 'ref' against artifact 'base' (or against 'csn.definitions'
  // if no 'base' given).
  // Return the resulting artifact or element (or 'undefined' if not found).
  function resolveRef(ref, base) {
    let result = base;
    for (let i = 0; i < ref.length; i++) {
      let pathStep = ref[i].id || ref[i];
      // Only first path step may be looked up in 'definitions'
      if (i == 0 && !base) {
        result = csn.definitions[pathStep];
        continue;
      }
      // Structured type
      else if (result && result.elements) {
        result = getFinalTypeOf(result.elements[pathStep]);
      }
      // Association
      else if (result && result.target) {
        result = resolveRef([pathStep], csn.definitions[result.target]);
      }
      // Not resolvable
      else {
        return undefined;
      }
    }
    return result;
  }
*/

  // Return true if 'typeName' is the name of a builtin type
  function isBuiltinType(typeName) {
    // FIXME: Rather than checking a list of builtin types, we just rely on the fact
    // that in a valid model, the only types that do not occur in 'definitions' are
    // the builtin ones.
    return !csn.definitions[typeName];
  }

  // Return a string array with the names of the magic variables defined in the
  // compiler (e.g. CURRENT_DATE, $now, depending on options also CURRENT_CONNECTION etc for HANA)
  function getMagicVariables() {
    // FIXME: Retrieve directly from compiler instead, or from the list used to decide quoting-necesity
    return Object.keys(model.$magicVariables.artifacts);
  }

  // Render a context or service. Return the resulting source string.
  function renderContext(artifactName, art, env) {
    let result = renderAnnotationAssignments(art, env);
    let childEnv = increaseIndent(env);
    result += env.indent + art.kind + ' ' + env.namePrefix + quoteId(getLastPartOf(artifactName)) + ' {\n';
    let subArtifacts = getSubArtifacts(artifactName);
    for (let name in subArtifacts) {
      result += renderArtifact(artifactName + '.' + name, subArtifacts[name], childEnv);
    }
    return result + env.indent + '};\n';
  }

  // Render a namespace. Return the resulting source string.
  function renderNamespace(artifactName, art, env) {
    // We currently do not render anything for a namespace, we just append its id to
    // the environment's current name prefix and descend into its children
    let result = '';
    let childEnv = addNamePrefix(env, getLastPartOf(artifactName));
    let subArtifacts = getSubArtifacts(artifactName);
    for (let name in subArtifacts) {
      result += renderArtifact(artifactName + '.' + name, subArtifacts[name], childEnv);
    }
    return result;
  }

  // Render a (non-projection, non-view) entity. Return the resulting source string.
  function renderEntity(artifactName, art, env) {
    let result = renderAnnotationAssignments(art, env);
    let childEnv = increaseIndent(env);
    result += env.indent + (art.abstract ? 'abstract ' : '') + 'entity ' + renderArtifactName(artifactName, env);
    let parameters = Object.keys(art.params || []).map(name => renderParameter(name, art.params[name], childEnv)).join(',\n');
    result += (parameters == '') ? '' : ' (\n' + parameters + '\n' + env.indent + ')';
    if (art.includes) {
      // Includes are never flattened (don't exist in HANA)
      result += ' : ' + art.includes.map(name => renderAbsoluteNameWithQuotes(name, env)).join(', ');
    }
    result += ' {\n';
    for (let name in art.elements) {
      result += renderElement(name, art.elements[name], childEnv);
    }
    result += env.indent + '}';
    result += renderActionsAndFunctions(art, env) + renderTechnicalConfiguration(art.technicalConfig, env) + ';\n';
    return result;
  }

  // Render the 'technical configuration { ... }' section 'tc' of an entity.
  // Return the resulting source string.
  function renderTechnicalConfiguration(tc, env) {
    let result = '';
    let childEnv = increaseIndent(env);

    if (!tc) {
      return result;
    }

    // FIXME: How to deal with non-HANA technical configurations? We should probably just iterate all entries
    // in 'tc' that we find and render them all (is it syntactically allowed yet to have more than one?)
    tc = tc.hana;
    if (!tc) {
      throw new Error('Expecting a HANA technical configuration');
    }
    result += '\n' + env.indent + 'technical ' + (tc.calculated ? '' : 'hana ') + 'configuration {\n';

    // Fixed parts belonging to the table (includes migration, store type, unload prio, extended storage,
    // auto merge, partitioning, ...)
    if (tc.tableSuffix) {
      // Unlike SQL, CDL and HANA CDS require a semicolon after each table-suffix part
      // (e.g. `migration enabled; row store; ...`). In order to keep both
      // the simplicity of "the whole bandwurm is just one expression that can be
      // rendered to SQL without further knowledge") and at the same time telling
      // CDS about the boundaries, the compactor has put each part into its own `xpr`
      // object. Semantically equivalent because a "trivial" SQL renderer would just
      // concatenate them.
      for (let xpr of tc.tableSuffix) {
        result += childEnv.indent + renderExpr(xpr, childEnv) + ';\n';
      }
    }

    // Indices and full-text indices
    for (let idxName in tc.indexes || {}) {
      if (tc.indexes[idxName][0] instanceof Array) {
        // FIXME: Should we allow multiple indices with the same name at all?
        for (let index of tc.indexes[idxName]) {
          result += childEnv.indent + renderExpr(index, childEnv) + ';\n';
        }
      }
      else {
        result += childEnv.indent + renderExpr(tc.indexes[idxName], childEnv) + ';\n';
      }
    }
    // Fuzzy search indices
    for (let columnName in tc.fzindexes || {}) {
      if (tc.fzindexes[columnName][0] instanceof Array) {
        // FIXME: Should we allow multiple fuzzy search indices on the same column at all?
        // And if not, why do we wrap this into an array?
        for (let index of tc.fzindexes[columnName]) {
          result += childEnv.indent + renderExpr(fixFuzzyIndex(index, columnName), childEnv) + ';\n';
        }
      }
      else {
        result += childEnv.indent + renderExpr(fixFuzzyIndex(tc.fzindexes[columnName], columnName), childEnv) + ';\n';
      }
    }
    result += env.indent + '}';
    return result;

    // Fuzzy indices are stored in compact CSN as they would appear in SQL after the column name,
    // i.e. the whole line in SQL looks somewhat like this:
    //   s nvarchar(10) FUZZY SEARCH INDEX ON FUZZY SEARCH MODE 'ALPHANUM'
    // But in CDL, we don't write fuzzy search indices together with the table column, so we need
    // to insert the name of the column after 'ON' in CDS syntax, making it look like this:
    //   fuzzy search mode on (s) search mode 'ALPHANUM'
    // This function expects an array with the original expression and returns an array with the modified expression
    function fixFuzzyIndex(fuzzyIndex, columnName) {
      return fuzzyIndex.map(token => (token == 'on' ? { xpr: ['on', '(', { ref: columnName.split('.') }, ')'] } : token));
    }
  }

  // Render an element (of an entity, type or annotation, not a projection or view).
  // Return the resulting source string.
  function renderElement(elementName, elm, env) {
    // Ignore if toHana says so
    if (elm._ignore) {
      return '';
    }
    // Special handling for HANA CDS: Must omit the ':' before anonymous structured types (for historical reasons)
    let omitColon = (options.forHana && !elm.type && elm.elements);
    let result = renderAnnotationAssignments(elm, env);
    result += env.indent + (elm.virtual ? 'virtual ' : '') 
                         + (elm.key ? 'key ' : '')
                         + ((elm.masked && !elm._ignoreMasked)? 'masked ' : '')
                         + quoteOrUppercaseId(elementName) + (omitColon ? ' ' : ' : ')
                         + renderTypeReference(elm, env)
                         + renderNullability(elm);
    if (elm.default) {
      result += ' default ' + renderExpr(elm.default, env);
    }
    return result + ';\n';
  }

  // Return the SELECT of the leading query of query 'query'
  function leadingQuerySelect(query) {
    if (query.SELECT) {
      return query.SELECT;
    }
    // Sanity checks
    if (!query.SET || !query.SET.args || !query.SET.args[0]) {
      throw new Error(`Expecting set with args in query: ${JSON.stringify(query)}`);
    }
    return leadingQuerySelect(query.SET.args[0]);
  }

  // Render a projection entity. Return the resulting source string.
  function renderProjection(artifactName, art, env) {
    let result = renderAnnotationAssignments(art, env);
    let childEnv = increaseIndent(env);
    let select = leadingQuerySelect(art.query);
    result += env.indent + (art.abstract ? 'abstract ' : '') + 'entity ' + renderArtifactName(artifactName, env);
    result += ' as projection on ' + renderAbsolutePathWithAlias(select.from, env);
    if (select.columns) {
      result += ' {\n';
      result += select.columns.map(col => renderViewColumn(col, childEnv))
                              .filter(s => s != '')
                              .join(',\n') + '\n';
      result += env.indent + '}';
    }
    if (select.excluding) {
      result += ' excluding {\n' + select.excluding.map(id => `${childEnv.indent}${quoteOrUppercaseId(id)}`).join(',\n') + '\n';
      result += env.indent + '}';
    }
    result += renderActionsAndFunctions(art, env) + ';\n';
    result += renderQueryElementAnnotations(artifactName, art, env);
    return result;
  }

  // Render annotations that were extended to a query element of a view or projection (they only
  // appear in the view's 'elements', not in their 'columns', because the element itself may not
  // even be in 'columns', e.g. if it was expanded from a '*'). Return the resulting 'annotate'
  // statement or an empty string if none required.
  function renderQueryElementAnnotations(artifactName, art, env) {
    // For preparation, create a map from element names to column objects
    let columnMap = Object.create(null);
    let select = leadingQuerySelect(art.query);
    for (let col of select.columns||['*']) {
      // Ignore '*'
      if (col == '*') {
        continue;
      }
      // Column must have an alias or be a path - take last part of that as element name
      columnMap[col.as || getLastPartOfRef(col.ref)] = col;
    }
    // Now iterate elements - render an annotation if it is different from the column's
    let childEnv = increaseIndent(env);
    let result = '';
    for (let elemName in art.elements) {
      let elemAnnotations = '';
      let elem = art.elements[elemName];
      for (let name in elem) {
        if (!name.startsWith('@')) {
          continue;
        }
        let annotationValue = renderAnnotationValue(elem[name], childEnv);
        // Skip annotation if column has the same
        if (columnMap[elemName] && columnMap[elemName][name]
            && renderAnnotationValue(columnMap[elemName][name], childEnv) == annotationValue) {
          continue;
        }
        // Annotation names are never flattened
        elemAnnotations += `${childEnv.indent}${'@' + renderAbsoluteNameWithQuotes(name.substring(1), env)} : ${annotationValue}\n`;
      }
      if (elemAnnotations != '') {
        result += `${elemAnnotations}${childEnv.indent}${elemName};\n`;
      }
    }
    if (result != '') {
      result = `${env.indent}annotate ${renderArtifactName(artifactName, env)} with {\n${result}${env.indent}};\n`;
    }
    return result;
  }

  // Render the source of a query, which may be a path reference, possibly with an alias,
  // or a subselect, or a join operation, as seen from artifact 'art'.
  // Returns the source as a string.
  function renderViewSource(source, env) {
    // Sub-SELECT
    if (source.SELECT || source.SET) {
      let result = `(${renderQuery(source, false, increaseIndent(env))})`;
      if (source.as) {
        result += ` as ${quoteId(source.as)}`;
      }
      return result;
    }
    // JOIN
    else if (source.join) {
      // One join operation, possibly with ON-condition
      // FIXME: Clarify if join operators can be n-ary (assuming binary here)
      let result = `(${renderViewSource(source.args[0], env)} ${source.join} join ${renderViewSource(source.args[1], env)}`;
      if (source.on) {
        result += ` on ${renderExpr(source.on, env)}`;
      }
      result += `)`;
      return result;
    }
    // Ordinary path, possibly with an alias
    else {
      return renderAbsolutePathWithAlias(source, env);
    }
  }

  // Render a path that starts with an absolute name (as used e.g. for the source of a query),
  // with flat or deep names, depending on options. Expects an object 'path' that has a 'ref'.
  // Returns the name as a string.
  function renderAbsolutePath(path, env) {
    // Sanity checks
    if (!path.ref) {
      throw new Error('Expecting ref in path: ' + JSON.stringify(path));
    }
    // Determine the absolute name of the first artifact on the path (before any associations or element traversals)
    let firstArtifactName = path.ref[0].id || path.ref[0];
    let firstArtifact = csn.definitions[firstArtifactName];
    if (!firstArtifact) {
      throw new Error('Expecting first path step in path to be resolvable: ' + JSON.stringify(path));
    }
    let result = '';
    // Render the first path step (absolute name, with different quoting/flatness ..)
    if (flatNames) {
      result += renderAbsoluteNameFlat(firstArtifactName, env);
    } else {
      result += renderAbsoluteNameWithQuotes(firstArtifactName, env);
    }
    // Even the first step might have a filter
    if (path.ref[0].where) {
      result += `[${path.ref[0].cardinality ? (path.ref[0].cardinality.max + ': ') : ''}${renderExpr(path.ref[0].where, env)}]`;
    }
    // Add any path steps (possibly with filters) that may follow after that
    if (path.ref.length > 1) {
      result += `.${renderExpr({ref: path.ref.slice(1)}, env)}`;
    }
    return result;
  }

  // Render a path that starts with an absolute name (as used for the source of a query),
  // possibly with an alias, with flat or deep names, depending on options. Expects an object 'path' that has a
  // 'ref' and (in case of an alias) an 'as'. If necessary, an artificial alias
  // is created to the original implicit name.
  // Returns the name and alias as a string.
  function renderAbsolutePathWithAlias(path, env) {
    let result = renderAbsolutePath(path, env);
    // Take care of aliases
    let implicitAlias = getLastPartOfRef(path.ref);
    if (path.as) {
      // Source had an alias - render it
      result += ' as ' + quoteOrUppercaseId(path.as);
    }
    else if (getLastPartOf(result) != quoteOrUppercaseId(implicitAlias)) {
      // Render an artificial alias if the result would produce a different one
      result += ' as ' + quoteOrUppercaseId(implicitAlias);
    }
    return result;
  }

  // Render a single view or projection column 'col', as it occurs in a select list or
  // projection list within 'art', possibly with annotations.
  // Return the resulting source string (no trailing LF).
  function renderViewColumn(col, env) {
    // Ignore if toHana says so
    // FIXME: This probably needs to change ...
    if (col._ignore) {
      return '';
    }
    // Annotations and column
    let result = renderAnnotationAssignments(col, env);
    result += env.indent + renderExpr(col, env, true);
    // Explicit alias?
    if (col.as) {
      result += ' as ' + quoteOrUppercaseId(col.as);
    }
    // Explicit type provided for the view element?
    if (col.cast) {
      // Special case: Explicit association type is actually a redirect
      if (col.cast.target) {
        // Redirections are never flattened (don't exist in HANA)
        result += ' : redirected to ' + renderAbsoluteNameWithQuotes(col.cast.target, env);
      } else {
        result += ' : ' + renderTypeReference(col.cast, env);
      }
    }
    return result;
  }

  // Render a view
  function renderView(artifactName, art, env) {
    let result = renderAnnotationAssignments(art, env);
    result += env.indent + 'view ' + renderArtifactName(artifactName, env)
           + ' as ' + renderQuery(art.query, true, env);
    result += ';\n';
    result += renderQueryElementAnnotations(artifactName, art, env);
    return result;
  }

  // Render a query 'query', i.e. a select statement with where-condition etc.
  // If 'isLeadingQuery' is true, mixins, actions and functions of 'art' are
  // also rendered into the query.
  function renderQuery(query, isLeadingQuery, env) {
    let result = '';
    // Set operator, like UNION, INTERSECT, ...
    if (query.SET) {
      // First arg may be leading query
      result += `(${renderQuery(query.SET.args[0], isLeadingQuery, env)}`
      // FIXME: Clarify if set operators can be n-ary (assuming binary here)
      if (query.SET.op) {
        result += `\n${env.indent}${query.SET.op}${query.SET.all ? ' all' : ''} ${renderQuery(query.SET.args[1], false, env)}`;
      }
      result += ')';
      // Set operation may also have an ORDER BY and LIMIT/OFFSET (in contrast to the ones belonging to
      // each SELECT)
      if (query.SET.orderBy) {
        result += `${continueIndent(result, env)}order by ${query.SET.orderBy.map(entry => renderOrderByEntry(entry, env)).join(', ')}`;
      }
      if (query.SET.limit) {
        result += `${continueIndent(result, env)}${renderLimit(query.SET.limit, env)}`;
      }
      return result;
    }
    // Otherwise must have a SELECT
    else if (!query.SELECT) {
      throw new Error('Unexpected query operation ' + JSON.stringify(query));
    }
    let select = query.SELECT;
    let childEnv = increaseIndent(env);
    result += `select from ${renderViewSource(select.from, env)}`;
    if (isLeadingQuery && select.mixin) {
      result += ' mixin {\n'
      for (let name in select.mixin) {
        result += renderElement(name, select.mixin[name], childEnv);
      }
      result += env.indent + '} into'
    }
    result += select.distinct ? ' distinct' : '';
    result += ' {\n' +
              (select.columns||['*']).map(col => renderViewColumn(col, childEnv))
                                     .filter(s => s != '')
                                     .join(',\n') + '\n';
    result += env.indent + '}';
    if (select.excluding) {
      result += ' excluding {\n' + select.excluding.map(id => `${childEnv.indent}${quoteOrUppercaseId(id)}`).join(',\n') + '\n';
      result += env.indent + '}';
    }
    // FIXME: Currently, only projections can have actions and functions, but we cannot distinguish
    // a projection from a view any more
    if (isLeadingQuery) {
      result += renderActionsAndFunctions(query, env);
    }
    if (select.where) {
      result += `${continueIndent(result, env)}where ${renderExpr(select.where, env)}`;
    }
    if (select.groupBy) {
      result += `${continueIndent(result, env)}group by ${select.groupBy.map(expr => renderExpr(expr, env)).join(', ')}`;
    }
    if (select.having) {
      result += `${continueIndent(result, env)}having ${renderExpr(select.having, env)}`;
    }
    if (select.orderBy) {
      result += `${continueIndent(result, env)}order by ${select.orderBy.map(entry => renderOrderByEntry(entry, env)).join(', ')}`;
    }
    if (select.limit) {
      result += `${continueIndent(result, env)}${renderLimit(select.limit, env)}`;
    }
    return result;

    // Utility function to make sure that we continue with the same indentation in WHERE, GROUP BY, ... after a closing curly brace and beyond
    function continueIndent(result, env) {
      if (result.endsWith('}') || result.endsWith('})')) {
        // The preceding clause ended with '}', just append after that
        return ' ';
      } else {
        // Otherwise, start new line and indent normally
        return '\n' + increaseIndent(env).indent;
      }
    }

    // Render a query's LIMIT clause, which may have also have OFFSET.
    function renderLimit(limit, env) {
      let result = '';
      if (limit.rows !== undefined) {
        result += `limit ${renderExpr(limit.rows, env)}`;
      }
      if (limit.offset !== undefined) {
        result += `${result != '' ? '\n' + increaseIndent(env).indent : ''}offset ${renderExpr(limit.offset, env)}`;
      }
      return result;
    }
  }

  // Render one entry of a query's ORDER BY clause (which always has a 'value' expression, and may
  // have a 'sort' property for ASC/DESC and a 'nulls' for FIRST/LAST
  function renderOrderByEntry(entry, env) {
    let result = renderExpr(entry, env);
    if (entry.sort) {
      result += ` ${entry.sort}`;
    }
    if (entry.nulls) {
      result += ` nulls ${entry.nulls}`;
    }
    return result;
  }

  // Render an entity's actions and functions (if any)
  // (expect an entity with trailing '}' to have just been rendered).
  // Return the resulting source string.
  function renderActionsAndFunctions(art, env) {
    let result = ''
    let childEnv = increaseIndent(env);
    for (let name in art.actions) {
      result += renderActionOrFunction(name, art.actions[name], childEnv);
    }
    // Even if we have seen actions/functions, they might all have been ignored
    if (result != '') {
      result = ' actions {\n' + result + env.indent + '}';
    }
    return result;
  }

  // Render an action or function 'act' with name 'actName'. Return the resulting source string.
  function renderActionOrFunction(actionName, act, env) {
    // Ignore if toHana says so
    if (act._ignore) {
      return '';
    }
    let result = renderAnnotationAssignments(act, env) + env.indent + act.kind + ' ' + env.namePrefix + quoteId(getLastPartOf(actionName));
    let childEnv = increaseIndent(env);
    let parameters = Object.keys(act.params || []).map(name => renderParameter(name, act.params[name], childEnv)).join(',\n');
    result += (parameters == '') ? '()' : '(\n' + parameters + '\n' + env.indent + ')';
    if (act.returns) {
      result += ' returns ' + renderTypeReference(act.returns, env);
    }
    result += ';\n';
    return result;
  }

  // Render an action or function parameter 'par' with name 'parName'. Return the resulting source string (no trailing LF).
  function renderParameter(parName, par, env) {
    let result = renderAnnotationAssignments(par, env) + env.indent + quoteId(parName) + ' : ' + renderTypeReference(par, env);
    result += renderNullability(par);
    return result;
  }

  // Render a type (derived or structured) or an annotation decl with name 'artifactName'.
  // Return the resulting source string.
  function renderTypeOrAnnotation(artifactName, art, env) {
    let result = renderAnnotationAssignments(art, env);
    result += env.indent + (art.dbType ? "table " : '') + art.kind + " " + env.namePrefix + quoteId(getLastPartOf(artifactName));
    if (art.includes) {
      // Includes are never flattened (don't exist in HANA)
      result += ' : ' + art.includes.map(name => renderAbsoluteNameWithQuotes(name, env)).join(', ');
    }
    let childEnv = increaseIndent(env);
    if (art.elements) {
      // Structured type or annotation with anonymous struct type
      result += " {\n";
      for (let name in art.elements) {
        result += renderElement(name, art.elements[name], childEnv);
      }
      result += env.indent + '};\n';
    } else {
      // Derived type or annotation with non-anonymous type
      result += " : " + renderTypeReference(art, env) + ';\n';
    }
    return result;
  }

  // Render a reference to a type used by 'elm' (named or inline)
  function renderTypeReference(elm, env) {
    let result = '';

    // Array type: Render items instead
    if (elm.items) {
      return 'array of ' + renderTypeReference(elm.items, env);
    }

    // FIXME: Is this a type attribute?
    result += (elm.localized ? 'localized ' : '');

    // Anonymous structured type
    if (!elm.type) {
      if (!elm.elements) {
        throw new Error('Missing type of: ' + JSON.stringify(elm));
      }
      result += '{\n';
      let childEnv = increaseIndent(env);
      for (let name in elm.elements) {
        result += renderElement(name, elm.elements[name], childEnv);
      }
      result += env.indent + '}'
      return result;
    }

    // Association type
    if (elm.type == 'cds.Association' || elm.type == 'cds.Composition') {
      // Type, cardinality and target
      result += elm.type == 'cds.Association' ? 'association' : 'composition';
      result += renderCardinality(elm.cardinality) + (elm.type == 'cds.Association' ? ' to ' : ' of ');
      result += flatNames ? renderAbsoluteNameFlat(elm.target, env)
                          : renderAbsoluteNameWithQuotes(elm.target, env);

      // ON-condition (if any)
      if (elm.on) {
        result += ' on ' + renderExpr(elm.on, env);
      }

      // Foreign keys (if any, unless we also have an ON_condition (which means we have been transformed from managed to unmanaged)
      if (elm.keys && !elm.on) {
        result += ' { ' + Object.keys(elm.keys).map(name => renderForeignKey(elm.keys[name], env)).join(', ') + ' }';
      }
      return result;
    }

    // Reference to another element
    // FIXME: Shouldn't that be 'type of' ??
    if (elm.type.ref) {
      return renderAbsolutePath(elm.type, env);
    }

    // If we get here, it must be a named type
    if (isBuiltinType(elm.type)) {
      // cds.Integer => render as Integer (no quotes)
      result += elm.type.replace(/^cds\./, '');
      result += renderTypeParameters(elm);
    } else {
      // Simple absolute name
      // Type names are never flattened (derived types are unraveled in HANA)
      result += renderAbsoluteNameWithQuotes(elm.type, env);
    }
    if (elm.enum) {
      result += ' enum {\n';
      let childEnv = increaseIndent(env);
      for (let name in elm.enum) {
        let enumConst = elm.enum[name];
        result += renderAnnotationAssignments(enumConst, childEnv);
        let enumValue = { val: enumConst.val === undefined ? name : enumConst.val };
        result += childEnv.indent + quoteId(name) + ' = ' + renderExpr(enumValue, childEnv) + ';\n';
      }
      result += env.indent + '}';
    }
    return result;
  }

  // Render an annotation value (somewhat like a simplified expression, with slightly different
  // representation)
  function renderAnnotationValue(x, env) {
    if (x instanceof Array) {
      // Render array parts as values
      return `[${x.map(item => renderAnnotationValue(item, env)).join(', ')}]`;
    }
    else if (typeof x == 'object' && x !== null) {
      // Enum symbol
      if (x['#']) {
        return `#${x['#']}`;
      }
      // Shorthand for absolute path (as string)
      else if (x['=']) {
        return quotePathString(x['=']);
      }
      // Struct value (can actually only occur within an array)
      else {
        // Note that we have to quote the struct keys here manually and not use quoteId, because they may even contain dots (yuc!)
        // FIXME: Should that really be allowed?
        return `{${Object.keys(x).map(key => '"' + key + '": ' + renderAnnotationValue(x[key], env)).join(', ')}}`;
      }
    }
    // Null
    else if (x === null) {
      return 'null';
    }
    // Primitive: string, number, boolean
    else {
      // Quote strings, leave all others as they are
      return (typeof x == 'string') ? `'${x.replace(/'/g, "''")}'` : x;
    }
  }

  // Render an expression (including paths and values) or condition 'x'.
  // (no trailing LF, don't indent if inline)
  function renderExpr(x, env, inline=true) {
    // Compound expression
    if (x instanceof Array) {
      // Simply concatenate array parts with spaces
      return x.map(item => renderExpr(item, env, inline)).join(' ');
    }
    // Various special cases represented as objects
    else if (typeof x == 'object' && x !== null) {
      // Literal value, possibly with explicit 'literal' property
      if (x.val !== undefined) {
        switch (x.literal || typeof x.val) {
          case 'number':
          case 'boolean':
          case 'null':
            return x.val;
          case 'x':
          case 'date':
          case 'time':
          case 'timestamp':
            return `${x.literal}'${x.val}'`;
          case 'string':
            return `'${x.val.replace(/'/g, "''")}'`;
          case 'object':
            if (x.val === null) {
              return 'null';
            }
            // otherwise fall through to
          default:
            throw new Error('Unknown literal or type: ' + JSON.stringify(x));
        }
      }
      // Enum symbol
      else if (x['#']) {
        return `#${x['#']}`;
      }
      // Reference: Array of path steps, possibly preceded by ':'
      else if (x.ref) {
        return `${(x.param || x.global) ? ':' : ''}${x.ref.map(renderPathStep).join('.')}`;
      }
      // Function call, possibly with args (use '=>' for named args)
      else if (x.func) {
        return `${x.func}(${renderArgs(x.args, '=>')})`;
      }
      // Nested expression
      else if (x.xpr) {
        return renderExpr(x.xpr, env);
      }
      // Sub-select
      else if (x.SELECT || x.SET) {
        return `(${renderQuery(x, false, increaseIndent(env))})`;
      }
      else {
        throw new Error('Unknown expression: ' + JSON.stringify(x));
      }
    }
    // Not a literal value but part of an operator, function etc - just leave as it is
    else {
      return x;
    }

    // Render a single path step 's' at path position 'idx', which can have filters or parameters or be a function
    function renderPathStep(s, idx) {
      // Simple id or absolute name
      if (typeof(s) == 'string') {
        // HANA-specific extra magic (should actually be in forHana)
        if (options.forHana) {
          // In HANA, we replace leading $self by the absolute name of the current artifact
          // (see FIXME at renderArtifact)
          if (idx == 0 && s == '$self') {
            return flatNames ? renderAbsoluteNameFlat(env.currentArtifactName, env)
                             : renderAbsoluteNameWithQuotes(env.currentArtifactName, env);
          }
          // HANA-specific translation of '$now' and '$user'
          if (s == '$now') {
            return 'CURRENT_TIMESTAMP';
          } else if (s == '$user') {
            return "SESSION_CONTEXT('XS_APPLICATIONUSER')";
          }
        }
        // In first path position, do not quote $projection and magic $-variables like CURRENT_DATE, $now etc.
        // FIXME: We should rather explicitly recognize quoting somehow
        if (idx == 0
            && (['$projection', '$self'].includes(s)
                || getMagicVariables().map(id => id.toLowerCase()).includes(s.toLowerCase())
                || s == 'self' && options.oldstyleSelf)) {
          return s;
        }
        return quoteOrUppercaseId(s);
      }
      // ID with filters or parameters
      else if (typeof s == 'object') {
        // Filter, possibly with cardinality
        if (s.where) {
          return `${quoteOrUppercaseId(s.id)}[${s.cardinality ? (s.cardinality.max + ': ') : ''}${renderExpr(s.where, env)}]`;
        }
        // Not really a path but an object-like function call
        else if (s.func) {
          return `${s.func}(${renderArgs(s.args, '=>')})`;
        }
        // View with arguments (use ':' for named args)
        else if (s.args) {
          return `${quoteOrUppercaseId(s.id)}(${renderArgs(s.args, ':')})`;
        }
        else {
          throw new Error('Unknown path step object: ' + JSON.stringify(s));
        }
      }
      else {
        throw new Error('Unknown path step: ' + JSON.stringify(s));
      }
    }

    // Render function arguments or view parameters (positional if array, named if object/dict),
    // using 'sep' as separator for positional parameters
    function renderArgs(args, sep) {
      // Positional arguments
      if (args instanceof Array) {
        return args.map(arg => renderExpr(arg, env)).join(', ');
      }
      // Named arguments (object/dict)
      else if (typeof args == 'object') {
        return Object.keys(args).map(key => `${quoteOrUppercaseId(key)} ${sep} ${renderExpr(args[key], env)}`).join(', ');
      }
      else {
        throw new Error('Unknown args: ' + JSON.stringify(args));
      }
    }
  }

  // Render a cardinality (only those parts that were actually provided)
  function renderCardinality(card) {
    if (!card) {
      return '';
    }
    let result = '[';
    if (card.src !== undefined) {
      result += card.src + ', ';
    }
    if (card.min !== undefined) {
      result += card.min + '..';
    }
    if (card.max !== undefined) {
      result += card.max;
    }
    return result + ']';
  }

  // Render the nullability of an element or parameter (can be unset, true, or false)
  function renderNullability(obj /* , env */) {
    if (obj.notNull === undefined) {
      // Attribute not set at all
      return '';
    }
    return obj.notNull ? ' not null' : ' null';
  }

  // Render a foreign key (no trailing LF)
  function renderForeignKey(fkey) {
    return `${renderExpr(fkey)}${fkey.as ? (' as ' + fkey.as) : ''}`;
  }

  // Render (primitive) type parameters of element 'elm', i.e. 
  // length, precision and scale (even if incomplete), plus any other unknown ones.
  function renderTypeParameters(elm /*, env */) {
    let params = [];
    // Length, precision and scale (even if incomplete)
    if (elm.length !== undefined) {
      params.push(elm.length);
    }
    if (elm.precision !== undefined) {
      params.push(elm.precision);
    }
    if (elm.scale !== undefined) {
      params.push(elm.scale);
    }
    // Additional type parameters
    // FIXME: Not yet clear how that looks in new CSN
    for (let arg of elm.typeArguments || []) {
      params.push(arg);
    }
    return params.length == 0 ? '' : '(' + params.join(', ') + ')';
  }

  // Render all annotation assignments of annotatable object 'obj'
  function renderAnnotationAssignments(obj, env) {
    let result = '';
    for (let name in obj) {
      if (name.startsWith('@')) {
        result += renderAnnotationAssignment(obj[name], name, env);
      }
    }
    return result;
  }

  // Render a single annotation assignment 'ann' with fully qualified name 'name' (no trailing LF).
  // We might see variants like 'A.B.C#foo' or even 'A.B#foo.C'. In both cases, the #foo must be ignored
  // when resolving the name, but must stay in the rendered output (quoted as necessary).
  function renderAnnotationAssignment(ann, name, env) {
    // Take the annotation assignment apart into <nameBeforeVariant>[#<variant>[.<nameAfterVariant>]]
    //                      @1111111  3333333   5555
    let parts = name.match(/@([^#]+)(#([^.]+)(\.(.+))?)?/);
    let nameBeforeVariant = parts[1];
    let variant = parts[3];
    let nameAfterVariant = parts[5];
    let topLevelName = getTopLevelArtifactNameOf(nameBeforeVariant, model);
    let result = env.indent + '@';
    if (topLevelName) {
      // Checked annotation, with declaration - must render top-level absolute name with proper using and alias
      // Annotation names are never flattened
      result += renderAbsoluteNameWithQuotes(topLevelName, env);
      if (topLevelName != nameBeforeVariant) {
        result += '.' + quotePathString(nameBeforeVariant.substring(topLevelName.length + 1));
      }
    }
    else {
      // Unchecked annotation, just render the name as it is
      result += quotePathString(nameBeforeVariant);
    }
    // Append '#'-variant if any
    if (variant) {
      // FIXME: Unfortunately, the compiler does not yet understand an inner variant with proper quoting,
      // i.e. like "__A"."B"#"foo"."C". As a workaround, we present the '#'-variant as a quoted part of the
      // previous path step, i.e as "__A"."B#foo"."C" (which yields the same result). This hack is only necessary
      // for inner '#'-variants, i.e. for those followed by a <nameAfterVariant>.
      // FIXME: Won't work for inner variants on the top-level artifact, because the USING no longer matches
      // for something like "__A#foo"."B"."C"
      if (nameAfterVariant) {
        let resultSteps = result.split('.');
        // Take all paths steps from the result (which is now essentially 'nameBeforeVariant' with USING
        // adaptations) except the last step
        result = resultSteps.slice(0, -1).join('.');
        // Append a combination of last path step and '#'-variant (quoted)
        let lastStep = resultSteps[resultSteps.length - 1];
        if (lastStep.includes('"')) {
          // Last step was already quoted - strip off the existing quotes
          lastStep = lastStep.slice(1, -1);
        }
        result += '.' + quoteId(lastStep + '#' + variant);
      }
      else {
        // No hack required for trailing '#'-variant
        result += '#' + quoteId(variant);
      }
    }
    // Append anything that might have come after the variant
    if (nameAfterVariant) {
      result += '.' + quotePathString(nameAfterVariant);
    }
    result += ' : ' + renderAnnotationValue(ann, env);
    return result  + '\n';
  }

  // Render an absolute name in 'flat' mode, i.e. uppercased and underscored. Also record the
  // fact that 'absName' is used in 'env', so that an appropriate USING can be constructed
  // if necessary. 
  function renderAbsoluteNameFlat(absName, env) {
    // Add using declaration
    env.topLevelAliases[absName] = {
      quotedName: uppercaseAndUnderscore(absName),
      quotedAlias: uppercaseAndUnderscore(absName)
    };
    return uppercaseAndUnderscore(absName);
  }

  // Render an absolute name 'absName', with appropriate quotes. Also record the
  // fact that 'absName' is used in 'env', so that an appropriate USING can be constructed
  // if necessary.
  function renderAbsoluteNameWithQuotes(absName, env) {
    // Special case: If the top-level artifact name is not a valid artifact name, it came from an unchecked annotation
    // and must be left as it is (just quoted)
    let topLevelName = getTopLevelArtifactNameOf(absName, csn);
    if (!csn.definitions[topLevelName]) {
      return quotePathString(absName);
    }

    // Another special case: If we are rendering for HANA, and if the first path step is an artifact that is
    // 'implemented in' something, we need to treat the whole name like a top-level id.
    // Note: The 'impl' might also have been generated by toHana based on '@cds.persistence.exists';
    // we use 'impl' to transport this info because the annotations have already been removed when
    // arriving here
    // FIXME: Make that '$impl' or similar
    if (options.toHana && csn.definitions[absName] && csn.definitions[absName].impl) {
      env.topLevelAliases[absName] = {
        quotedName: quoteAbsoluteNameAsId(absName),
        quotedAlias: quoteId(createTopLevelAliasName(absName))
      };
      return env.topLevelAliases[absName].quotedAlias;
    }

    // Retrieve or create a suitable alias name for the surrounding top-level artifact
    let topLevelAlias = env.topLevelAliases[topLevelName];
    if (!topLevelAlias) {
      env.topLevelAliases[topLevelName] = {
        quotedName: quoteAbsolutePathString(topLevelName),
        quotedAlias: quoteId(createTopLevelAliasName(topLevelName))
      };
      topLevelAlias = env.topLevelAliases[topLevelName];
    }

    // Replace the top-level name with its alias
    if (absName == topLevelName) {
      return topLevelAlias.quotedAlias;
    } else {
      return topLevelAlias.quotedAlias + '.' + quotePathString(absName.substring(topLevelName.length + 1));
    }
  }

  // Create a suitable alias name for a top-level artifact name. Ideally, it should not conflict with
  // any other identifier in the model and be somewhat recognizable and un-ugly...
  function createTopLevelAliasName(topLevelName) {
    // FIXME: We should rather check for conflicts than just using something obscure like this ...
    return '__' + topLevelName.replace(/::/g, '__').replace(/\./g, '_');
  }

  // Render appropriate USING directives for all artifacts used by artifact 'artifactName' in 'env'.
  function renderUsings(artifactName, env) {
    return Object.keys(env.topLevelAliases)
                 .filter(name => !(flatNames && env.topLevelAliases[name].quotedName == uppercaseAndUnderscore(artifactName))) // avoid "using FOO as FOO" in FOO.cds
                 .map(name => 'using ' + env.topLevelAliases[name].quotedName + ' as ' + env.topLevelAliases[name].quotedAlias + ';\n')
                 .join('');
  }
  
  // Depending on the naming style, render the namespace declaration for a top-level artifact 'name'
  // if it has a namespace parent. Assume that this is only called for top-level artifacts.
  // - For 'deep' and 'hdbcds' names, render the namespace declaration (resulting in '.' or '::' style names)
  // - For 'flat' names, do not render anything (namespace already part of flattened names).
  // Return the namespace declaration (with trailing LF) or an empty string.
  function renderNamespaceDeclaration(topLevelName, env) {
    if (flatNames) {
      // No namespaces in flat mode
      return '';
    }
    // The top-level artifact's parent would be the namespace (if any)
    let namespace = getParentNameOf(topLevelName);
    if (namespace) {
      return env.indent + 'namespace ' + quotePathString(namespace) + ';\n';
    }
    return '';
  }

  // Return a dictionary of top-level artifacts contained in the model (by their name)
  function getTopLevelArtifacts() {
    let result = Object.create(null);
    for (let name in csn.definitions) {
      if (flatNames) {
        let art = csn.definitions[name];
        // For 'flat' naming, take all entities and views, nothing else
        if (art.kind == 'entity' || art.kind == 'view') {
          result[name] = art;
        }
      }
      else {
        // For all other naming conventions, take all top-level artifacts except namespaces
        let topLevelName = getTopLevelArtifactNameOf(name, csn);
        let topLevelArtifact = csn.definitions[topLevelName];
        if (topLevelArtifact && topLevelArtifact.kind != 'namespace') {
          result[topLevelName] = topLevelArtifact;
        }
      }
    }
    return result;
  }

  // Returns a newly created default environment (which keeps track of indentation, required USING
  // declarations and name prefixes.
  function createEnv() {
    return {
      // Current indentation string
      indent: '',
      // Dictionary of aliases for used artifact names, each entry like 'name' : { quotedName, quotedAlias }
      topLevelAliases: Object.create(null),
      // Current name prefix (including trailing dot if not empty)
      namePrefix: ''
    }
  }

  // Returns a copy of 'env' with (quoted) name prefix 'id' and a dot appended to the current name prefix
  function addNamePrefix(env, id) {
    return Object.assign({}, env, { namePrefix: env.namePrefix + quoteId(id) + '.' });
  }

  // Returns a copy of 'env' with increased indentation (and resetted name prefix)
  function increaseIndent(env) {
    return Object.assign({}, env, { namePrefix: '', indent: env.indent + '  ' });
  }

  // Return a path string 'path' with appropriate "-quotes.
  function quotePathString(path) {
    // "foo"."bar"."wiz"."blub"
    return path.split('.').map(quoteId).join('.');
  }

  // Return an absolute path 'abspath', with '::' inserted if required by naming strategy 'hdbcds',
  // with appropriate "-quotes
  function quoteAbsolutePathString(abspath) {
    if (!hdbcdsNames) {
      return quotePathString(abspath);
    }
    let topLevelName = getTopLevelArtifactNameOf(abspath, csn);
    let namespace = getParentNameOf(topLevelName);
    if (namespace) {
      return quotePathString(namespace) + '::' + quotePathString(abspath.substring(namespace.length + 1));
    }
    return quotePathString(abspath);
  }

  // Return an id 'id' with appropriate "-quotes
  // FIXME: Should only quote where necessary (examining the id for magic characters and reserved
  // keywords) - for now, simply quote everything
  function quoteId(id) {
    // Should only ever be called for real IDs (i.e. no dots inside)
    if (id.indexOf('.') != -1) {
      throw new Error(id);
    }
    // FIXME: Somewhat arbitrary magic: Do not quote $projection (because HANA CDS doesn't recognize it otherwise).  Similar for $self.
    // FIXME: The test should not be on the name, but by checking the _artifact.
    if (id == '$projection' || id == '$self' ||
        id == 'self' && options.oldstyleSelf ||
        id == '$user' || id == '$now') {
      return id;
    }
    // Returns quoted name if:
    // 1. starts with a digit
    // 2. it contains chars different than:
    //  - uppercase letters
    //  - lowercase letters
    //  - digits
    //  - underscore
    if (id.match(/^\d/) || id.match(/\W/g))
      return '"' + id.replace(/"/g, '""') + '"';
    if (keywords.cdl.includes(id.toUpperCase()))
      return '"' + id.replace(/"/g, '""') + '"';
    if (options.toHana && keywords.sql92.includes(id.toUpperCase()))
      return '"' + id.replace(/"/g, '""') + '"';
    if (keywords.functions.includes(id.toUpperCase()))
      return '"' + id.replace(/"/g, '""') + '"';
    return id;
  }

  // Return an absolute name 'absname', with '::' inserted if required by naming strategy 'hdbcds', quoted
  // as if it was a single identifier (required only for native USINGs)
  function quoteAbsoluteNameAsId(absname) {
    if (hdbcdsNames) {
      let topLevelName = getTopLevelArtifactNameOf(absname, csn);
      let namespace = getParentNameOf(topLevelName);
      if (namespace) {
        return '"' + (namespace + '::' + absname.substring(namespace.length + 1)).replace(/"/g, '""') + '"';
      }
    }
    return '"' + absname.replace(/"/g, '""') + '"';
  }

  // Quote or uppercase an identifier 'id', depending on naming strategy
  function quoteOrUppercaseId(id) {
    if (flatNames) {
      return id.replace(/\./g, '_').toUpperCase();
    } else {
      return quoteId(id);
    }
  }

  // Render the name of an artifact, using the current name prefix from 'env'
  // and just the last part of the artifact's name. In case of flat names, this
  // is equivalent to simply flattening and uppercasing the whole name.
  function renderArtifactName(artifactName, env) {
    return (flatNames) ? quoteOrUppercaseId(artifactName)
                       : env.namePrefix + quoteId(getLastPartOf(artifactName));
  }

  // replace . by _
  // convert to uppercase
  function uppercaseAndUnderscore(name) {
    return name.replace(/\./g, '_').toUpperCase();
  }
}

module.exports = {
  toCdsSourceNew,
};
