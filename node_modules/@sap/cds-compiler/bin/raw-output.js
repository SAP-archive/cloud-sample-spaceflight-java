// Make internal properties of the augmented CSN visible

const { locationString } = require('../lib/base/messages');

function revealInternalProperties( model ) {
  var unique_id = 0;

  var transformers = {
    location: locationString,
    artifacts: artifactDictionary,
    definitions: artifactDictionary,
    elements: (e,n) => (n.self ? artifactDictionary(e) : dictionary(e)),
    actions: dictionary,
    params: dictionary,
    enum: dictionary,
    foreignKeys: dictionary,
    exclude: dictionary,
    struct: dictionary,
    queries: n => n.map( revealQuery ),
    $tableAliases: dictionary,
    $navigation: dictionary,
    $combined: artifactDictionary,
    $dictOrderBy: artifactDictionary,
    _layerRepresentative: s => s.realname,
    _layerExtends: layerExtends,
    _parent: artifactIdentifier,
    _main: artifactIdentifier,
    _block: artifactIdentifier,
    _artifact: artifactIdentifier,
    _navigation: artifactIdentifier,
    _tableAlias: artifactIdentifier,
    _projections: artifactIdentifier, // array
    _$queryNode: n => (n.location && { location: locationString( n.location ) }),
    _$next: artifactIdentifier,
    _finalType: artifactIdentifier,
    _leadingQuery: artifactIdentifier,
    _source: artifactIdentifier,
    _extend: (a) => reveal( a, null ),
    _annotate: (a) => reveal( a, null ),
    _deps: dependencyInfo,
    _incomplete: primOrString,
    _shadowed: (a) => reveal( a, null ),
    _status: primOrString,       // is a string anyway
    _service: artifactIdentifier,
    _firstAliasInFrom: artifactIdentifier,
  }
  return reveal( model );

  function artifactIdentifier( node, parent ) {
    if (node === parent)
      return 'this';
    if (node instanceof Array)
      return node.map( artifactIdentifier );
    if (!(node instanceof Object))
      return primOrString( node );
    switch (node.kind) {
      case undefined:             // TODO: remove this `returns` property for actions
        return (node._artifact && node._artifact.kind)
          ? artifactIdentifier( node._artifact )
          : JSON.stringify(node);
      case 'builtin':
        return 'builtin("cds")';
      case 'source':
        return (node.name)
          ? 'source(' + quoted( node.filename ) + ',using:' + quoted( node.name.id ) + ')'
          : 'source(' + quoted( node.filename ) + ')';
      case 'using':
        return 'using(' + quoted( node.name && node.name.id ) +
               ',source:' + quoted( node.location && node.location.filename ) + ')';
      default: {
        let names = [];
        if (node.name) {
          [ 'element', 'alias', 'query', 'param', 'action', 'absolute' ].forEach( function( prop ) {
            if (prop in node.name)
              names.push( (names.length || node.kind === 'annotate' ? prop + ':' : '') + quoted( node.name[prop] ) );
          });
        }
        else
          names = [ quoted(undefined) ];
        if (!names.length)      // TODO: should only be necessary temporarily
          names = [JSON.stringify(node.name)];
        // TODO: as long as we have no kind='mixin':
        let kind = (node.kind === 'element' && !node.name.element) ? 'mixin' : node.kind;
        return (kind || '<kind>') + '(' + names.join(',') + ')';
      }
    }
  }

  function quoted( name, undef = '<undefined>' ) {
    return (typeof name === 'number')
      ? name
      : name ? '"' + name.replace( /"/g, '""' ) + '"' : undef;
  }

  function artifactDictionary( node ) {
    if (node == null || typeof node !== 'object' || Object.getPrototypeOf(node)
        || !model.definitions || node === model.definitions )
      return dictionary( node );    // no dictionary or no definitions section
    let dict = Object.create(null);
    for (let name in node) {
      dict[name] = artifactIdentifier( node[name] );
    }
    return dict;
  }

  function dependencyInfo( deps ) {
    if (!(deps instanceof Array))
      return primOrString( deps );
    return deps
      .filter( d => d.location )
      .map( d => artifactIdentifier( d.art ) );
  }

  function layerExtends( dict ) {
    let r = Object.create(null);
    // let proto = Object.getPrototypeOf(dict);
    // if (proto)
    //   r.__proto__ = proto.realname || proto;
    for (let name in dict)
      r[name] = true;
    return r;
  }

  function primOrString( node ) {
    if (node == null || typeof node !== 'object')
      // node instanceof Object would be false for dict
      return node
    if (node instanceof Array)
      return node.map( primOrString );
    if (node instanceof Object)
      return '' + node;
    else
      return '<dict>';
  }

  function dictionary( node ) {
    return reveal( node, '__proto__' ); 
  }

  function revealQuery( node ) {
    return reveal( node, undefined, undefined, true );
  }

  function reveal( node, protoProp, _array, identifierKind = 'query' ) {
    // warning: 'protoProp' bound via map()
    if (node == null || typeof node !== 'object' )
      // node instanceof Object would be false for dict
      return node
    if (node instanceof Array)
      return node.map( reveal );

    let proto = Object.getPrototypeOf(node);
    if (proto !== null && proto !== Object.prototype)
      return node;
    if (proto && node.kind === identifierKind)
      return artifactIdentifier( node );

    let r = Object.create( proto );
    // property to recognize === objects
    if (proto && node.kind && node.__unique_id__ == null)
      Object.defineProperty( node, '__unique_id__', { value: ++unique_id } );

    for (let prop of Object.getOwnPropertyNames( node )) { // also non-enumerable
      let item = node[prop];
      let func =
          (proto === null || protoProp === null ? reveal : transformers[prop]) ||
          (node.propertyIsEnumerable( prop ) ? reveal : primOrString);
      r[prop] = func( item, node );
    }
    if (proto && protoProp === '__proto__')
      Object.defineProperty( r, protoProp, { enumerable: true, value: '' + proto } );
    return r;
  }
}

module.exports = revealInternalProperties;
