#!/usr/bin/env node

// command line interface to the cds api resp. cds compiler
// Usage: cdsc [options] <file> ...
// Call cdsc --help for a detailed description
// Exit codes are:
//   0   for success
//   1   compilation error
//   2   command line usage error

'use strict';

/* eslint no-console:off */

const program = require('commander');
const compiler = require('../lib/main');
const { getDefaultTntFlavorOptions } = require('../lib/transform/tntSpecific');
var util = require('util');
var fs = require('fs');
var path = require('path');
var reveal = require('./raw-output');

program
  .usage('[options] <file> ...')
  .description(`Compile a CDS model given from the input files. Input files may be CDS source files (.cds), CSN
  model files (.json), property files for localized annotations (.properties) and XML files (.xml)
  for pre-processed ODATA annotations.`)

  // Uncomment this to make it easier to check for the 100 columns limitation in the '--help' output
  // .option('@@', '34567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890')
  .option('@@', 'General Options')
  .option('-h, --help',             'Display this help text and exit')
  .option('-w, --warning <level>',  'Show warnings up to <level> (0: Error, 1: Warnings, 2: Info (default))',
          verifyWarningOption)
  .option('    --show-message-id',  'Show message ID in error, warning and info messages')
  .option('-v, --version',          'Display version number and exit')

  .option('@@', 'Generation options (can be combined, default if none given is "--to-csn --out -")')
  .option('-o, --out <dir>',        'Place generated files in directory <dir>, default is "-" for <stdout>')
  .option('-H, --to-hana <flags>',  `Generate HANA CDS source files, <flags> can be a comma-separated
                          combination of either "flat" (default), "deep" or "hdbcds" for entity
                          names, either "assocs" (default) or "joins" for associations and any
                          of "src,csn"
                            flat    : Produce HANA entity and element names in uppercase and
                                      flattened with underscores. Do not generate structured
                                      types.
                            deep    : Produce HANA entity and element names in original case
                                      as in CDL. Keep nested contexts (resulting in entity names
                                      with dots), but flatten element names with underscores.
                                      Generate structured types, too.
                            hdbcds  : Produce HANA entity end element names as HANA CDS would
                                      generate them from the same CDS source (like "deep",
                                      but using element names with dots).
                            assocs  : Keep associations in HANA CDS as far as possible
                            joins   : Transform associations to HANA CDS joins
                            src     : Generate HANA CDS source files "<artifact>.hdbcds"
                            csn     : Generate "hana_csn.json" with HANA-preprocessed model`, verifyToHanaOption)
  .option('-O, --to-odata <flags>', `Generate ODATA metadata and annotations, <flags> can be a comma-
                          separated combination of "xml,json,separate,combined,csn" and either
                          "v2" (default) or "v4" version
                            v2      : Generate ODATA V2 output
                            v4      : Generate ODATA V4 output
                            xml     : Generate XML output (separate or combined)
                            json    : Generate JSON output (not available for V2)
                            separate: Generate "<svc>_metadata.xml" and "<svc>_annotations.xml"
                            combined: Generate "<svc>.xml"
                            csn     : Generate "odata_csn.json" with ODATA-preprocessed model`, verifyToOdataOption)
  .option('-C, --to-cdl',           'Generate CDS source files "<artifact>.cds"')
  .option('-S, --to-swagger <flags>', `Generate Swagger (OpenAPI) JSON, <flags> can be a comma-separated
                          combination of "json" and "csn"
                            json    : Generate OpenAPI JSON output for each service as
                                      "<svc>_swagger.json"
                            csn     : Generate "swagger_csn.json" with Swagger-preprocessed model`, verifyToSwaggerOption)
  .option('-Q, --to-sql <flags>',   `Generate SQL DDL statements to create tables and views, <flags> can be
                          a comma-separated combination of either "flat" (default), "deep" or
                          "hdbcds" for entity names, either "assocs" (default) or "joins" for
                          associations and any of "src,csn"
                            flat    : Produce SQL table and view names in uppercase and
                                      flattened with underscores (no quotes required)
                            deep    : Produce SQL table and view names in original case
                                      as in CDL (with dots), but flatten element names with
                                      underscores (requires quotes)
                            hdbcds  : Produce SQL table, view and column names as HANA CDS
                                      would generate them from the same CDS source (like "deep",
                                      but using element names with dots).
                            assocs  : Keep associations as far as possible (only usable for
                                      HANA SQL)
                            joins   : Transform associations to SQL joins
                            src     : Generate SQL source files as "<artifact>.sql"
                            csn     : Generate "sql_csn.json" with SQL-preprocessed model`, verifyToSqlOption)
  .option('-I, --to-i18n <style>',  `Generate files for translation of localized annotations, <style> can
                          be either "prop" (default) for a property file or "ui5" for a UI5-
                          style combination of property file and modified model
                            prop    : Generate property file with  annotation text
                            ui5     : Generate model with placeholders and property file with
                                      annotation text`,
          verifyI18nOption)
  .option('-l, --lint-mode',        `Generate nothing, just produce single-file error messages if any (for
                          use by editors)`)
  .option('    --to-csn',           'Generate original model as CSN to "csn.json"')
  .option('@@', 'Backward compatibility options (deprecated, do not use)')
  .option('    --check-model',      'Perform extra checks on the model') // FIXME: Should remove option and do this always
  .option('    --oldstyle-self',    'Allow "self" alternatively to "$self" (implied by --tnt-flavor)') // FIXME: We should get rid of that
  .option('    --tnt-flavor',       'Compile with backward compatibility for the "TNT" project')
  .option('    --tnt-csn',          'Generate TNT-specific post-processed CSN') // FIXME: Should migrate towards --to-odata v2,xml,separate,csn'

  .option('@@', 'Diagnostic options')
  .option('    --trace-parser',     'Trace parser') // FIXME: Previously --trace-parse
  .option('    --trace-parser-amb', 'Trace parser ambiguities') // FIXME: Previously --ambig-detection
  .option('    --trace-fs',         'Trace file system access caused by "using from"')

  .option('@@', 'Internal options (for testing only, may be changed/removed at any time)')
  .option('-R, --raw-output',       'Write raw augmented CSN and error output to stdout')
  .option('    --beta-mode',        'Enable unsupported, incomplete (beta) features')
  .option('    --new-csn',          'Produce new-style CSN (preview of planned future CSN format)')
  .option('    --hana-flavor',      'Compile with backward compatibility for HANA CDS (incomplete)')
  .option('    --parse-only',       'Stop compilation after parsing and write result to stdout')
  .option('    --to-extensions',    'Generate augmented CSN for extensions from properties file') // FIXME: Previously 'generate-extensions', should later become part of normal compilation, producing plain CSN
  .option('    --test-mode',        `Produce extra-stable output for automated tests (normalize filenames
                          in errors, sort properties in CSN, omit version in CSN)`)
  .option('    --extra-augment',    'Compile to plain CSN, augment and compile again, augmentation tests')
  .option('    --re-augmented',     'Re-augmented CSN and error output') // FIXME: What does that mean/do? Isn't that what --extra-augment is supposed to do?
  .option('    --old-propagate',    'Use old propagation logic')
  .option('    --disable-propagate',`Do not propagate properties with "--to-csn" (makes result re-usable
                          with extensions)`) // FIXME: Should probably become a flag for '--to-csn'

  .option('@@', 'Table renaming (tentative, subject to change, requires "--beta-mode")')
  .option('    --to-rename <flags>', `Generate SQL DDL statements to rename existing tables and their
                          columns so that they match the result of "--to-hana" or "--to-sql"
                          with the "flat" option. Possible values for <flags> are either
                          "deep" or "hdbcds" (default) for the names of the existing tables.
                          Results are generated as "rename_<artifact>.sql"
                            deep    : Assume existing SQL tables and views were named in
                                      original case as in CDL (with dots), but element names
                                      were flattened with underscores (as a result e.g. from
                                      "cdsc --to-hana src,deep")
                            hdbcds  : Assume existing SQL tables, views and columns were
                                      generated by HANA CDS from the same CDS source (or from
                                      "cdsc --to-sql src,hdbcds")`, verifyToRenameOption)
  ;
  // Note: When adding any options where the '--foo-bar' part becomes longer than the longest existing one,
  // you will need to adapt the indentation of those having multiple lines, so that '--help' comes out aligned.
  // Generally, the alignment of the lines above needs a bit of care - the multi-line ones need to be just so...
  // Also, we try to keep the output below 100 characters per line.

// Note: Instead of throwing ProcessExitError, we would rather just call process.exit(exitCode),
// but that might truncate the output of stdout and stderr, both of which are async (or rather,
// may possibly be async, depending on OS and whether I/O goes to TTY, socket, file, ... sigh)
class ProcessExitError extends Error {
  constructor(exitCode,...args) {
    super(...args);
    this.exitCode = exitCode;
  }
}

// Deal with '--version' explicitly (so that it appears in the proper place in '--help')
program.on('option:version', function() {
  process.stdout.write(compiler.version() + '\n');
  throw new ProcessExitError(0);
});

// Deal with '--help' explicitly (needs some tweaking for the text formatting)
program.on('option:help', function() {
  displayUsage(null, 0);
});

// Report unknown options explicitly (so that it looks like the other error messages)
program.unknownOption = (option) => {
  displayUsage(`Unknown option "${option}"`, 2);
}

// Parse the command line and translate it into options
try {
  program.parse(process.argv);
  // Complain if no files given
  // FIXME: Might later read from stdin instead
  if (!program.args.length) {
    displayUsage('Missing <file> ... arguments', 2);
  }
  // Please keep these in the same order as the --help output
  var options = {
    // Default warning level is 2 (info)
    warning : program.warning === undefined ? 2 : program.warning,
    showMessageId : program.showMessageId,
    // Default output goes to stdout
    out : program.out || '-',
    toHana: program.toHana,
    toOdata : program.toOdata,
    toCdl : program.toCdl,
    toSwagger : program.toSwagger,
    toSql : program.toSql,
    toI18n : program.toI18n,
    lintMode : program.lintMode,
    // By default, toCsn is on if no other to-option is set
    toCsn : program.toCsn || (!program.toHana && !program.toOdata && !program.toCdl && !program.toSwagger && !program.toSql
                              && !program.toI18n && !program.lintMode && !program.toRename),
    checkModel : program.checkModel,
    oldstyleSelf : program.oldstyleSelf,
    tntFlavor : program.tntFlavor && getDefaultTntFlavorOptions(),
    tntCsn : program.tntCsn,
    traceParser : program.traceParser,
    traceParserAmb : program.traceParserAmb,
    traceFs : program.traceFs,
    rawOutput : program.rawOutput,
    betaMode : program.betaMode,
    newCsn : program.newCsn,    // TEMP
    hanaFlavor : program.hanaFlavor,
    parseOnly : program.parseOnly,
    toExtensions : program.toExtensions,
    testMode : program.testMode,
    extraAugment : program.extraAugment,
    reAugmented : program.reAugmented,
    oldPropagate : program.oldPropagate,
    disablePropagate : program.disablePropagate, // TODO: how to handle this?
    toRename : program.toRename,
  }

  // Do the work for all options at once
  executeCommandLine(options, program.args)
} catch (err) {
  // This whole try/catch is only here because process.exit does not work in combination with
  // stdout/err - see comment at ProcessExitError
  if (err instanceof ProcessExitError) {
    process.exitCode = err.exitCode;
  } else {
    throw err;
  }
}

// Display 'error' (if any) and the program's usage help text, then exit with exit code <code>
function displayUsage(error, code) {
  program.outputHelp(helpText => {
    return helpText
              .replace(/\n\n {2}Options:\n\n/, '')  // Get rid of the extra 'Options:' headline with many newlines 
              .replace(/ {4}@@ */g, '\n  ')         // Convert the '@@' fake-options to subsections
              .replace(/ {4}-h, --help *output usage information\n/g, '');  // Get rid of auto-generated '--help'
  });
  // Display error at the end (more readable, no scrolling)
  if (error) {
    process.stderr.write(`\n  ERROR: ${error}\n`);
  }
  throw new ProcessExitError(code);
}

// Check the value of --warning for legal values. Return value as an int.
function verifyWarningOption(value) {
  let result = parseInt(value);
  if (Number.isNaN(result) ||  result < 0 || result > 2) {
    displayUsage(`Illegal <level> "${value}" for option "-w, --warning"`, 2);
  }
  return result;
}

// Check whether all 'flags' occur in array 'allowedFlags'. Complain if one doesn't, mentioning
// the option name 'optStr' and optionally the flag name 'flagId'. Return an object with each of 'flags'
// set to 'true'
function verifyFlags(allowedFlags, flags, optStr, flagId='flag') {
  let result = {};
  for (let flag of flags.split(',')) {
    if (!allowedFlags.includes(flag)) {
      displayUsage(`Illegal <${flagId}> "${flag}" for option "${optStr}", allowed are: "${allowedFlags.join(',')}"`, 2);
    }
    result[flag] = true;
  }
  return result;
}

// Check the value of --to-odata for legal values. Return the value as an object with sub-options.
function verifyToOdataOption(value) {
  let result = verifyFlags(['v4','v2','xml','json','separate','combined','csn'], value, '-O, --to-odata');

  if (result.v2) {
    result.version = 'v2'
  }
  if (result.v4) {
    result.version = 'v4'
  }
  if (result.v2 && result.v4) {
    displayUsage(`Either "v2" (default) or "v4" can be specified for version with option "-O, --to-odata", but not both`, 2);
  }
  delete result.v2;
  delete result.v4;
  return result;
}

// Check the value of --to-swagger for legal values. Return the value as an object with sub-options.
function verifyToSwaggerOption(value) {
  return verifyFlags(['json','csn'], value, '-S, --to-swagger');
}

// Check the value of --to-hana for legal values. Return the value as an object with sub-options.
function verifyToHanaOption(value) {
  let result = verifyFlags(['flat','deep','hdbcds','assocs','joins','src','csn'], value, '-H, --to-hana');

  let nrOfNameFlags = 0;
  if (result.flat) {
    result.names = 'flat'
    nrOfNameFlags++;
  }
  if (result.deep) {
    result.names = 'deep'
    nrOfNameFlags++;
  }
  if (result.hdbcds) {
    result.names = 'hdbcds'
    nrOfNameFlags++;
  }
  if (nrOfNameFlags > 1) {
    displayUsage(`Only one of "flat" (default), "deep" or "hdbcds" can be specified for names with option "-H, --to-hana", but not combinations`, 2);
  }
  delete result.flat;
  delete result.deep;
  delete result.hdbcds;

  if (result.assocs) {
    result.associations = 'assocs'
  }
  if (result.joins) {
    result.associations = 'joins'
  }
  if (result.assocs && result.joins) {
    displayUsage(`Either "assocs" (default) or "joins" can be specified for associations with option "-H, --to-hana", but not both`, 2);
  }
  delete result.assocs;
  delete result.joins;
  return result;
}

// Check the value of --to-sql for legal values. Return the value as an object with sub-options.
function verifyToSqlOption(value) {
  let result = verifyFlags(['flat','deep','hdbcds','assocs','joins','src','csn'], value, '-Q, --to-sql');

  let nrOfNameFlags = 0;
  if (result.flat) {
    result.names = 'flat'
    nrOfNameFlags++;
  }
  if (result.deep) {
    result.names = 'deep'
    nrOfNameFlags++;
  }
  if (result.hdbcds) {
    result.names = 'hdbcds'
    nrOfNameFlags++;
  }
  if (nrOfNameFlags > 1) {
    displayUsage(`Only one of "flat" (default), "deep" or "hdbcds" can be specified for names with option "-Q, --to-sql", but not combinations`, 2);
  }
  delete result.flat;
  delete result.deep;
  delete result.hdbcds;

  if (result.assocs) {
    result.associations = 'assocs'
  }
  if (result.joins) {
    result.associations = 'joins'
  }
  if (result.assocs && result.joins) {
    displayUsage(`Either "assocs" (default) or "joins" can be specified for associations with option "-Q, --to-sql", but not both`, 2);
  }
  delete result.assocs;
  delete result.joins;
  return result;
}

// Check the value of --to-rename for legal values. Return the value as an object with sub-options.
function verifyToRenameOption(value) {
  let result = verifyFlags(['deep','hdbcds'], value, '--to-rename');

  if (result.deep) {
    result.names = 'deep'
  }
  if (result.hdbcds) {
    result.names = 'hdbcds'
  }
  if (result.deep && result.hdbcds) {
    displayUsage(`Either "deep" or "hdbcds" (default) can be specified for names with option "--to-rename", but not both`, 2);
  }
  delete result.deep;
  delete result.hdbcds;
  return result;
}

// Check the value of --to-i18n for legal values. Return the value as an object with sub-options.
function verifyI18nOption(value) {
  verifyFlags(['prop','ui5'], value, '-I, --to-i18n', 'style');
  return { style : value } ;
}

// Executes a command line that has been translated to 'options' (what to do) and 'args' (which files)
function executeCommandLine(options, args) {
  const normalizeFilename = options.testMode && process.platform === 'win32';
  const messageLevels = { Error: 0, Warning: 1, Info: 2, None: 3 };
  // All messages are put into the message array, even those which should not
  // been displayed (severity 'None')

  // Create output directory if necessary
  if (options.out && options.out != '-' && !fs.existsSync(options.out)) {
    fs.mkdirSync(options.out);
  }

  var run;
  if (options.toExtensions) {
    // This option can disappear when each extension is tagged whether is has
    // been applied - the compactor could then list the non-applied extensions
    try {
      console.log(JSON.stringify(compiler.generateExtensions(args[0], options), null, 2));
    } catch (err) {
      console.error(err.message);
      process.exit(1);
    }
  }
  else {
    run = compiler.compile( args, undefined, options );
  }

  // The backends (should be changed to async where necessary): ----------------
  if (options.toExtensions) {
    run = null;                   // already done (option to be deleted)
  }
  else if (options.tntCsn) {
    // FIXME: This is the only one that is not actually combinable with others
    run = run.then( tntOutput );
  } else {
    // Backend options (in alphabetical order)
    if (options.toCdl) {
      run = run.then( toCdl );
    }
    if (options.toCsn) {                          // standard: output CSN
      run = run.then( toCsn );
    }
    if (options.toHana) {
      run = run.then( toHana );
    }
    if (options.toI18n) {
      run = run.then( toI18n )
    }
    if (options.toOdata) {
      run = run.then( toOdata );
    }
    if (options.toRename) {
      run = run.then( toRename );
    }
    if (options.toSql) {
      run = run.then( toSql );
    }
    if (options.toSwagger) {
      run = run.then( toSwagger );
    }
  }
  if(run) {
    run = run.then( displayMessages, displayErrors );
  }

  if (run) {
    run.catch( catchErrors );
  }

  // Execute the command line option '--to-cdl' and display the results.
  // Return the original model (for chaining)
  function toCdl( model ) {
    let cdlResult = compiler.toCdl(model);
    for (let name in cdlResult) {
      writeToFileOrDisplay(options.out, name + '.cds', cdlResult[name]);
    }
    return model;
  }

  // Execute the command line option '--to-csn' and display the results.
  // Return the original model (for chaining)
  function toCsn( model ) {
    // Result already provided by caller
    displayNamedCsn(model, 'csn', options);
    return model;
  }

  // Execute the command line option '--to-hana' and display the results.
  // Return the original model (for chaining)
  function toHana( model ) {
    let hanaResult = compiler.toHana(model);
    for (let name in hanaResult.hdbcds) {
      writeToFileOrDisplay(options.out, name + '.hdbcds', hanaResult.hdbcds[name]);
    }
    if (hanaResult.csn) {
      displayNamedCsn(hanaResult._augmentedCsn, 'hana_csn', options);
    }
    return model;
  }

  // Execute the command line option '--to-i18n' and display the results.
  // Return the original model (for chaining)
  function toI18n(model) {
    let i18nResult = compiler.toI18n(model);
    // Different results depending on 'style'
    if (options.toI18n.style == 'prop') {
      writeToFileOrDisplay(options.out, 'annotations.properties', Object.keys(i18nResult).map(prop => `${prop}=${i18nResult[prop]}`).join('\n'), true);
    } else if (options.toI18n.style == 'ui5') {
      let props = '';
      for (let key in i18nResult.properties) {
        props += `${key}=${i18nResult.properties[key]}\n`;
      }
      writeToFileOrDisplay(options.out, 'i18n.properties', props);
      displayNamedCsn(i18nResult, 'definitions', options);
    } else {
      throw new Error(`Invalid style ${options.toI18n.style} for toI18n`);
    }
    return model;
  }

  // Execute the command line option '--to-odata' and display the results.
  // Return the original model (for chaining)
  function toOdata( model ) {
    let odataResult = compiler.toOdata(model);
    for (let serviceName in odataResult.services) {
      // <service>_metadata.xml (metadata)
      if (odataResult.services[serviceName].metadata) {
        writeToFileOrDisplay(options.out, serviceName + '_metadata.xml', odataResult.services[serviceName].metadata);
      }
      // <service>_annotations.xml (annotations)
      if (odataResult.services[serviceName].annotations) {
        writeToFileOrDisplay(options.out, serviceName + '_annotations.xml', odataResult.services[serviceName].annotations);
      }
      // <service>.xml (combined)
      if (odataResult.services[serviceName].combined) {
        writeToFileOrDisplay(options.out, serviceName + '.xml', odataResult.services[serviceName].combined);
      }
      // <service>.json (metadata_json)
      if (odataResult.services[serviceName].metadata_json) {
        writeToFileOrDisplay(options.out, serviceName + '.json', odataResult.services[serviceName].metadata_json);
      }
    }
    // odata_csn.json resp. odata_csn_raw.txt
    if (odataResult._augmentedCsn) {
      displayNamedCsn(odataResult._augmentedCsn, 'odata_csn', options);
    }
    return model;
  }

  // Execute the command line option '--to-rename' and display the results.
  // Return the original model (for chaining)
  function toRename( model ) {
    let renameResult = compiler.toRename(model);
    for (let name in renameResult.rename) {
      writeToFileOrDisplay(options.out, 'rename_' + name + '.sql', renameResult.rename[name] + '\n', true);
    }
    return model;
  }

  // Execute the command line option '--to-sql' and display the results.
  // Return the original model (for chaining)
  function toSql( model ) {
    let sqlResult = compiler.toSql(model);
    for (let name in sqlResult.sql) {
      writeToFileOrDisplay(options.out, name + '.sql', sqlResult.sql[name] + '\n', true);
    }
    if (sqlResult.csn) {
      displayNamedCsn(sqlResult._augmentedCsn, 'sql_csn', options);
    }
    return model;
  }

  // Execute the command line option '--to-swagger' and display the results.
  // Return the original model (for chaining)
  function toSwagger( model ) {
    let swaggerResult = compiler.toSwagger(model);
    for (let serviceName in swaggerResult.services || {}) {
      writeToFileOrDisplay(options.out, `${serviceName}_swagger.json`, swaggerResult.services[serviceName], false);
    }
    if (swaggerResult.csn) {
      displayNamedCsn(swaggerResult._augmentedCsn, 'swagger_csn', options);
    }
    return model;
  }

  // Execute the (old) command line option '--tnt-output' and display the results.
  // FIXME: This is the only one that cannot yet be composed from others
  // Return the original model (for chaining)
  function tntOutput( model ) {
    // TODO: use async file-system API
    // Perform TNT-specific post-processing
    let result = compiler.toTntSpecificOutput(model, model.options);
    // Write result to files in target directory
    // FIXME: Check in options which parts actually need to be generated
    // Write annotations.xml and metadata.xml only if there is exactly one service
    // FIXME: For backward compatibility only, should be removed soon
    if (result.annotations && result.metadata) {
      writeToFileOrDisplay(model.options.out, 'annotations.xml', result.annotations);
      writeToFileOrDisplay(model.options.out, 'metadata.xml', result.metadata);
    }
    writeToFileOrDisplay(model.options.out, 'csn.json', result.csn);
    for (let serviceName in result.services) {
      writeToFileOrDisplay(model.options.out, serviceName + '_annotations.xml', result.services[serviceName].annotations);
      writeToFileOrDisplay(model.options.out, serviceName + '_metadata.xml', result.services[serviceName].metadata);
    }
    return model;
  }

  // Display error messages in `err` resulting from a compilation.  Also set
  // process.exitCode - process.exit() will force the process to exit as quickly
  // as possible = is problematic, since console.error() might be asynchronous
  function displayErrors (err) {
    if (options.rawOutput) {
      err.model = reveal( err.model );
      console.error( util.inspect( err, false, null ));
      process.exitCode = 1;
    }
    else if (err instanceof compiler.CompilationError) {
      displayMessages( err.model, err.errors );
      process.exitCode = 1;
    }
    else if (err instanceof compiler.InvocationError) {
      console.error( '' );
      for (let sub of err.errors)
        console.error( sub.message );
      console.error( '' );
      process.exitCode = 2;
    }
    else
      throw err;

    err.hasBeenReported = true;
    throw err;
  }

  function displayMessages( model, messages = model.messages ) {
    if (messages instanceof Array)
    {
      for (let msg of messages) {
        if (messageLevels[ msg.severity ] <= options.warning)
          console.error( compiler.messageString( msg, normalizeFilename, !options.showMessageId ) );
      }
    }
    return model;
  }

  // Write the model 'model' to file '<name>.{json|raw.txt}' in directory 'options.out',
  // or display it to stdout if 'options.out' is '-'.
  // Depending on 'options.rawOutput', the model is either compacted to 'name.json' or
  // written in raw form to '<name>_raw.txt'.
  function displayNamedCsn(model, name, options) {
    if (options.rawOutput) {
      writeToFileOrDisplay(options.out, name + '_raw.txt', util.inspect(reveal(model), false, null), true);
    }
    else if (options.newCsn) {
      writeToFileOrDisplay(options.out, name + '.json', compiler.compactModel(model), true);
    }
    else {
      writeToFileOrDisplay(options.out, name + '.json', compiler.compactSortedJson(model), true);
    }
  }

  // Write the result 'content' to a file 'filename' in directory 'dir', except if 'dir' is '-'.
  // In that case, display 'content' to stdout.
  // If 'content' is not a string, JSON-stringify it
  // If displaying to stdout, prepend a headline containing 'filename', unless 'omitHeadline' is set.
  // For filenames, illegal characters (slash, backslash, colon) are replaced by '_'.
  function writeToFileOrDisplay(dir, filename, content, omitHeadline = false) {
    filename = filename.replace(/[:/\\]/g, '_');
    if (!(content instanceof String || typeof content == 'string')) {
      content = JSON.stringify(content, null, 2);
    }
    if (dir == '-') {
      if (!omitHeadline) {
        process.stdout.write(`// ------------------- ${filename} -------------------\n`);
      }
      process.stdout.write(`${content}\n`);
      if (!omitHeadline) {
        process.stdout.write(`\n`);
      }
    } else {
      // TODO: We might consider using async file-system API ...
      fs.writeFileSync(path.join(dir, filename), content);
    }
  }

  function catchErrors (err) {
    if (err instanceof Error && err.hasBeenReported)
      return;
    console.error( '' );
    console.error( 'INTERNAL ERROR: %s', err );
    console.error( util.inspect(err, false, null) );
    console.error( '' );
    process.exitCode = 70;
  }
}
