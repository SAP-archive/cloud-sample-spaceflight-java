const {SessionInstanceError, SessionSingletonError} = require('../errors')
const Session = require('./Session')

// Runtime-wide symbol registry instead of global variables as it does not have side effects with caching and Common.js
// Will not solve dependency issues when two packages require different versions of this package.
const SINGLETON_KEY = Symbol.for('cds.ql.session')

/**
 * Check if a session instance is exists.
 * @returns {boolean}
 * @private
 */
const noSessionInstance = () => {
  const globalSymbols = Object.getOwnPropertySymbols(global)

  return (globalSymbols.indexOf(SINGLETON_KEY) === -1 || !global[SINGLETON_KEY])
}

/**
 * Create a singleton session instance to a database.
 * @param {Object} [options] - Driver, connect and pool options.
 * @param {string|function} [options.driver] - Reference to a client facade or dependency injection of a custom one.
 * @param {string} [options.url] - Connect options in url format.
 * @param {Object} [options.pool] - The min and max pool options.
 * @param {number} [options.pool.min] - The minimum number of db connection clients.
 * @param {number} [options.pool.max] - The maximum number of db connection clients.
 * @param {number} [options.pool.evictionRunIntervalMillisForPools] - The time interval in ms until an idle pool is
 * evicted.
 * Default 60000 ms (1 min).
 * @param {number} [options.pool.evictionRunIntervalMillis] - The time interval in ms for an eviction check of idle db
 * clients in a pool.
 * Default 10000 ms (10 s).
 * @param {number} [options.pool.numTestsPerEvictionRun] - The number of db clients to be checked in each eviction run.
 * Defaults to half of options.pool.min, but at least 2.
 * @param {number} [options.pool.softIdleTimeoutMillis] - The time interval in ms until a db client in idle state is
 * considered as 'to be evicted'. Does not evict idle db clients if number of available clients would fall below
 * options.pool.min.
 * Default 30000 ms (30 s).
 * @param {number} [options.pool.idleTimeoutMillis] - The time interval in ms until a db client in idle state is
 * considered as 'to be evicted'. If number of available clients would fall below options.pool.min it evicts this
 * client and creates a new one to meet options.pool.min.
 * Default 480000 ms (8 min).
 * @param {string} [options.host] - Address to the db
 * @param {string} [options.port] - Port for db
 * @param {string} [options.user] - Username for authentication
 * @param {string} [options.password] - Password for authentication
 * @returns {Promise} promise resolves if session creation was successful, rejects if not
 */
const connect = (options) => {
  if (!noSessionInstance()) {
    throw new SessionSingletonError()
  }

  global[SINGLETON_KEY] = new Session(options)

  return global[SINGLETON_KEY]
}

/**
 * Acquires a db client from the session.
 * @param {Object} [clientOptions] - Client settings
 * @param {string} [clientOptions.user] - The user name for the db connection.
 * @param {string} [clientOptions.locale] - The language identifier.
 * @returns {Promise.<Object>} A promise for the acquired db client.
 * @alias module:singleton.acquire
 */
const acquire = (clientOptions) => {
  if (noSessionInstance()) {
    return Promise.reject(new SessionInstanceError())
  }

  return global[SINGLETON_KEY].acquire(clientOptions)
}

/**
 * Releases a db client to be reused by the session.
 * @param {Client} client - The client that should be released
 * @returns {Promise} A promise for the release of the client
 * @alias module:singleton.release
 */
const release = (client) => {
  if (noSessionInstance()) {
    return Promise.reject(new SessionInstanceError())
  }

  return global[SINGLETON_KEY].release(client)
}

/**
 * Destroy a db client to be recreated by the session.
 * @param {Client} client - The client that should be destroyed
 * @returns {Promise} A promise for the destruction of the client
 * @alias module:singleton.release
 */
const destroy = (client) => {
  if (noSessionInstance()) {
    return Promise.reject(new SessionInstanceError())
  }

  return global[SINGLETON_KEY].destroy(client)
}

/**
 * Disconnects and deletes the session instance.
 * @returns {Promise} Promise without a parameter.
 * @alias module:singleton.disconnect
 */
const disconnect = () => {
  if (noSessionInstance()) {
    return Promise.reject(new SessionInstanceError())
  }

  return global[SINGLETON_KEY].disconnect()
    .then(() => {
      // use both as Node.js v6.7.0 cannot delete properly
      global[SINGLETON_KEY] = undefined
      delete global[SINGLETON_KEY]
    })
}

/**
 * Checks if a session instance is available
 * @returns {boolean} true if session is available
 */
const hasSession = () => {
  return (!noSessionInstance())
}

/**
 * Execute CQN or SQL outside of the odata package.
 *
 * @param {string|object} query - SQL string or CQN object generated by the DML statements.
 * @param {Array} [values] - Values to be set in the SQL statement if query is provided as string.
 * @returns {Promise} Promise, that resolves with result object (array) if successful or rejects with error if not.
 *
 */
const run = (query, values) => {
  if (noSessionInstance()) {
    return Promise.reject(new SessionInstanceError())
  }

  return global[SINGLETON_KEY].run(query, values)
}

/**
 * Executes the statement and processes the result set one by one.
 * Should be used if huge result sets are expected to process it in a streaming-like fashion
 * instead of materializing the full set in memory before.
 *
 * @param {string|object} query - SQL string or CQN object generated by the DML statements.
 * @param {Array} [values] - Values to be set in the SQL statement if query is provided as string.
 * @param {function} cb - synchronous function to process each row of the result set.
 * @returns {Promise} Promise, that resolves with undefined if successful or rejects with error if not.
 */
const foreach = (query, values, cb) => {
  if (noSessionInstance()) {
    return Promise.reject(new SessionInstanceError())
  }

  return global[SINGLETON_KEY].foreach(query, values, cb)
}

/**
 * Drops all tables/views and creates them again
 * @param {object} csn the unreflected CSN.
 * @returns {Promise} Promise, that resolves with undefined if successful or rejects with error if not.
 */
const deploy = (csn) => {
  if (noSessionInstance()) {
    return Promise.reject(new SessionInstanceError())
  }

  return global[SINGLETON_KEY].deploy(csn)
}

/**
 * @module singleton
 */
module.exports = {
  acquire,
  connect,
  destroy,
  disconnect,
  hasSession,
  release,
  run,
  foreach,
  deploy
}
