const Pool = require('./Pool')
const {IllegalFunctionArgumentError} = require('../errors')

/**
 * Session to acquire db connection clients.
 */
class Session {
  /**
   * Creates a Session according to the given pool settings (minimum and maximum number of clients) and client settings
   * (db client type and connection options).
   *
   * @param {Object} options - Pool and Client settings
   * @param {Object} [options.pool] - The min and max pool settings.
   * @param {number} [options.pool.min] - The minimum number of db connection clients.
   * @param {number} [options.pool.max] - The maximum number of db connection clients.
   * @param {number} [options.pool.idleTimeoutMillisForPools] - The time interval in ms until an idle pool is
   * evicted.
   * Default 60000 ms (1 min).
   * @param {number} [options.pool.evictionRunIntervalMillis] - The time interval in ms for an eviction check of idle db
   * clients in a pool.
   * Default 10000 ms (10 s).
   * @param {number} [options.pool.numTestsPerEvictionRun] - The number of db clients to be checked in each eviction run.
   * Defaults to half of options.pool.min, but at least 2.
   * @param {number} [options.pool.softIdleTimeoutMillis] - The time interval in ms until a db client in idle state is
   * considered as 'to be evicted'. Does not evict idle db clients if number of available clients would fall below
   * options.pool.min.
   * Default 30000 ms (30 s).
   * @param {number} [options.pool.idleTimeoutMillis] - The time interval in ms until a db client in idle state is
   * considered as 'to be evicted'. If number of available clients would fall below options.pool.min it evicts this
   * client and creates a new one to meet options.pool.min.
   * Default 480000 ms (8 min).
   * @param {Object} options.driver - The to be used DB client.
   * @param {string} [options.host] - Address to the db
   * @param {string} [options.port] - Port for db
   * @param {string} [options.user] - Username for authentication
   * @param {string} [options.password] - Password for authentication
   * @param {boolean} [options.multiTenant] - true, if mt is active
   */
  constructor (options) {
    this._options = this._getOptions(options)
    this._pools = new Map()
  }

  /**
   * Get defaults or additional data for the given options.
   * @param {Object} options
   * @returns {Object}
   * @private
   */
  _getOptions (options) {
    if (!options) {
      options = this._getFromPackageJson()
    }

    if (typeof options === 'number' || typeof options === 'function') {
      throw new IllegalFunctionArgumentError('options')
    }

    if (typeof options === 'string') {
      options = this._parseConnectUrl(options)
    }

    if (!options.user && (options.tag || options.service)) {
      this._addCredentialsFromXsEnv(options)
    }

    const resourcesToBeChecked = options.pool && options.pool.min > 2 ? Math.ceil(options.pool.min / 2) : 2

    options.pool = Object.assign({
      idleTimeoutMillisForPools: 60000,
      evictionRunIntervalMillis: 10000,
      numTestsPerEvictionRun: resourcesToBeChecked,
      softIdleTimeoutMillis: 30000,
      idleTimeoutMillis: 480000
    }, options.pool, {testOnBorrow: true})

    this._addDriverToOptions(options)

    return options
  }

  /**
   * The credentials might be configured at the package.json
   * @returns {Object}
   * @private
   */
  _getFromPackageJson () {
    const {config: {data = {}}} = require('../cds')
    return Object.assign({pool: {}}, data)
  }

  /**
   * Parse a connect string into options.
   * @param {string} url
   * @returns {Object}
   * @private
   */
  _parseConnectUrl (url) {
    const matches = url.match((/^(?:(?:(\w+):)(.+)|([^:]+))$/))

    return {
      driver: matches[3] ? 'sqlite' : matches[1],
      host: matches[3] || matches[2]
    }
  }

  _addCredentialsFromXsEnv (options) {
    const properties = ['name', 'label', 'tag', 'plan']
    const filter = {}

    for (const property of properties) {
      if (options[property]) {
        filter[property] = options[property]
      }
    }

    // options from xsenv will contain the property driver, which overwrites the one defined at connect.
    Object.assign(options, this._xsenv.cfServiceCredentials(filter), {driver: options.driver})
  }

  get _xsenv () {
    return require('@sap/xsenv')
  }

  /**
   * In case the driver is provided as string, require and use the package
   * @param {Object} options
   * @private
   */
  _addDriverToOptions (options) {
    if (typeof options.driver === 'function') {
      return
    }

    const driverPackage = this._getDriverPackageById(options.driver)

    if (options.multiTenant === true) {
      this._enrichOptions = driverPackage.options
    } else {
      driverPackage.options(options)
    }

    driverPackage.inject(require('../cds').cds)

    options.driver = driverPackage.Client

    if (!options.driver.prototype._runBlock) {
      options.driver.prototype._runBlock = require('../statements/runBlock')

      if (process.env.DEBUG) {
        this._addDebugToDriver(options.driver)
      }
    }
  }

  _addDebugToDriver (driver) {
    // The driver has a different method for select and transactions
    if (driver.prototype._runSingle) {
      driver.prototype._executeSelect = this._decorated(driver.prototype._executeSelect)
      driver.prototype._runSingle = this._decorated(driver.prototype._runSingle)

      return
    }

    driver.prototype._executeSQL = this._decorated(driver.prototype._executeSQL)
  }

  _decorated (fn) {
    const {stdout} = require('./debug')

    return function (...args) {
      if (args.length > 2) {
        stdout(args[0], args[1])
      } else {
        stdout(...args)
      }

      return fn.apply(this, args)
    }
  }

  /**
   * Provided drivers will have the @sap group and cds- prefix.
   * Custom can have any string.
   * @param driverId
   * @returns {*}
   * @private
   */
  _getDriverPackageById (driverId) {
    const driver = driverId || 'sqlite'

    switch (driver) {
      case 'hana':
      case 'sqlite':
        return require(`@sap/cds-${driver}`)
      default:
        return require(driver)
    }
  }

  /**
   * Acquires a db client from the session.
   * @param {Object} [clientOptions] - Client settings
   * @param {string} [clientOptions.user] - The user name for the db connection.
   * @param {string} [clientOptions.locale] - The language identifier.
   * @param {string} [clientOptions.JWT] - Full JWT from (HTTP) request.
   * @param {string} [clientOptions.tenantId] - GUID of a tenant.
   * @returns {Promise.<Object>} A promise for the acquired db client.
   */
  acquire (clientOptions = {}) {
    let poolKey

    try {
      poolKey = this._getPoolIdentifier(clientOptions.tenantId)
    } catch (err) {
      return Promise.reject(err)
    }

    const pool = this._pools.get(poolKey)

    // First call, or pool has been invalidated
    if (!pool) {
      return this._createPool(poolKey)
        .then((pool) => {
          return this._acquire(pool, poolKey, clientOptions)
        })
    }

    // Test connect or instance manager call is not finished yet
    if (pool instanceof Promise) {
      return pool.then(() => {
        return this._acquire(this._pools.get(poolKey), poolKey, clientOptions)
      })
    }

    return this._acquire(pool, poolKey, clientOptions)
  }

  /**
   * Get the identifier for the pool.
   * @param {string} tenantId
   * @returns {string}
   * @private
   */
  _getPoolIdentifier (tenantId) {
    if (this._options.multiTenant) {
      if (tenantId) {
        return tenantId
      }

      throw new IllegalFunctionArgumentError('tenantId')
    }

    return 'singleTenant'
  }

  _handlePoolEviction (pool) {
    if (pool.noClientsBorrowed) {
      return this._disconnect(pool, pool._name)
    }
  }

  _clearPoolTimeout (pool) {
    if (pool._timeout !== undefined) {
      clearTimeout(pool._timeout)
      delete pool._timeout
    }
  }

  _setPoolTimeout (pool) {
    if (this._options.pool.idleTimeoutMillisForPools > 0) {
      this._clearPoolTimeout(pool)

      pool._timeout = setTimeout(() => {
        this._handlePoolEviction(pool)
      }, this._options.pool.idleTimeoutMillisForPools)
    }
  }

  /**
   * Create a pool instance if a test connect succeeds.
   * @param poolKey
   * @returns {*|Function|Promise<T>}
   * @private
   */
  _createPool (poolKey) {
    const ready = this._getAndCheckCredentials(poolKey)
      .then((options) => {
        const pool = new Pool(options)
        pool._name = poolKey
        this._pools.set(poolKey, pool)

        return pool
      })
      .catch(err => {
        // Crash the node instance on purpose
        setImmediate(() => {
          throw err
        })

        // Throw again or other errors will occur until next tic is reached.
        throw err
      })

    this._pools.set(poolKey, ready)

    return ready
  }

  /**
   * Load credentials from instance manager if needed.
   * Test connect in any case.
   * @param {string} tenantId
   * @returns {Object}
   * @private
   */
  _getAndCheckCredentials (tenantId) {
    if (this._options.multiTenant) {
      return this._getServiceCredentials(tenantId)
        .then((options) => {
          return this._testConnection(options)
        })
    }

    return this._testConnection(this._options)
  }

  /**
   * Get the credentials for a service by id.
   * @param tenantId
   * @returns {*}
   * @private
   */
  _getServiceCredentials (tenantId) {
    if (!this._instanceManager) {
      return this._getInstanceManager()
        .then(() => {
          return this._getInstanceCredentials(tenantId)
        })
    }

    return this._getInstanceCredentials(tenantId)
  }

  /**
   * Used to initialize the instance manager only once.
   * @returns {Promise}
   * @private
   */
  _getInstanceManager () {
    return new Promise((resolve, reject) => {
      // require only when needed
      require('@sap/instance-manager').create(this._options, (err, instanceManager) => {
        if (err) {
          reject(err)
          return
        }

        this._instanceManager = instanceManager
        resolve()
      })
    })
  }

  /**
   * Use the instance manager instance to get the actual credentials.
   * @param tenantId
   * @returns {Promise<any>}
   * @private
   */
  _getInstanceCredentials (tenantId) {
    return new Promise((resolve, reject) => {
      this._instanceManager.get(tenantId, (err, instance) => {
        if (err) {
          reject(err)
          return
        }

        // Get defaults from general options; mostly pool options are relevant
        const defaultOptions = Object.assign({}, this._options)

        // A client might not provide the "options" function
        if (this._enrichOptions) {
          this._enrichOptions(defaultOptions)
        }

        if (!instance || !instance.credentials) {
          reject(new IllegalFunctionArgumentError('tenantId'))
          return
        }

        // Merge with options from , so one can set certain options like pool.
        resolve(Object.assign(defaultOptions, {
          host: instance.credentials.host,
          port: instance.credentials.port,
          user: instance.credentials.user,
          password: instance.credentials.password,
          schema: instance.credentials.schema,
          ca: instance.credentials.certificate
        }))
      })
    })
  }

  /**
   * Test the credentials by doing a test connect.
   * @param {Object} options
   * @returns {Promise<Object>}
   * @private
   */
  _testConnection (options) {
    const Client = this._options.driver
    const client = new Client(options)

    return client.connect()
      .then(() => {
        return client.end()
      })
      .then(() => {
        return options
      })
  }

  /**
   * Acquire a client from the pool.
   * @param {Object} pool
   * @param {Object} poolKey
   * @param {Object} clientOptions
   * @returns {Promise}
   * @private
   */
  _acquire (pool, poolKey, clientOptions) {
    return pool.acquire(clientOptions)
      .then((client) => {
        // add information to client, so it can be returned to correct pool.
        client._poolKey = poolKey

        return client
      })
  }

  /**
   * Releases a db client to be reused by the session.
   * @param {Client} client - The client that should be released
   * @returns {Promise} A promise for the release of the client
   */
  release (client) {
    return this._destroyRelease('release', client)
  }

  /**
   * Destroys a db client to be recreated by the session.
   * @param {Client} client - The client that should be destroyed
   * @returns {Promise} A promise for the destruction of the client
   */
  destroy (client) {
    return this._destroyRelease('destroy', client)
  }

  _destroyRelease (command, client) {
    const pool = this._getPoolFromClient(client)

    if (!pool) {
      return Promise.reject(new Error('bla'))
    }

    this._setPoolTimeout(pool)

    return pool[command](client)
  }

  _getPoolFromClient (client) {
    const pool = this._pools.get(client._poolKey)

    delete client._poolKey

    return pool
  }

  /**
   * Drain the instance of all clients.
   * Allows a graceful shutdown of the complete session instance.
   */
  disconnect () {
    if (this._pools.size === 0) {
      return Promise.resolve()
    }

    const disconnects = []

    for (const [poolKey, pool] of this._pools) {
      disconnects.push(this._disconnect(pool, poolKey))
    }

    return Promise.all(disconnects)
  }

  _disconnect (pool, poolKey) {
    // Test connect or instance manager call is not finished yet
    if (pool instanceof Promise) {
      return pool.then(() => {
        return this._cleanupPool(this._pools.get(poolKey), poolKey)
      })
    }

    return this._cleanupPool(pool, poolKey)
  }

  _cleanupPool (pool, poolKey) {
    return pool.disconnect()
      .then(() => {
        this._clearPoolTimeout(pool)
        this._pools.delete(poolKey)
      })
  }

  /**
   * Execute CQN or SQL outside of the odata package.
   *
   * @param {string|object} query - SQL string or CQN object generated by the DML statements.
   * @param {Array} [values] - Values to be set in the SQL statement if query is provided as string.
   * @returns {Object} thenable, that resolves with result object (array) if successful or rejects with error if not.
   *
   */
  run (query, values) {
    const runs = []
    const promise = this.acquire()
      .then((client) => {
        let chain = client.run(query, values)

        for (const args of runs) {
          chain = chain.then(() => {
            return client.run(...args)
          })
        }

        return chain
          .then((res) => {
            return this.release(client)
              .then(() => {
                return res
              })
          })
          .catch((err) => {
            return this.release(client)
              .then(() => {
                throw err
              })
          })
      })

    const then = (fn) => {
      return promise.then(fn)
    }
    const end = {
      then: then,
      catch: (fn) => {
        return promise.catch(fn)
      }
    }
    then.run = (...args) => {
      runs.push(args)
      return end
    }

    return end
  }

  /**
   * Executes the statement and processes the result set one by one.
   * Should be used if huge result sets are expected to process it in a streaming-like fashion
   * instead of materializing the full set in memory before.
   *
   * @param {string|object} query - SQL string or CQN object generated by the DML statements.
   * @param {Array} [values] - Values to be set in the SQL statement if query is provided as string.
   * @param {function} cb - synchronous function to process each row of the result set.
   * @returns {Promise} Promise, that resolves with undefined if successful or rejects with error if not.
   */
  foreach (query, values, cb) {
    return this.acquire()
      .then((client) => {
        return client.foreach(query, values, cb)
          .then(() => this.release(client))
          .catch((err) => {
            return this.release(client)
              .then(() => {
                throw err
              })
          })
      })
  }

  /**
   * Drops all tables/views and creates them again
   * @param {object} csn the unreflected CSN.
   * @returns {Promise} Promise, that resolves with undefined if successful or rejects with error if not.
   */
  deploy (csn) {
    return this.acquire()
      .then((client) => {
        return client.deploy(this._load(csn))
          .then(() => this.release(client))
          .catch((err) => {
            return this.release(client)
              .then(() => {
                throw err
              })
          })
          .then(this.runInit)
      })
  }

  runInit () {
    // first try to load w/o executing
    let init

    try {
      const path = require('path')
      init = require.resolve(path.resolve('db/init'))
    } catch (err) {
      if (err.code !== 'MODULE_NOT_FOUND') {
        throw err
      }
    }

    // then execute w/o ignoring errors
    if (init) {
      return require(init)
    }
  }

  _load (csn, ...args) {
    const {load, reflect} = require('../cds')

    if (typeof csn === 'string') {
      args.unshift(csn)

      return load(args)
        .then((csn) => {
          this.model = reflect(csn)

          return csn
        })
    }

    this.model = reflect(csn)
    return csn
  }
}

if (process.env.DEBUG) {
  const {stdout} = require('./debug')
  class DebugSession extends Session {
    acquire (...args) {
      stdout('acquire connection')
      return super.acquire(...args)
    }
    release (...args) {
      stdout('release connection')
      return super.release(...args)
    }
    disconnect () {
      stdout('disconnect session')
      return super.disconnect()
    }
  }

  module.exports = DebugSession
} else {
  module.exports = Session
}
