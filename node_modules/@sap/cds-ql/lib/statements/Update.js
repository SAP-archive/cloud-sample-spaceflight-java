const Where = require('./Where')
const {
  IllegalFunctionArgumentError
} = require('../errors')

/**
 * UPDATE statement updates values or rows from a specific table.
 * @extends {Where}
 */
class Update extends Where {
  constructor () {
    super('UPDATE')
  }

  static entity (entity) {
    const cqn = new Update()
    cqn.UPDATE.entity = Where._isEntity(entity)

    return cqn
  }

  /**
   * Sets the values that should be updated
   *
   * @example
   * UPDATE('Authors').set({NAME: 'Jon Doe', STOCK: 123})
   *
   * @param {object} valueObject contains the properties that should be updated
   */
  set (valueObject) {
    if (this._isInvalidValueObject(valueObject)) {
      throw new IllegalFunctionArgumentError('values')
    }

    this.UPDATE.data = this._convertToCqnObject(valueObject)
    return this
  }

  _convertToCqnObject (valueObject) {
    const cqnObj = {}
    for (const key in valueObject) {
      cqnObj[key] = this._generateValObj(valueObject[key], key)
    }
    return cqnObj
  }

  _generateValObj (value, key) {
    if (value === null || value === undefined) {
      return {val: null}
    }

    if (['-=', '+=', '*=', '/=', '%='].includes(Object.keys(value)[0])) {
      const op = Object.keys(value)[0]
      const val = value[op]
      return {xpr: [{ref: [key]}, op.substring(0, 1), {val: val}]}
    }

    if (value['=']) {
      return {ref: [value['=']]}
    }

    return {val: value}
  }

  _isInvalidValueObject (valueObject) {
    if (!(valueObject instanceof Object) || Array.isArray(valueObject)) {
      return true
    }

    for (const key of Object.keys(valueObject)) {
      if (valueObject[key] === undefined || (valueObject[key] instanceof Object && Object.keys(valueObject[key]).length === 0)) {
        return true
      }
    }

    return false
  }

  valueOf () {
    return `UPDATE "${this.UPDATE.entity}" `
  }
}

module.exports = Update
