const BaseStatement = require('./BaseStatement')
const {IllegalFunctionArgumentError} = require('../errors')

/**
 * Insert values into table
 */
class Insert extends BaseStatement {
  constructor () {
    super('INSERT')
  }

  /**
   * Name of the entity where the entries should be inserted
   *
   * @example <caption>In case the order of columns is known, their names can be omitted</caption>
   * INSERT.into('Books')
   *  .rows([1, 'Harry Potter'])
   *
   * @example <caption>In case the order of columns is unknown, specify the name of the columns</caption>
   * INSERT.into('Books')
   *  .columns('ID', 'NAME')
   *  .rows([1, 'The Hitchhikers Guide to the Galaxy'])
   *
   * @example <caption>Use an object instead of array</caption>
   * INSERT.into('Books')
   *  .rows({ID:1, NAME: 'Animal Farm'})
   *
   * @param {string|object} entity string or an entity from reflection API
   *
   * @returns {Insert} CQN object for Insert
   */
  static into (entity) {
    const cqn = new Insert()
    cqn.INSERT.into = BaseStatement._isEntity(entity)

    return cqn
  }

  /**
   * Optional. Can be used to order the value entries if column names are known
   * @param {Array} columnNames - names of the columns
   * @param {Array} args - List of columns in case one arguemnt per column is used
   * @returns {Insert} current instance of the insert
   */
  columns (columnNames, ...args) {
    if (typeof columnNames === 'string') {
      args.unshift(columnNames)
      columnNames = args
    }

    if (Array.isArray(columnNames)) {
      this.INSERT.columns = columnNames
      return this
    }

    throw new IllegalFunctionArgumentError('columnNames')
  }

  /**
   * Adds one or multiple rows to the table.
   *
   * @example <caption>In case the order of columns is known, their names can be omitted</caption>
   * INSERT.into('Books')
   *   .rows([1, 'Harry Potter'])
   *
   * @example <caption>If order is unknown specify the name of the columns</caption>
   * INSERT.into('Books')
   *   .columns('ID', 'NAME')
   *   .rows([1, 'The Hitchhikers Guide to the Galaxy'])
   *
   * @example <caption>Use an object instead of array</caption>
   * INSERT.into('Books')
   *   .rows({ID:1, NAME: 'Animal Farm'})
   *
   * @example <caption>Batch insert</caption>
   * INSERT.into('Books').rows([
   *   [1, 'Harry Potter'],
   *   [2, 'The Hitchhikers Guide to the Galaxy'],
   *   [3, 'Animal Farm']
   * ])
   * @example <caption>Batch insert with objects</caption>
   * INSERT.into('Books').rows([
   *   {ID:1, NAME: 'Harry Potter'},
   *   {ID:2, NAME: 'The Hitchhikers Guide to the Galaxy'},
   *   {ID:3, NAME: 'Animal Farm'}
   * ])
   *  @param {array|object} rows
   *  @returns {object} query object according to CQN format
   */
  rows (rows, ...args) {
    if (!rows) {
      throw new IllegalFunctionArgumentError('rows')
    }

    if (Array.isArray(rows)) {
      // check if we have at least one element
      if (rows.length === 0) {
        throw new IllegalFunctionArgumentError('rows')
      }

      // check if all the entries in the array are arrays
      if (rows.every(e => Array.isArray(e))) {
        this._rows(rows)
        // check if array contains one or multiple objects
      } else if (rows.every(e => typeof e === 'object')) {
        this._entries(rows)
        // the rows have been added as arguments
      } else if (args.length !== 0) {
        args.unshift(rows)
        this._rows(args)
      } else {
        this._values(rows)
      }
    } else if (typeof rows === 'object') {
      this._entries(rows)
    } else {
      throw new IllegalFunctionArgumentError('rows')
    }

    return this
  }

  /**
   * Adds one or more entries as rows.
   */
  entries (...args) {
    const entries = (Array.isArray(args[0])) ? args[0] : args
    this._invalidArgs('entries', entries)
    return this.rows(entries)
  }

  values (...args) {
    const values = (Array.isArray(args[0])) ? args[0] : args
    this._invalidArgs('values', values)
    this._values(values)
    return this
  }

  _invalidArgs (argName, args) {
    if (!Array.isArray(args) || args.length === 0) {
      throw new IllegalFunctionArgumentError(argName)
    }
  }

  _rows (rows) {
    this.INSERT.rows = rows
  }

  _values (values) {
    this.INSERT.values = values
  }

  _entries (entries) {
    // object can be passed directly, so if only 1 object is passed wrap it into an array
    this.INSERT.entries = (Array.isArray(entries)) ? entries : [entries]
  }

  valueOf () {
    return `INSERT INTO "${this.INSERT.into}" `
  }
}

module.exports = Insert
