const BaseStatement = require('./BaseStatement')
const {
  IllegalFunctionArgumentError,
  UnexpectedFunctionCallError
} = require('../errors')
const cds = require('../cds')

class Where extends BaseStatement {
  _getCQN () {
    if (this.SELECT) {
      return this.SELECT
    }

    if (this.UPDATE) {
      return this.UPDATE
    }

    return this.DELETE
  }

  /**
   * Build 'where' cqn object. Can be chained and will always connect the chained where with an 'and'.
   *
   * Possible uses:
   * where('ID', <value>)
   * where('ID', '<operator>', <value>)
   * where('ID', 'between', <value>, <value>)
   * where('ID', '<operator>', <query>)
   * where('Association.name', '<operator>', <value>)
   * where('lower(column)', '<operator>', <value>)
   * where('contains', <arrayOfColumns>, <searchTerm>)
   * where(<object>)
   * Fluid usage with alternating string value arguments
   * where(arg1, arg2, arg3, arg4, arg5, ...)
   *
   * @example
   * where('ID', 7411)
   * where('ID', '>', 7411)
   * where({ ID: 7411})
   * Fluid usage:
   * where(`name like`, 'foo', `and ( ratio between`, 0.1, `and`, 0.3, `or ratio >`, 0.9, ')')
   *
   * @param {string|Object} arg1 Can be object if argument is passed as an object or can be a string when an identifier is directly passed.
   * @param {*} [arg2] Can be a value or an operator if the 3rd argument is the value.
   * @param [arg3] Value or CQN if second argument is operator.
   * @param [arg4] Value in case the second argument is the 'between' operator; Otherwise ignored.
   * @returns {Object} this object instance for chaining.
   * @throws WhereCalledError - If where was already called.
   * @throws UnexpectedFunctionCallError - If called in wrong context
   */
  where (arg1, arg2, arg3, arg4) {
    if (this._getCQN().having) {
      throw new UnexpectedFunctionCallError('where')
    }

    if (this._getCQN().where) {
      return this._andWhere(...arguments)
    }

    this._getCQN().where = []
    return this._where(...arguments)
  }

  /**
   * .and can only be used after .join has been called.
   * @param {string|Object} arg1 Can be object if argument is passed as an object or can be a string when an identifier is directly passed.
   * @param {*} [arg2] Can be a value or an operator if the 3rd argument is the value.
   * @param [arg3] Value or CQN if second argument is operator.
   * @param [arg4] Value in case the second argument is the 'between' operator; Otherwise ignored.
   * @returns {Object} this object instance for chaining.
   * @throws UnexpectedFunctionCallError - If called without calling join or where before.
   */
  and (arg1, arg2, arg3, arg4) {
    return this._logicOperation('and', arg1, arg2, arg3, arg4)
  }

  /**
   * .byId filters on the column 'id'. It can only be used if .where has not been called yet.
   * @param {string} arg1 is the value on which the filtering should be performed.
   * @returns {Object} this object instance for chaining
   */
  byId (arg1) {
    return this.where('id', arg1)
  }

  /**
   * .or can be only used after .where has been called.
   * @param {string|Object} arg1 Can be object if argument is passed as an object or can be a string when an identifier is directly passed.
   * @param {*} [arg2] Can be a value or an operator if the 3rd argument is the value.
   * @param [arg3] Value or CQN if second argument is operator.
   * @param [arg4] Value in case the second argument is the 'between' operator; Otherwise ignored.
   * @returns {Object} this object instance for chaining.
   * @throws UnexpectedFunctionCallError - If called without calling join or where before.
   */
  or (arg1, arg2, arg3, arg4) {
    return this._logicOperation('or', arg1, arg2, arg3, arg4)
  }

  _andWhere (arg1, arg2, arg3, arg4) {
    const needBrackets = arg1 instanceof Object && arg1.or
    this._getCQN().where.push('and')

    if (needBrackets) {
      // in case of function 'and' was called and an object input param containing an 'or' we need to add brackets
      this._getCQN().where.push('(')
      this._where(...arguments)
      this._getCQN().where.push(')')

      return this
    }

    return this._where(...arguments)
  }

  _logicOperation (operator, arg1, arg2, arg3, arg4) {
    const isJoin = this._getCQN().from.hasOwnProperty('join')
    const isWhere = this._getCQN().where && this._getCQN().where.length > 0
    const isHaving = this._getCQN().having && this._getCQN().having.length > 0
    const needBrackets = arg1 instanceof Object && operator === 'and' && arg1.or

    if (isHaving && operator === 'or') {
      this._getCQN().having.push(operator)
      if (needBrackets) {
        // in case of function 'and' was called and an object input param containing an 'or' we need to add brackets
        this._getCQN().having.push('(', ...this._parseArguments(arg1, arg2, arg3, arg4), ')')

        return this
      }

      this._getCQN().having.push(...this._parseArguments(arg1, arg2, arg3, arg4))
      return this
    }

    if (isWhere && operator === 'or') {
      this._getCQN().where.push(operator)

      if (needBrackets) {
        // in case of function 'and' was called and an object input param containing an 'or' we need to add brackets
        this._getCQN().where.push('(', ...this._parseArguments(arg1, arg2, arg3, arg4), ')')

        return this
      }

      return this._where(arg1, arg2, arg3, arg4)
    }

    if (!isJoin && operator === 'or') {
      // or called without where before
      return this.where(arg1, arg2, arg3, arg4)
    }

    if (isJoin) {
      this._getCQN().from.on.push(operator)
      this._getCQN().from.on.push(...this._parseArguments(arg1, arg2, arg3, arg4))

      return this
    }

    throw new UnexpectedFunctionCallError(operator)
  }

  _fluidUsage (...args) {
    const expr = cds.parse.expr(Array.from(args).join(' '))
    return expr.xpr
  }

  _where (...args) {
    if (args.length === 0) {
      throw new IllegalFunctionArgumentError('arg1')
    }

    // currently we only support fluid usage with 4+ args
    if (args.length > 4) {
      this._getCQN().where.push(...this._fluidUsage(...args))
      return this
    }

    this._getCQN().where.push(...this._parseArguments(...args))

    return this
  }

  /**
   * @deprecated
   * @param object
   * @returns {*}
   * @private
   */
  _extractKeyValueFromObject (object) {
    // for now we assume there is only one entry in the object
    for (const key of Object.keys(object)) {
      return {key: key, value: object[key]}
    }

    return null
  }

  _isFunction (element) {
    if (element === null) {
      return false
    }

    if (typeof element === 'string') {
      return element.includes('(')
    }

    if (typeof element === 'object') {
      const keyValue = this._extractKeyValueFromObject(element)
      if (keyValue && keyValue.value) {
        return this._isFunction(keyValue.value)
      }
    }

    return false
  }

  _isOneArgFunction (arg1, arg2, arg3) {
    return this._isFunction(arg1) || this._isFunction(arg3) || this._isFunction(arg2)
  }

  _parseFunction (func) {
    if (typeof func === 'object') {
      return this._parseFunctionFromObject(func)
    }

    if (typeof func === 'string') {
      return this._parseFunctionFromString(func)
    }
  }

  _parseFunctionFromString (aggregation) {
    const parts = aggregation.match(/[^,()]+/g)
    if (parts.length !== 2) {
      throw new IllegalFunctionArgumentError('columns')
    }

    // special cases like count(*), count(1) or sum(10.1)
    if (parts[1] === '*' || this._isNumber(parts[1])) {
      return {ref: [parts[0].toLowerCase(), {args: parts[1]}]}
    }

    return {ref: [parts[0].toLowerCase(), {args: [this._buildRef(parts[1])]}]}
  }

  _parseFunctionFromObject (obj) {
    const keyValueObj = this._extractKeyValueFromObject(obj)
    const aggregation = this._parseFunctionFromString(keyValueObj.value)
    aggregation.as = keyValueObj.key
    return aggregation
  }

  _isNumber (obj) {
    return !isNaN(obj)
  }

  _handleFunction (arg1, arg2, arg3) {
    if (!arg2) {
      throw new IllegalFunctionArgumentError('arg2')
    }

    const comparison = (arg3 === undefined) ? '=' : arg2
    const value = (arg3 === undefined) ? arg2 : arg3

    const firstElement = (this._isFunction(arg1) ? this._parseFunction(arg1) : this._valOrCqn(arg1))
    const secondElement = (this._isFunction(value) ? this._parseFunction(value) : this._valOrCqn(value))

    return [firstElement, comparison.toLowerCase(), secondElement]
  }

  _valOrCqn (arg) {
    if (this._isCqn(arg)) {
      return arg
    }

    return {val: arg}
  }

  _isRefExpression (arg) {
    return arg instanceof Object && arg.identifier && arg.refname
  }

  _parseArguments (arg1, arg2, arg3, arg4) {
    // currently between is not supported for functions
    if (this._isOneArgFunction(arg1, arg2, arg3)) {
      return this._handleFunction(arg1, arg2, arg3)
    }

    // Used internally for path expressions
    if (this._isRefExpression(arg1) && this._isRefExpression(arg3)) {
      return [{ref: [arg1.identifier, arg1.refname]}, arg2.toLowerCase(), {ref: [arg3.identifier, arg3.refname]}]
    }

    if (/^(:?not )?exists$/.test(arg1)) {
      return [{
        ref: [arg1, {
          args: [arg2]
        }]
      }]
    }

    if (/^(:?not )?contains$/.test(arg1) && Array.isArray(arg2)) {
      return this._handleContains(arg1, arg2, arg3)
    }

    if (arg1 instanceof Object && !this._isCqn(arg1)) {
      return this._parseObjectArgument(arg1)
    }

    return this._parseNonSingleObjectArguments(arg1, arg2, arg3, arg4)
  }

  _isCqn (arg) {
    return arg && (arg.xpr || arg.hasOwnProperty('val') || arg.ref || arg.SELECT)
  }

  _handleContains (contains, columns, searchTerm) {
    if (columns.length === 1) {
      return [{
        ref: [contains, {
          args: [{xpr: ['(', {ref: columns}, ')']}, ...this._convertSearchTermToCqn(searchTerm)]
        }]
      }]
    } else {
      return [{
        ref: [contains, {
          args: [{
            list: columns.map((column) => {
              return {ref: [column]}
            })
          }, ...this._convertSearchTermToCqn(searchTerm)]
        }]
      }]
    }
  }

  _convertSearchTermToCqn (searchTerm) {
    if (Array.isArray(searchTerm)) {
      return searchTerm.map((element) => {
        if (element === 'and' || element === 'or' || element === 'not') {
          return element
        }

        return {val: element}
      })
    }

    return [{val: searchTerm}]
  }

  _getTableNamesFrom (fromObj) {
    if (typeof fromObj === 'string') { // delete with string in from
      return [fromObj]
    }

    if (fromObj.name) { // delete with entity in from
      return [fromObj.name]
    }

    // select
    return this._extractRefs(fromObj)
  }

  _extractRefs (from) {
    if (from.hasOwnProperty('join')) { // cqn with join in from
      return this._refs(from.args)
    }
    return from.as ? [from.ref[0], from.as] : [from.ref[0]]
  }

  _refs (refs) {
    const arr = []
    for (const element of refs) {
      if (element.hasOwnProperty('join')) {
        // multiple join are nested, se we need to find all the table names in there as well
        arr.push(...this._extractRefs(element))
      } else {
        arr.push(element.ref[0])
        if (element.as) {
          arr.push(element.as)
        }
      }
    }
    return arr
  }

  _getTableNamesEntity (entityObj) {
    if (typeof entityObj === 'string') { // update with string in entity
      return entityObj
    }

    if (entityObj.name) { // update with entity in entity
      return entityObj.name
    }
  }

  _getTableNames () {
    const tableNames = []
    const cqn = this._getCQN()

    if (cqn.from) { // select and delete
      tableNames.push(...this._getTableNamesFrom(cqn.from))
    } else if (cqn.entity) { // update
      tableNames.push(this._getTableNamesEntity(cqn.entity))
    }

    return tableNames
  }

  _matchTableColumn (name = '') {
    const matches = name.match(/^(?:"(\w+(?:\.\w+)*)"|(\w+))\.(?:"(\w+(?:\.\w+)*)"|(\w+))$/)

    if (matches) {
      return matches.filter(this._filterForTableAndColumn)
    }
  }

  _matchInline (name) {
    let matches = name.split(/\.\{/)
    const lastIndex = matches.length - 1
    matches[lastIndex] = matches[lastIndex].match(/(\w+)\}+/)[1]
    return matches
  }

  _filterForTableAndColumn (element, index) {
    return index && element != null
  }

  _buildWithTableName (element) {
    const tableNames = this._getTableNames()
    const matched = this._matchTableColumn(element)

    if (matched && tableNames.indexOf(matched[0]) !== -1) {
      return {ref: [matched[0], matched[1]]}
    }

    if (matched && this._model) {
      for (const table of tableNames) {
        if (this._isAssociation(table, matched[0])) { // <-- inline or column name with dot
          return this._buildInline(matched)
        }
      }
    }

    if (element.includes('.{')) { // <-- inline, no isAssociation check
      return this._buildInline(this._matchInline(element))
    }
  }

  _buildInline (array) {
    let ref = {ref: [array[0]]}
    if (array.length > 1) {
      array.splice(0, 1)
      ref['inline'] = [this._buildInline(array)]
    }
    return ref
  }

  _buildRef (element) {
    const ref = this._buildWithTableName(element)

    if (ref) {
      return ref
    }

    return {ref: [element]}
  }

  _buildValOrRef (element) {
    if (typeof element === 'string') {
      const ref = this._buildWithTableName(element)
      if (ref) {
        return ref
      }
    }

    return this._valOrCqn(element)
  }

  _refOrCqn (arg) {
    if (!this._isCqn(arg)) {
      return this._buildRef(arg)
    }

    return arg
  }

  _parseNonSingleObjectArguments (givenRef, givenComparison, givenValue, secondValue) {
    // contains in object
    if (typeof givenRef === 'string' && givenRef.toLowerCase() === 'contains' && Array.isArray(givenValue) && typeof secondValue === 'string') {
      return this._handleContains(givenRef, givenValue, secondValue)
    }
    const ref = this._isFunction(givenRef) ? this._parseFunction(givenRef) : this._refOrCqn(givenRef)
    const comparison = (givenValue === undefined) ? '=' : givenComparison
    const value = (givenValue === undefined) ? givenComparison : givenValue

    if (value === undefined) {
      return [ref]
    }

    // null is of type object
    if (value !== null) {
      if (value instanceof RegExp) {
        return [ref, 'regexp', {val: String(value)}]
      }

      if (value.SELECT) {
        return [ref, comparison, value]
      }
    }

    if (secondValue) {
      return [ref, comparison, {val: value}, 'and', {val: secondValue}]
    }

    return [ref, comparison, this._buildValOrRef(value)]
  }

  _isNonNestedObject (object) {
    return object instanceof Object && !Array.isArray(object) && !(object instanceof RegExp)
  }

  _isAndOr (key) {
    return key === 'or' || key === 'and'
  }

  _validateObjectArgument (object) {
    if (Array.isArray(object) || Object.keys(object).length === 0) {
      throw new IllegalFunctionArgumentError('arg1')
    }
  }

  _parseObjectArgument (object) {
    this._validateObjectArgument(object)

    const arrayReturn = []

    for (const key of Object.keys(object)) {
      if (this._isAndOr(key)) {
        // only if an 'or' follows on an 'and' we need to add brackets
        if (key === 'and' && object[key].or) {
          arrayReturn.push(key, '(', ...this._parseObjectArgument(object[key]), ')')
        } else {
          arrayReturn.push(key, ...this._parseObjectArgument(object[key]))
        }
      } else if (/^(:?not )?exists$/.test(key)) {
        arrayReturn.push({ref: [key, {args: [object[key]]}]})
      } else if (this._isNonNestedObject(object[key])) {
        this._addLogicOperatorIfNeeded(arrayReturn)
        arrayReturn.push(...this._parseNonNestedObject(key, object[key]))
      } else {
        this._addLogicOperatorIfNeeded(arrayReturn)
        const comparison = (Array.isArray(object[key])) ? 'in' : '='
        arrayReturn.push(...this._parseNonSingleObjectArguments(key, comparison, object[key]))
      }
    }

    return arrayReturn
  }

  _addLogicOperatorIfNeeded (array) {
    const length = array.length

    if (length === 0) {
      return
    }

    const lastEntry = array[length - 1]

    if (lastEntry !== 'and' && lastEntry !== 'or') {
      array.push('and')
    }
  }

  _parseNonNestedObject (parentKey, object) {
    const keys = Object.keys(object)

    if (this._isCqn(object)) {
      if (object.SELECT) {
        return this._parseNonSingleObjectArguments(parentKey, 'in', object)
      }

      return this._parseNonSingleObjectArguments(parentKey, object)
    }

    switch (keys.length) {
      case 1:
        return this._parseNonSingleObjectArguments(parentKey, keys[0], object[keys[0]])
      case 2:
        return this._parseNonSingleObjectArguments(parentKey, keys[0], object[keys[0]], object[keys[1]])
      default:
        throw new IllegalFunctionArgumentError('arg1')
    }
  }

  _isAssociation (entityName, associationName) {
    const entity = this._model.definitions[entityName]
    if (entity) {
      return (entity.elements[associationName] && entity.elements[associationName].type === 'cds.Association')
    }
    throw new IllegalFunctionArgumentError('entityName')
  }
}

module.exports = Where
