const {setListener, getListener} = require('./queue')
const PRAGMAS = /(?:=>)\s*{\s*"(serialized)? ?(transaction(?:al)?)?"/

/**
 * Parse the function for pragmas.
 * @returns {{serialized: {string}, transaction: {string}}}
 * @private
 */
const _getPragmas = (fn) => {
  const [, serialized, transaction] = PRAGMAS.exec(fn) || []

  return {
    serialized,
    transaction
  }
}

/**
 * The context object, provided at inner blocks.
 * @returns {Function}
 * @private
 */
const _getContext = (capture) => {
  return {
    run: (query) => {
      if (typeof query === 'function') {
        // Add the config for later execution
        const {serialized, transaction} = _getPragmas(query)

        // Capture inner block's statements
        const queue = _captureRun(query, transaction)
        queue.serialized = serialized
        queue.transaction = transaction

        // Add to queue.
        capture(queue)
        return
      }

      // CQN already captured with listener
      if (query._promised) {
        return
      }

      capture(query)
    }
  }
}

/**
 * In case of CQN .then can be used directly at the CQN.
 * This should trigger execution in most cases, but is only captured in the run block context.
 * The chain can hold N .then and or .catch calls and needs to be reconstructed.
 * @returns {Promise<*>}
 * @private
 */
const _reconstructCapturedChain = (exec, captured) => {
  for (const entry of captured) {
    exec = exec[entry.type](entry.fn)
  }

  return exec
}

const _entryToPromise = (dbc, queue, entry) => {
  // Nested block
  if (Array.isArray(entry)) {
    return (entry.serialized) ? _runSerialized(dbc, entry) : _runParallel(dbc, entry)
  }

  // Captured CQN with promise chains
  if (entry._promised && entry._promised.length > 0) {
    return _reconstructCapturedChain(dbc.execute(entry), entry._promised)
  }

  // Other queries captured from inner cds.run
  return dbc.execute(entry)
}

const _runBegin = (dbc, transaction) => {
  if (transaction) {
    return dbc.begin()
      .catch((beginErr) => {
        dbc._toBeDestroyed = true

        throw beginErr
      })
  }

  return Promise.resolve()
}

const _handleExecuteError = (dbc, transaction, execErr) => {
  if (transaction) {
    // in case execute fails roll back and reject
    return dbc.rollback()
      .catch((rollbackErr) => {
        dbc._toBeDestroyed = true

        throw rollbackErr
      })
      .then(() => {
        throw execErr
      })
  }

  return Promise.reject(execErr)
}

const _runCommit = (chain, dbc, queue) => {
  if (queue.transaction) {
    return chain
      .catch((err) => {
        return _handleExecuteError(dbc, queue.transaction, err)
      })
      .then((res) => {
        return dbc.commit()
          .catch((execErr) => {
            // in case execute fails roll back and reject
            return dbc.rollback()
              .catch((rollbackErr) => {
                dbc._toBeDestroyed = true

                throw rollbackErr
              })
              .then(() => {
                throw execErr
              })
          })
          .then(() => {
            return res // return result of the last non-commit statement
          })
      })
  }

  return chain
}

/**
 * Queries should run in sequence.
 * @returns {Promise<void>}
 * @private
 */
const _runSerialized = (dbc, queue) => {
  let chain = _runBegin(dbc, queue.transaction)

  for (const entry of queue) {
    chain = chain
      .then(() => {
        return _entryToPromise(dbc, queue, entry)
      })
  }

  return _runCommit(chain, dbc, queue)
}

/**
 * Start all queries and sub blocks at once.
 * @returns {Promise<any[]>}
 * @private
 */
const _runParallel = (dbc, queue) => {
  const chain = _runBegin(dbc, queue.transaction)
    // Start following promises after begin has been executed
    .then(() => {
      const all = []

      for (const entry of queue) {
        all.push(_entryToPromise(dbc, queue, entry))
      }

      return Promise.all(all)
    })

  return _runCommit(chain, dbc, queue)
}

/**
 * Checks if the queue should be run in parallel or in sequence
 * @returns {Promise}
 * @private
 */
const _runQueue = (dbc, queue) => {
  if (queue.serialized) {
    return _runSerialized(dbc, queue)
  }

  return _runParallel(dbc, queue)
}

/**
 * Will run all functions synchronously and capture the queries and possible then/catch functions
 * @returns {Array}
 * @private
 */
const _captureRun = (fn, transaction) => {
  const queue = []
  const capture = (query) => {
    queue.push(query)
  }

  // empty handler in the outer run or handler from the last run
  const lastListener = getListener()

  // register the capture function for any statement
  setListener(capture)

  // run the function, collecting all contained queries and calls to .run (simulates "cds" aka op or context)
  fn(_getContext(capture))

  // Reset the listener
  setListener(lastListener)

  return queue
}

// hereby we collect queries and calls to .run contained in fn
function runBlock (fn) {
  try {
    const {serialized, transaction} = _getPragmas(fn)
    const queue = _captureRun(fn, transaction)

    if (queue.length === 0) {
      return Promise.reject(new Error('No statements at block'))
    }

    queue.serialized = serialized
    queue.transaction = transaction
    return _runQueue(this, queue)
  } catch (err) {
    return Promise.reject(err)
  }
}

module.exports = runBlock
