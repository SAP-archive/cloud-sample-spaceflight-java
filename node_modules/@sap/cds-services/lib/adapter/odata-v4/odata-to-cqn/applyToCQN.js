const odata = require('@sap/odata-v4')
const ResourceKind = odata.uri.UriResource.ResourceKind
const TransformationKind = odata.uri.Transformation.TransformationKind
const ExpressionKind = odata.uri.Expression.ExpressionKind
const StandardMethod = odata.uri.AggregateExpression.StandardMethod

const {FeatureNotSupported} = require('../../../errors')

const AGGREGATION_METHODS = new Map([
  [StandardMethod.SUM, 'sum'],
  [StandardMethod.MIN, 'min'],
  [StandardMethod.MAX, 'max'],
  [StandardMethod.AVERAGE, 'avg']])

const _getColumnName = (expression) => {
  switch (expression.getKind()) {
    case ExpressionKind.MEMBER:
      return expression.getPathSegments()[0].getProperty().getName()
    default:
      throw new FeatureNotSupported(`Expression ${expression.getKind()} is not supported`)
  }
}

const checkAggregateExpression = (aggregateExpression) => {
  if (aggregateExpression.getInlineAggregateExpression() ||
    aggregateExpression.getFrom().length ||
    (aggregateExpression.getPathSegments().length &&
      aggregateExpression.getPathSegments()[0].getKind() !== ResourceKind.COUNT)) {
    throw new FeatureNotSupported('Only simple aggregations are supported')
  }
}

const _addAggregation = (aggregateExpression) => {
  const columnName = _getColumnName(aggregateExpression.getExpression())
  const method = AGGREGATION_METHODS.get(aggregateExpression.getStandardMethod())
  const aggregation = `${method}(${columnName})`
  const alias = aggregateExpression.getAlias()
  if (alias) {
    const column = {}
    column[aggregation] = alias
    return column
  } else {
    return aggregation
  }
}

const _addCount = (aggregateExpression) => {
  const alias = aggregateExpression.getAlias()
  if (alias) {
    return {'count(*)': alias}
  } else {
    return 'count(*)'
  }
}

const _createColumnsForAggregateExpressions = (aggregateExpressions) => {
  let columns = []
  for (const aggregateExpression of aggregateExpressions) {
    checkAggregateExpression(aggregateExpression)
    if (aggregateExpression.getExpression() && aggregateExpression.getStandardMethod() !== null) {
      columns.push(_addAggregation(aggregateExpression))
    } else { // checked in checkAggregateExpression to be ResourceKind.COUNT
      columns.push(_addCount(aggregateExpression))
    }
  }
  return columns
}

/**
 * Add odata apply to a CQN object.
 *
 * @param {string} transformations - odata-v4 transformaion object
 *
 * @private
 */
const applyToCQN = (transformations) => {
  const res = {groupBy: [], aggregations: []}
  const transformation = transformations[0]
  switch (transformation.getKind()) {
    case TransformationKind.GROUP_BY:
      if (transformation.getTransformations().length) {
        res.aggregations.push(..._createColumnsForAggregateExpressions(transformation.getTransformations()[0].getExpressions()))
      }
      for (const item of transformation.getGroupByItems()) {
        const name = item.getPathSegments()[0].getProperty().getName()
        res.groupBy.push(name)
      }
      return res
    case TransformationKind.AGGREGATE:
      if (transformation.getExpressions().length) {
        res.aggregations.push(..._createColumnsForAggregateExpressions(transformation.getExpressions()))
      }
      return res
    default:
      throw new FeatureNotSupported(`Transformation ${transformation.getKind()} is not supported`)
  }
}

module.exports = applyToCQN
