const {
  QueryOptions,
  Components: {DATA_READ_HANDLER},
  uri: {
    UriResource: {
      ResourceKind: {
        COUNT,
        NAVIGATION_TO_ONE
      }
    }
  }
} = require('@sap/odata-v4')

const getContextObject = require('../utils/context-object')
const {isCustomOperation, maxPageSize, skipToken} = require('../utils/request')
const {toODataResult} = require('../utils/event')
const notFound = require('../../../services/handlers/notFound')
const {validateResourcePathLength} = require('../utils/request')

/**
 * Checks whether a count of entities is requested
 * (not count embedded into collection).
 * @param {Array} segments - The uri path segments of the request.
 * @returns {boolean} - True if a count of entities is requested, else false.
 * @private
 */
const _isCount = (segments) => {
  return (segments[segments.length - 1].getKind() === COUNT)
}

/**
 * Get the count by using the general READ CQN and alter it to a COUNT query.
 * @param {Object} service
 * @param {Object} readContext
 * @param {boolean} shareContext
 * @return {Promise}
 * @private
 */
const _getCount = (service, readContext, shareContext = false) => {
  // Copy CQN including from and where and changing columns
  const select = readContext.statements.SELECT.from(readContext.query.SELECT.from, [{'COUNT(1)': 'count'}])
  if (readContext.query.SELECT.where) {
    select.SELECT.where = readContext.query.SELECT.where
  }

  const context = (shareContext) ? Object.assign({}, readContext) : readContext

  // remove as Object.defineProperty would cause a conflict
  delete context.query

  // Define new CQN
  context.query = select

  return service.processEvent('READ', context)
  // Transform into scalar result
    .then((result) => {
      return (result[0] && result[0].count) ? result[0].count : 0
    })
}

/**
 * Checks whether a collection of entities or a single entity is requested.
 * Returns false in case of a custom operation.
 * @returns {boolean} - True if a collection of entities is requested, else false.
 * @private
 */
const _isCollection = (segments) => {
  const lastEntitySegment = Array.from(segments).reverse().find((segment) => segment.getProperty() === null)
  const kind = lastEntitySegment.getKind()

  return !isCustomOperation(segments) &&
    kind !== NAVIGATION_TO_ONE &&
    kind !== COUNT &&
    lastEntitySegment.getKeyPredicates().length === 0
}

/**
 * Checks whether the count needs to be included in the result set as an annotation.
 * @param {Object} req - The odata-v4 request.
 * @returns {boolean}
 * @private
 */
const _checkIfCountToBeIncluded = (req) => {
  return (req.getUriInfo().getQueryOption(QueryOptions.COUNT))
}

/**
 * Reading the full entity or only a property of it is alike.
 * In case of an entity, odata-v4 wants the value an object structure,
 * in case of a property as scalar.
 * @param {Object} service
 * @param {Object} context
 * @param {Array} segments
 * @return {Promise}
 * @private
 */
const _readEntityOrProperty = (service, context, segments) => {
  return service.processEvent('READ', context)
    .then((result) => {
      // Reading one entity or a property of it should yield only a result length of one.
      if (result.length !== 1) {
        throw notFound(context)
      }

      const propertyElement = segments[segments.length - 1].getProperty()

      return toODataResult((propertyElement === null) ? result[0] : result[0][propertyElement.getName()])
    })
}

/**
 * Read an entity collection without including the count of the total amount of entities.
 * @param {Object} service
 * @param {Object} context
 * @param {Object} req
 * @return {Promise}
 * @private
 */
const _readCollectionNoCount = (service, context, req) => {
  return service.processEvent('READ', context)
    .then((result) => {
      const modifiedResult = toODataResult(result)
      const pageSize = maxPageSize(req.getUriInfo().getPathSegments())

      if (pageSize && result.length === pageSize) {
        modifiedResult['*@odata.nextLink'] = (skipToken(req.getUriInfo()) + pageSize)
      }

      return modifiedResult
    })
}

/**
 * Read an entity collection and include the count count of the total amount of entities.
 * odata-v4 wants the count to be added as annotation.
 * @param {Object} service
 * @param {Object} context
 * @param {Object} req
 * @return {Promise}
 * @private
 */
const _readCollectionWithCount = (service, context, req) => {
  // When there is a limit, there might be need for getting the actual value
  if (context.query.SELECT.limit) {
    // Share one db client for both service request if not already batched
    let finishTransaction = false

    if (context.run && !context._.doNotFinishTransaction) {
      finishTransaction = true // not in batch
      context._.doNotFinishTransaction = true // still use the same pool connection for all db queries
    }

    // Request the count and collection in parallel
    return Promise.all([_readCollectionNoCount(service, context, req), _getCount(service, context, true)])
      .then(([result, count]) => {
        result['*@odata.count'] = count

        // End transaction block in case of non batch
        if (finishTransaction && context._.endTransactionIfConnected) {
          context._.doNotFinishTransaction = false // not in batch: finish transaction manually as bellow

          return context._.endTransactionIfConnected(context, 'rollback')
            .then(() => {
              return result
            })
        }

        return result
      })
  }

  // No limit, use the length property
  return _readCollectionNoCount(service, context, req)
    .then((result) => {
      result['*@odata.count'] = result.value.length

      return result
    })
}

/**
 * Depending on the read request segments, create one ore more reading service request.
 * @param {Object} service
 * @param {Object} req
 * @return {Promise}
 * @private
 */
const _readAndTransform = (service, req) => {
  const context = getContextObject(DATA_READ_HANDLER, service, req)
  const segments = req.getUriInfo().getPathSegments()

  // Scalar count is requested
  if (_isCount(segments)) {
    return _getCount(service, context)
      .then((result) => {
        return toODataResult(result)
      })
  }

  if (_isCollection(segments)) {
    if (_checkIfCountToBeIncluded(req)) {
      return _readCollectionWithCount(service, context, req)
    }

    return _readCollectionNoCount(service, context, req)
  }

  return _readEntityOrProperty(service, context, segments)
}

/**
 * The handler that will be registered with odata-v4.
 *
 * If an entity collection is read, it calls next with result as an Array with all entities of the collection.
 * If a count of the entities in the collection is requested, it uses number of the entities as a Number value.
 * If an single entity is read, it uses the entity as an object.
 * If a property of a single entity is requested (e.g. /Books(1)/name), it unwraps the property from the result.
 * If the single entity to be read does not exist, calls next with error to return a 404.
 * In all other failure cases it calls next with error to return a 500.
 *
 * @param {Service} service
 * @param {Object} options
 * @return {Function}
 */
const read = (service, options) => {
  return (req, res, next) => {
    // End here if length is greater then allowed
    validateResourcePathLength(req, options)

    // Get the service result(s) and hand them over the odata-v4
    _readAndTransform(service, req)
      .then((result) => {
        next(null, result)
      })
      .catch((err) => {
        next(err)
      })
  }
}

module.exports = read
