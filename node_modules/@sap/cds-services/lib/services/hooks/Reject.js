const {NotInModel} = require('../../errors/index')
const DEFAULT_EVENTS = ['CREATE', 'DELETE', 'READ', 'UPDATE']

/**
 * Reject manages all to be rejected events and event + entity combinations..
 * @alias module:hooks.Reject
 */
class Reject {
  /**
   * Constructs a reject handler.
   * Instantiates a new Set internally in which the individual entries will be referenced.
   *
   * @param {object} reflected - the reflected CSN model.
   * @param {string} service - Service name as specified in CSN.
   */
  constructor (reflected, service) {
    this._rejects = new Set()
    this._model = reflected
    this._service = service
  }

  /**
   * Reject an event type, list of event types or an event type for a entity.
   * @param {string|Array} event - Specific event type or list of types.
   * @param {string|Object|Array} [entity] - Name of the entity or CSN entity or list of entities the event type should be rejected for.
   * The list can be specified either as Array or as multiple parameters.
   */
  use (event, ...entity) {
    // Ensure both parameters can be handled as array
    const events = Array.isArray(event) ? event : [event]
    const entities = Array.isArray(entity[0]) ? entity[0] : entity

    this._addEventAndEntityLists(events, entities)
  }

  /**
   * Iterate over events and foreach entry iterate over entities.
   * Add all possible combinations to the reject list.
   * @param {array} events - List of events
   * @param {array} entities - List of entities.
   * @private
   */
  _addEventAndEntityLists (events, entities) {
    let normalizedEvent

    for (const event of events) {
      normalizedEvent = event

      // Check if provided event is
      // (a) default event or
      // (b) unbound custom operation contained in the reflection model
      if (!DEFAULT_EVENTS.includes(event) && entities.length === 0) {
        if (!event) {
          throw new NotInModel(event)
        }

        normalizedEvent = this._addServiceNamePrefix(event)

        if (!this._isUnboundCustomOperation(normalizedEvent)) {
          throw new NotInModel(event)
        }
      }

      if (entities.length === 0) {
        this._rejects.add(this._checkRejectEntry(normalizedEvent))
      } else {
        this._addEntitiesForEvent(normalizedEvent, entities)
      }
    }
  }

  /**
   * Iterate over entities and add reject entries for given event.
   * Add all possible combinations to the reject list.
   * @param {string} event - Event the entities operations should be rejected for.
   * @param {array} entities - List of entities.
   * @private
   */
  _addEntitiesForEvent (event, entities) {
    let serviceEntity
    for (let entity of entities) {
      let entityName = entity

      if (this._entityHasValidType(entity)) {
        throw new NotInModel(entity)
      }

      if (typeof entity === 'object') {
        if (entity.kind !== 'entity' || typeof entity.name !== 'string') {
          throw new NotInModel(entity)
        }

        entityName = entity.name
      }

      serviceEntity = this._addServiceNamePrefix(entityName)

      // Check if provided entity is not defined in the reflection model
      if (!this._isModeledEntity(serviceEntity)) {
        throw new NotInModel(entityName)
      }

      // Check if provided bound custom operation is defined within the provided entity in the reflection model
      if (!DEFAULT_EVENTS.includes(event) && serviceEntity !== undefined && !this._isBoundCustomOperation(serviceEntity, event)) {
        throw new NotInModel(event)
      }

      this._rejects.add(this._checkRejectEntry(event, serviceEntity))
    }
  }

  _entityHasValidType (entity) {
    return typeof entity !== 'string' && typeof entity !== 'object'
  }

  _addServiceNamePrefix (definition) {
    return definition.startsWith(this._service) ? definition : `${this._service}.${definition}`
  }

  /**
   * Checks whether or not an entity exists in the reflection model.
   * @param entity
   * @returns {boolean}
   * @private
   */
  _isModeledEntity (entity) {
    return this._model.find(d => d.kind === 'entity' && d.name === entity) !== undefined
  }

  /**
   * Checks whether or not a provided event exists as unbound custom operation in the reflection model.
   * @param {string} event
   * @returns {boolean}
   * @private
   */
  _isUnboundCustomOperation (event) {
    return this._model.find(d => ['action', 'function'].includes(d.kind) && d.name === event) !== undefined
  }

  /**
   * Checks whether or not a provided event exists as bound custom operation in the reflection model.
   * @param {string} entity
   * @param {string} event
   * @returns {boolean}
   * @private
   */
  _isBoundCustomOperation (entity, event) {
    return this._model.find(d => d.kind === 'entity' && d.name === entity && d.actions && d.actions[event]) !== undefined
  }

  /**
   * Check if the specified event is valid by type.
   * @param event
   * @param entity
   * @returns {Object}
   * @private
   */
  _checkRejectEntry (event, entity) {
    if (typeof entity === 'string') {
      return {event, entity}
    }

    return {event}
  }

  /**
   * Checks if the set has the event or event and entity combination.
   * @param {string} event - Name of the event like READ, UPDATE, DELETE, ...
   * @param {Object} target - Unreflected entity from CSN referenced at context object
   * @returns {boolean}
   */
  has (event, target = {}) {
    for (const entry of this._rejects) {
      if (entry.event === event && (!entry.entity || entry.entity === target.name)) {
        return true
      }
    }

    return false
  }
}

module.exports = Reject
