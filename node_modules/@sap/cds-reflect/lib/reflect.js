/** 
 * Reflects the given model or definition. 
 * The argument can be a parsed model or a single parsed definition; 
 * depending on that corresponding reflection decorators are returned.
 * For models, all entries are augmented with properties `name` and `kind`. 
 * The reflection methods commonly accept these two arguments:
 * 
 * - an optional **filter** to match definitions, wich can be one of...
 * 	- a `function` returning `true` or `false`
 * 	- a `string` referring to a _kind_ of definition 
 * - an optional **set of definitions** to fetch in  
 * (default: _this.definitions_)
 * 
 * Derived kinds are supported, e.g. `m.each('struct')` matches structs 
 * as well as entities; kind `'any'` matches all.
 * 
 * @param x one of:
 *  - a parsed model, or...
 * 	- a single parsed definition 
 * @returns {ReflectedModel|ReflectedDefinition|ReflectedAssociation|ReflectedEntity} 
 * 
 * @typedef {string | function} Filter
 * @typedef {{[string]:Definition}} Definitions      * 
 * @typedef {kind:string,name:string,elements?:{}} Definition      * 
 */
function reflect (x) {
    if (typeof x === 'string')  x = this.parse(x)
	return is.Model(x) ? x[_reflected] || (x[_reflected] = new ReflectedModel(x)) 
	: is.Association(x) ? x[_reflected] || (x[_reflected] = new ReflectedAssociation(x))
	: is.entity(x) ? x[_reflected] || (x[_reflected] = new ReflectedEntity(x))
	: x[_reflected] || (x[_reflected] = new ReflectedDefinition(x))
 }
const _reflected = Symbol('reflected')


class ReflectedModel {

	constructor (parsed) {
		Object.defineProperties (this, {
			_parsed: { value: parsed, configurable:1, writable:1 },
		})
		Object.assign (this, parsed) .foreach ((def, parents, name) => {
			if (!def.name)  set (def, 'name', name)
			if (!def.kind)  set (def, 'kind', parents.length ? 'element' : 'type')
		})  
	}

	/** Fetches definitions matching the given filter, returning an iterator on them. 
	 * @example 
	 * 		let model = cds.reflect (aParsedModel)
	 *      for (let d of model.each('entity'))  console.log (d.kind, d.name)
	 *      let entities = [...model.each('entity')]  //> capture all
	 *      let entities = model.all('entity')          //> equivalent shortct
	 * @param {Filter} [x] an optional filter 
	 * @param {Definitions} [defs] the definitions to fetch in, default: `this.definitions`
	 */
	*each (x, defs=this.definitions) {
		const filter = is.kindof(x)
		for (let name in defs)  if (filter(defs[name]))  yield defs[name]
	}

	/** Fetches definitions matching the given filter, returning them in an array.
	 * Convenience shortcut for `[...reflect.each('entity')]` */
	all (x, defs=this.definitions) { 
		return [...this.each(x,defs)]
	}

	/** Fetches definitions matching the given filter, returning the first match, if any. 
	 * @example 
	 *      let service = model.find('service')
	 * @param {Filter} [x]  the filter 
	 * @param {Definitions} [defs]  the definitions to fetch in, default: `this.definitions`
	 */
	find (x, defs=this.definitions) {
		for (let d of this.each(x,defs))  return d
	}

	/** Calls the visitor for each definition matching the given filter, optionally recusively.
	 * If the callback has two argument .foreach will recurse to all nested element definitions. 
	 * 
	 * The callback can interfere in the recursion by returning...
	 * - nothing - to recurse into the current definition (the default)
	 * - _"skip"_ - to not recurse into the current definition
	 * - another definition to recurse into
	 * 
	 * @param {Filter} [x]  an optional filter 
	 * @param {Callback} visitor  the callback function
	 * @param {Definitions} [defs]  the definitions to fetch in, default: `this.definitions`
	 * @returns {this} to allow chaining 
	 * 
	 * @example  
	 *      // recurse to print hierarchy of defs
	 *      m.foreach ((d,p) => console.log ('  -'.repeat(p.length), d.kind, d.name))
	 * @see find for details on the filter argument
	 * 
	 * @typedef {(each,parents?:[])=>any} Callback
	 */
	foreach (x, visitor, defs=this.definitions) {

		// filter is optional --> default: any
		if (!visitor) [x,visitor] = [is.any,x]

		// if visitor has only one parameter --> iterate definitions only 
		if (visitor.length == 1) {
			for (let d of this.each(x,defs))  visitor(d)
			return this
		}

		// if visitor has two parameters --> recursive iteration
		const filter = is.kindof(x);  /*run:*/ _recurse (defs,[])
		function _recurse (_defs, parents) { 
			for (let name in _defs) {
				let def = _defs[name]
				let d = filter(def) && visitor (def, parents, name) || def
				if (d.elements)  _recurse (d.elements, [...parents, d])
				if (d.target && d.target.elements)  _recurse (d.target.elements, [...parents, d.target])
				if (d.via && d.via.elements)  _recurse (d.via.elements, [...parents, d.via])
			}
		}
		return this
	}

	/** Fetches definitions declared as children of a given parent context or service. 
	 * It fetches all definitions whose fully-qualified names start with the parent's name. 
	 * Returns the found definitions as an object with the local names as keys.
	 * @example
	 *      let service = model.find ('service')
	 *      let entities = m.childrenOf (service)
	 * @param {string|any} parent  either the parent itself or its fully-qualified name 
	 * @param {integer} [depth]  specifies whether only direct children are included or more
	 * @returns {Object}  
	 */
	childrenOf (parent, depth=0) {
		let children={}, defs=this.definitions
		let ns = parent.name || parent;  if (ns)  ns += '.'
		for (let fqn in defs) if (fqn.startsWith(ns)) {
			let name = fqn.slice (ns.length)
			if (name.indexOf('.') >= depth)  continue
			children[name] = defs[fqn]
		}
		return children
	}

	/** Provides convenient access to the model's top-level definitions. 
	 * For example, you can use it in an es6-import-like fashion to avoid 
	 * working with fully-qualified names as follows:
	 * 
	 * @example
	 * let model = cds.reflect (cds.parse(`
	 *     namespace our.lovely.bookshop;
	 *     entity Books {...}
	 *     entity Authors {...}
	 * `))
	 * const {Books,Authors} = model.exports
	 * SELECT.from (Books) .where ({ID:11})
	 */
	get exports() {
		return set (this, 'exports', this.childrenOf (this.namespace||''))
	}

}


class ReflectedDefinition { 
	constructor (d) { this.def = d }
	is(kind) { return is.kindof(kind) (this.def) }
	get kind(){ return this.def.kind }
	get name(){ return this.def.name }
}


class ReflectedAssociation extends ReflectedDefinition {
	get is2one(){ const c = this.cardinality; return !c || c.max === 1 || c.targetMax === 1 }
    get is2many(){ return !this.is2one }
	get cardinality() { return this.def.cardinality }
}


class ReflectedEntity extends ReflectedDefinition {
	get keys(){
		let ee = this.def.elements, keys, dict={}
		for (let e in ee)  if (ee[e].key)  (keys=dict)[e] = ee[e]
		return set (this, 'keys', keys)
	}
}


function set (o,p,value) {
	Object.defineProperty(o,p,{value, configurable:true, writable:true})
	return value
}

const is = {
	Model: d => d.definitions !== undefined || d.extensions !== undefined || d.version !== undefined,
	entity: d => d.kind === 'entity'  ||  d.kind === 'view',
	struct: d => d.elements !== undefined || d.query !== undefined,
	service: d => d.kind === 'service' ,
	Association: d => d.type === 'cds.Association' || d.type === 'cds.Composition' ,
	Composition: d => d.type === 'cds.Composition' ,
	kindof: (x) => {
		if (!x) throw new Error ('missing filter for model reflection: '+ x)
		if (x === 'entity' || x.kind === 'entity')  return  is.entity
		if (x._cds)  return  d => d instanceof x  || d.kind == x.name
		if (x.type)  return  d => d.type === x.type  
		if (x.kind)  return  is.kindof (x.kind)
		if (typeof x === 'string')  return  is[x] || (d => d.kind === x)
		if (typeof x === 'function')  return x
		throw new Error ('invalid filter for model reflection: '+ x)
	},
	any: ()=>true,
}


module.exports = Object.assign (reflect, {
	ReflectedModel, 
	ReflectedDefinition
})