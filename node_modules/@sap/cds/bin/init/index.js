module.exports = Object.assign ( initProject, {
  options: [ '--java', '--db', '--flat' ],
  shortcuts: [ '-j', '-d', '-f' ],
  help: `
# SYNOPSIS

    *cds init* [ <folder> ]

    Creates a new project folder with the given name and adds _package.json_
    and _.vscode_ configuration pre-wired for usage with cds. Uses the current
    working directory and its name if no <folder> is specified.

# OPTIONS

    *-j* | *--java* <folder>

        Creates files for Java development in the given folder.  Uses 'srv'
        if no folder is specified.

    *-d* | *--db* <folder>

        Creates HANA files in the given folder.  Uses 'db' if no folder is
        specified.

`})


const fs = require ('fs-extra')
const exec = require('child_process').execSync
const path = require('path')

const DIRNAME_DB = 'db'
const DIRNAME_SRV = 'srv'
const GW_VERSION = '1.17.1'

const init = {
  java: function (subpath, cwd, logger=global.console, args={}) {
    subpath = typeof subpath === 'string' ? subpath : DIRNAME_SRV
    const javaDir = path.resolve(cwd, subpath)
    return fs.ensureDir(javaDir).then(() => {
      const execOpts = { stdio: 'inherit' }
      const packageName = 'org.changeme'
      const artifactID = subpath
      const hdiContainer = 'bookshop-hdi-container'

      logger.log('Generating into', javaDir)
      let cmd = `mvn archetype:generate -DgroupId=${packageName} -DartifactId=${artifactID} -Dversion=0.1.0-SNAPSHOT -Dpackage=${packageName} -Dhdi-container-service=${hdiContainer} -DarchetypeGroupId=com.sap.cloud.servicesdk.archetypes -DarchetypeArtifactId=odatav2 -DarchetypeVersion=${GW_VERSION} -DinteractiveMode=false`
      cmd += process.env.DEBUG ? ' -e' : ' -q'
      if (args.mvnSettings)  cmd += ` -s "${args.mvnSettings}"`  // for tests
      exec(cmd, Object.assign(execOpts, { cwd: path.dirname(javaDir) }))

      cmd = `git apply --ignore-whitespace ${path.resolve(__dirname, './java-srv/pom.xml.patch')}`
      exec(cmd, Object.assign(execOpts, { cwd: javaDir }))
    })
  },
  db: function (subpath, cwd, logger=global.console) {
    subpath = typeof subpath === 'string' ? subpath : DIRNAME_DB
    const dbDir = path.resolve(cwd, subpath)
    return fs.ensureDir(dbDir).then(() => {
      logger.log('Generating into', dbDir)
      return Promise.all([
        fs.copy(path.resolve(__dirname, './hana-db/db'), dbDir),
        fs.copy(path.resolve(__dirname, './hana-db/mta.yaml'), path.resolve(dbDir, '../mta.yaml')),
      ])
    })
  }
}

/**
 * Scaffoldes a new project with the given name. That is,
 * it creates a new folder and fills it with package.json and
 * config files from the template.
 */
function initProject ([name], args={}, cwd=process.cwd(), logger) {
  if (name) {
    const dir = path.join(cwd, name)
    fs.ensureDirSync (dir)
    cwd = dir
  } else {
    name = path.basename (cwd)
  }

  // check for --java <subpath>, --db etc.
  let flavours = Object.keys(args)
  if (flavours.length > 0 && flavours != 'flat') {
    flavours = flavours.filter(flavour => !!init[flavour])
    return promiseSequence(flavours, (flavour) => init[flavour](args[flavour], cwd, logger, args))
  }

  const archetypes = {
    standard: {
      folders: ['app', DIRNAME_SRV, DIRNAME_DB],
      src: 'project'
    },
    flat: {
      src: 'project-flat'
    },
  }
  const archy = archetypes [args.flat ? 'flat' : 'standard']
  return (archy.folders ? ensureDirs (cwd, archy.folders) : Promise.resolve())
  .then(() => fs.copy( // copy over static files
    path.resolve(__dirname, archy.src),
    cwd
  )).then(() => fs.move( // see https://github.com/npm/npm/issues/1862
    path.resolve(cwd, 'gitignore'),
    path.resolve(cwd, '.gitignore')).catch(err => {if (err.code !== 'EEXIST')  throw err})
  ).then(() => {
    write(path.join(cwd, 'package.json'), {
      name: name,
      version: "0.1.0",
      description: "cds-auto-generated project",
      repository: "<link to your github>",
      author: require('os').userInfo().username,
      dependencies: {
        '@sap/cds': '*'
      },
      scripts: {
        build: 'cds build --clean'
      },
      license: "ISC"
    })
  })
}

function ensureDirs (base, dirs) {
  return Promise.all (dirs.map (d => fs.ensureDir (path.join(base, d))))
}

function write (filename, o) {
  return fs.writeFile (filename, JSON.stringify(o, null, 2))
}

function promiseSequence (values, perform) {
  let chain = Promise.resolve()
  values.forEach(val => {
    chain = chain.then(() => perform(val)).catch(e => { throw e })
  })
  return chain
}
/* eslint no-console: off */
