module.exports = Object.assign ( compile, {
  options: [
    '--from', '--service', '--lang', '--unfold', '--for', '--to', '--dest'
  ],
  flags: [
    '--all', '--beta'
  ],
  shortcuts: [
    '-f', '-s', '-l', '-u', '-4', '-2', '-o',
  ],
  help: `
# SYNOPSIS

    *cds compile* [<models>] [<options>]

    Compiles the specified models, optionally applying specific processors to
    unfold and generate target outputs using the <options> as explained below.
    Reads from stdin if no <models> are specified.


# OPTIONS
    ${
        // *-f, --from* <frontend>

        //     use the specified frontend to parse the input. <frontend> can be one of
        //     the built-in parsers like *cdl* or *yaml* (> _http://bit.ly/-cdxjs#cds-parse_)
        //     valid node module ids of custom parsers.
     ''}
    *-s* | *--service* <name> | all

        chooses a specific service in case of models containing multiple ones.
        Specify _all_ to force output for all services.

    *-l* | *--lang* <languages> | all

        localize the model with given <languages>, a comma-separated list
        of language/locale codes or _all_. Localization is carried out before
        all other processors (-4/u) or backends (-2).

    *-u* | *--unfold* <processors> | all

        apply the specified <processors>, a comma-separated list of either
        built-in ones (> _http://bit.ly/-cdxjs#cds-unfold_) or valid node
        module ids of custom-provided ones.

    *-4* | *--for* <target>

        shortcut for --unfold for.<target>; e.g. these usages are equivalent:
        cds compile my-model --unfold for.odata
        cds compile my-model -4 odata

    *-2* | *--to* <backends>

        use the specified <backends>, a comma-separated list of either
        built-in ones like _yaml_ or _edmx_ (> _http://bit.ly/-cdxjs#cds-compile_)
        or valid node module ids of custom backends.

    *-o* | *--dest* <folder>

        writes output to the given folder instead of stdout.


# EXAMPLES

   *cds* compile model.cds
   *cds* c model.json --to cdl
   *cds* srv -s all -l all -2 edmx -o _out

   Use cds as shell command that reads from stdin and writes to stdout:
   *cat* hy | *cds* -2 sql | *sqlite3* test.db

`})


function compile_all (root='.') {

    const {exec} = require ('child_process')
    const cds = require ('../lib')

    exec(`find ${root} -name *.cds ! -path '*/node_modules/*'`, (_,stdout)=>{
        const all = stdout.split('\n').slice(0,-1)
        const info = `\n/ compiled ${all.length} cds models in`
        console.log (`Compiling ${all.length} cds models found in ${process.cwd()}...\n`)
        console.time (info)
        return Promise.all (all.map (each => cds.load(each)
            .then (()=> console.log (' ',each))
            .catch (()=> console.log (' \x1b[91m', each, '\x1b[0m'))
        )).then (()=>
            console.timeEnd (info)
        )
    })

}

function compile (models, options={}) {

    if (options.all)  return compile_all (models[0])

    const cds = require ('../lib')
    let chain, src, _suffix; //> be filled in below
    if (!options.as && !/,/.test(options.to))  options.as = 'str'
    if (options.beta)  options.betaMode = true

    if (typeof models === 'string')  models = [models]
    if (Array.isArray(models)) {
        if (!models[0])  return Promise.reject ('You must specify a model to compile!')
        chain = cds.load (models, options)
        src = models[0] .replace (/\.[^.]+$/,'')  //> excluding source file extension, e.g. .cds
    } else {
        chain = Promise.resolve (models)
        src = 'output'
    }

    if (options.unfold) for (let each of options.unfold.split(',')) {
        chain = chain.then (next (processor4 (cds.unfold, each)))
    }
    if (options.for) {
        chain = chain.then (next (processor4 (cds.unfold.for, options.for)))
    }
    if (options.lang) {
        chain = chain.then (m => cds.localize (m,options.lang))
    }
    if (options.to) for (let each of options.to.split(',')) {
        chain = chain.then (next (processor4 (cds.compile.to, _suffix=each)))
    }

    return chain.then (cds.write.to (
        options.dest,
        options.file || src,
        options.suffix || suffix4(_suffix),
        options.log || console.warn
    ))

    function processor4 (head, tail) {
        try {
            let proc = tail.split('.').reduce ((prev,next) => prev[next], head)
            if (proc)  return proc
        } catch(e){/* ignore */}
        throw `    unknown model processor: ${tail}`
    }

    function next (proc) {
        return (prev) => function*(){
            if (!isMany(prev))  yield [ proc(prev,options) ]
            else for (let [outer,_outer] of prev) {
                let next = proc (outer, options)
                if (isMany(next)) {
                    for (let [inner,_inner] of next) {
                        yield [ inner, Object.assign({},_outer,_inner) ]
                    }
                }
                else  yield [ next, _outer ]
            }
        }()
        function isMany (outcome) {
            return outcome[Symbol.iterator] && outcome.next
        }
    }

}


function suffix4 (x) { return x && ({
    edmx: '.xml',
    swgr: '.yml',
    cdl: '.cds',
    ddl: '.sql',
    edm: '.json'
}[x] || '.'+x) }

/* eslint no-console:0 */