const cds = require('../index')
const cdsv = require('@sap/cds-compiler')
const sqlMapping = (o={}) => o.sql || o.sql_mapping || cds.config.data.sql_mapping

module.exports = {
  parse: (...args) => _csn4 (cdsv.compileSources (...args)),
  compile: (...args) => cdsv.compile(...args) .then (_csn4),
  forOData: (csn,o) => _csn4Odata(csn,o),
  toHana: (csn,o) => cdsv.toHana(_xsn4(csn),o),
  toCdl: (csn,o) => cdsv.toCdl(_xsn4(csn),o),
  toSql: (csn,o) => cdsv.toSql(_xsn4(csn),o),
  toSwagger: (csn,o) => cdsv.toSwagger (_xsn4(csn),o),
  toOdata: (csn,o) => cdsv.toOdata (_xsn4(csn),o),
  sqlMapping
}

function _csn4Odata (csn, o={}) {
  const odata = cdsv.toOdata(_xsn4(csn), Object.assign({ csn: true }, o))
  const odataCsn = _csn4(odata._augmentedCsn, 'forOData')
  odataCsn['@sql_mapping'] = sqlMapping(o)
  return odataCsn
}


/** Returns a given model as plain csn.
 * The original augmented model is stored in the hidden
 * property [_x]
 */
function _csn4 (model, forOData) {
  if (!model.messages) return model
  if (!forOData && model._csn)  return model._csn
  let xsn = model,  csn = cds.config.build.new_csn ? cdsv.compactModel (xsn) : cdsv.toCsn (xsn)
  // FIXME: That's just ugly, bad and awfully slow, and the last one is likely critical
  csn = JSON.parse (JSON.stringify (csn, (key, value) => {
    if (key === 'indexNo') return
    if (key === 'origin') return
      // if (key === 'foreignKeys') return
    return value
  }))
  for (let s in xsn.sources) {
    if (xsn.sources[s].namespace)
      csn.namespace = xsn.sources[s].namespace.path.map(x => x.id).join('.')
    break //> only the first one
  }
  // keep _source in csn as non-enumerable property
  Object.defineProperty (csn, '_sources', {value: Object.keys (xsn.sources) })
  // keep _locations in csn as non-enumerable properties
  for (let d in csn.definitions) {
    if (!csn.definitions[d]['@source'] && csn.definitions[d].kind === 'service')  csn.definitions[d]['@source'] = xsn.definitions[d].location.filename
    Object.defineProperty (csn.definitions[d], '_location', {value: xsn.definitions[d].location })
  }
  // keep the _xsn twin  non-enumerable properties
  Object.defineProperty (csn, '_xsn', {value:xsn, configurable:1, writable:1 })
  // cache _csn to _xsn only in normalized models, i.e. not the flattened Odata csn
  forOData || Object.defineProperty (xsn, '_csn', {value:csn, configurable:1, writable:1 })
  return csn
}

/** Returns a given model as an augmented one.
 * This is necessary because severel cdsv operations seem to always expect
 * augmented models created from own parser and don't work with plain CSNs
 * from other sources??
 */
function _xsn4 (model) {
  if (model._parsed)  model = model._parsed
  if (model.messages) return model   // it is already an augmented one
  if (model._xsn) return model._xsn   // came from cdsv before
  // doesn't stem from cdsv... (yes, this is all pretty crazy)
  let csn=model, xsn = cdsv.compileSources({'.json': JSON.stringify(csn, (k, v) => {
    if (k === 'namespace') return
    return v
  })})
  Object.defineProperty (csn, '_xsn', {value:xsn})
  Object.defineProperty (xsn, '_csn', {value:csn})
  return xsn
}

// Add .toString() support to cdsv's composite errors class
const { CompilationError } = require('@sap/cds-compiler/lib/base/messages')
Object.defineProperties(CompilationError.prototype, {
  name: { get: function () { return 'cds.compile failed' } },
  message: { get: function () {
    return this.errors && this.errors.reduce((p,msg) => p +
      (' at '+msg).replace (': Error: ',': ')
      .replace ('Extraneous input','invalid token')
      .replace(/ expecting {(<EOF>, )?([^}]*)}/, (str,_,p1) => {
        return ` - expected one of `+ p1.toLowerCase() + '.'
      })
     + '\n', '\n')
  }}
})
