'use strict';

const RepresentationKinds = require('./RepresentationKind').Kinds;
const FormatDescription = require('./FormatDescription');

/**
 * The FormatManager manages all formats which are supported by a odata service. A format consists of
 * - a representation kind which defines what kind of OData representation can be serialized
 * - a content type defining type and subtype
 * - a serializer function
 * - a parameter-check function to check whether the serializer function supports the given content-type parameters
 */
class FormatManager {

    /**
     * Creates an instance of FormatManager.
     */
    constructor() {
        /**
         * Stores all format mappings for all representation kinds.
         * @type {Map<RepresentationKind.Kinds, FormatDescription[]>}
         * @private
         */
        this._representationKindHandlers = new Map();
    }

    /**
     * Registers a format description for later use.
     * @param {RepresentationKind.Kinds} representationKind The corresponding representation kind
     * @param {ContentTypeInfo.ContentTypes} contentType The corresponding content type
     * @param {Function} serializerFunction The serializer function to register
     * @param {?Function} parameterCheckFunction the function to check the format parameters
     * @returns {FormatManager} Self reference
     */
    use(representationKind, contentType, serializerFunction, parameterCheckFunction = () => true) {
        const formatDescription = new FormatDescription(contentType, serializerFunction, parameterCheckFunction);
        let representationKindFormatHandlers = this._representationKindHandlers.get(representationKind);
        if (representationKindFormatHandlers) {
            representationKindFormatHandlers.unshift(formatDescription);
        } else {
            this._representationKindHandlers.set(representationKind, [formatDescription]);
        }
        return this;
    }

    /**
     * Returns the format descriptions for a known representation kind.
     * If that is unknown or no serializer is registered, an empty array will be returned.
     *
     * @param {RepresentationKind.Kinds} representationKind Representation kind
     * @returns {FormatDescription[]} the registered format descriptions
     */
    getAllFormatDescriptions(representationKind) {
        return this._representationKindHandlers.get(representationKind) || [];
    }

    /**
     * Returns the format descriptions for a known representation kind and content-type combination.
     * If that is unknown or no serializer is registered, an empty array will be returned.
     *
     * @param {RepresentationKind.Kinds} representationKind Representation kind
     * @param {ContentTypeInfo.ContentTypes} contentType Content type
     * @returns {FormatDescription[]} the registered format descriptions
     */
    getFormatDescriptions(representationKind, contentType) {
        return this.getAllFormatDescriptions(representationKind)
            .filter(formatDescription => formatDescription.getTypeAndSubtype() === contentType);
    }

    /**
     * Returns the serializer function for representation kind ERROR {@see RepresentationKind.Kinds.ERROR}
     *
     * @param {ContentTypeInfo.ContentTypes} contentType Content type
     * @returns {Function} Returns the registered component
     */
    getErrorSerializer(contentType) {
        return this.getFormatDescriptions(RepresentationKinds.ERROR, contentType)[0].getSerializerFunction();
    }

    /**
     * Returns the debug serializer function for representation kind DEBUG {@see RepresentationKind.Kinds.DEBUG}
     *
     * @param {ContentTypeInfo.ContentTypes} contentType Content type
     * @returns {Function} Returns the registered component
     */
    getDebugSerializer(contentType) {
        return this.getFormatDescriptions(RepresentationKinds.DEBUG, contentType)[0].getSerializerFunction();
    }
}

module.exports = FormatManager;
