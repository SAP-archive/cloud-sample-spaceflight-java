'use strict';

const AbstractError = require('./AbstractError');

/**
 * @extends AbstractError
 */
class IllegalArgumentError extends AbstractError {

    static createForMissingParameter(paramName) {
        return new IllegalArgumentError(`Parameter '${paramName}' must not be undefined`);
    }

    static createForIllegalInstance(paramName, expectedType) {
        let msg = `Parameter '${paramName}' must be type of '${expectedType}'`;
        return new IllegalArgumentError(msg);
    }

    static createForIllegalElementType(index, arrayName, expectedType) {
        return new IllegalArgumentError(
            `Element of '${arrayName}' array at index ${index} must be type of '${expectedType}'`);
    }

    static createForNonNegativeParameter(paramName) {
        return new IllegalArgumentError(`Parameter '${paramName}' must be non-negative integer`);
    }

    static createForPositiveParameter(paramName) {
        return new IllegalArgumentError(`Parameter '${paramName}' must be positive integer`);
    }

    static createForIllegalValue(paramName, ...allowedValues) {
        return new IllegalArgumentError(`Only the following values are allowed for '${paramName}'` +
                ` parameter: ${allowedValues.join(', ')}`);
    }

    static createForIllegalTypeValue(paramName, typeName, ...allowedValues) {
        return new IllegalArgumentError(`Only the following values of '${typeName}' type are ` +
            `allowed for '${paramName}' parameter: ${allowedValues.join(', ')}`);
    }

    static createForMalformedValueFormat(paramName, expectedValueFormat) {
        return new IllegalArgumentError(`Value of '${paramName}' parameter must be in the following format: ` +
            `${expectedValueFormat}`);
    }

    /**
     * @param {string} message
     */
    constructor(message) {
        super(AbstractError.ErrorNames.ILLEGAL_ARGUMENT, message);
    }
}

module.exports = IllegalArgumentError;
