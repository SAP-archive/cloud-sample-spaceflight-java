'use strict';

const Command = require('./Command');
const HttpMethods = require('../http/HttpMethod').Methods;
const RepresentationKinds = require('../format/RepresentationKind').Kinds;
const MetaProperties = require('../format/JsonFormat').MetaProperties;
const ExpandHelper = require('../uri/ExpandHelper');
const InternalServerError = require('../errors/InternalServerError');

/**
* The `next` callback to be called upon finish execution.
*
* @callback Next
* @param {?Error} error An error if there is one or null if not
*/

/**
 * Executes the serialization of the provided data.
 *
 * @extends Command
 */
class SerializingCommand extends Command {

    /**
     * Creates an instance of the SerializingCommand.
     *
     * @param {Context} context The current odata context instance
     * @param {ContextUrlFactory} contextUrlFactory The context url factory to create the odata context url
     * @param {NextLinkSerializer} nextLinkSerializer The nextLink serializer to create a nextLink
     */
    constructor(context, contextUrlFactory, nextLinkSerializer) {
        super(context);
        this._contextUrlFactory = contextUrlFactory;
        this._nextLinkSerializer = nextLinkSerializer;
    }

    /**
     * Executes the registered serializing function bound with the contract created from the
     * content negotiation.
     *
     * @param {Next} next The next callback to be called on finish
     * @returns {undefined}
     */
    execute(next) {
        const context = this.getContext();
        const logger = context.getLogger();
        logger.path('Entering SerializingCommand.execute()...');

        const request = context.getRequest();
        const response = context.getResponse();

        if (response.isHeadersSent()) {
            logger.warning('Headers already sent');
            return next();
        }

        if (request.getMethod() === HttpMethods.HEAD) {
            // A body in the response is not needed in a HEAD request
            response.setBody('');
            logger.info('Omitting response payload serializing for HEAD request');
            return next();
        }

        const responseContract = response.getContract();
        const representationKind = responseContract.getRepresentationKind();
        const responseBody = response.getBody();

        if (representationKind === RepresentationKinds.METADATA && responseBody && responseBody.value) {
            // In case of locale-specific $metadata requests the application sets the metadata document
            // in the metadata handler. Thus serializing will be skipped in this case.
            response.setBody(responseBody.value);
            logger.info('Omitting response payload serializing for $metadata request');
            return next();
        }

        if (representationKind != null
            && representationKind !== RepresentationKinds.NO_CONTENT
            && representationKind !== RepresentationKinds.PRIMITIVE_VALUE
            && representationKind !== RepresentationKinds.BINARY
            && representationKind !== RepresentationKinds.COUNT
            && representationKind !== RepresentationKinds.BATCH) {

            logger.info('Preparing OData annotations...');

            let options = response.getOdataOptions();
            if (options == null) {
                options = {};
                response.setOdataOptions(options);
            }

            const uriInfo = request.getUriInfo();

            if (responseBody && typeof responseBody === 'object' && !responseBody[MetaProperties.CONTEXT]) {
                this._addRootMetaProperty(
                    responseBody, MetaProperties.CONTEXT,
                    this._contextUrlFactory.createContextURL(uriInfo, ExpandHelper.getFinalExpand(request),
                        representationKind, options.keys, context.getService().getEdm())
                );
            }

            const metadataEtag = context.getService().getMetadataEtag();
            if (responseBody && typeof responseBody === 'object' && metadataEtag) {
                this._addRootMetaProperty(responseBody, MetaProperties.METADATA_ETAG, metadataEtag);
            }

            if (responseBody && typeof responseBody === 'object' && responseBody[MetaProperties.NEXT_LINK]) {
                // Skiptoken currently only allowed for Entity- and Reference-Collections
                if (representationKind !== RepresentationKinds.ENTITY_COLLECTION
                    && representationKind !== RepresentationKinds.REFERENCE_COLLECTION) {
                    return next(
                        new InternalServerError('Skiptoken is only allowed for entity- and reference-collections'));
                }

                // Check, whether a maxPageSize is configured for the returned Entity- or Reference-Collection
                const segment = uriInfo.getLastSegment(
                    representationKind === RepresentationKinds.REFERENCE_COLLECTION ? -1 : 0);
                if ((representationKind === RepresentationKinds.ENTITY_COLLECTION
                    || representationKind === RepresentationKinds.REFERENCE_COLLECTION)
                    && (segment.getEntitySet() && !segment.getEntitySet().getMaxPageSize()
                        || segment.getTarget() && !segment.getTarget().getMaxPageSize())) {
                    return next(new InternalServerError('Skiptoken is only allowed for entity- '
                        + 'and reference-collections where a maximum page size is configured'));
                }

                const odataPath = request.getOdataPath();
                const queryOptionsString = request.getUrlObject().search;
                this._addRootMetaProperty(
                    responseBody, MetaProperties.NEXT_LINK,
                    this._nextLinkSerializer.serializeNextLink(
                        odataPath, queryOptionsString, responseBody[MetaProperties.NEXT_LINK]
                    )
                );
            }
        }

        logger.info('Start response payload serializing...');

        const options = response.getOdataOptions();
        let serialize = responseContract.getSerializerFunction();
        serialize(context, responseBody, options, (error, serializedBody) => {
            response.setBody(serializedBody);
            return next(error);
        });

        return undefined;
    }

    /**
     * Add an annotation to a target object.
     * @param {Object} target
     * @param {string} annotation the name of the annotation
     * @param {string} value the value of the annotation
     * @private
     */
    _addRootMetaProperty(targetParam, annotation, value) {
        let target = targetParam;
        if (Array.isArray(target.value) || Buffer.isBuffer(target.value)) {
            target[annotation] = value;
        } else if (target.value && typeof target.value === 'object') {
            target.value[annotation] = value;
        } else {
            target[annotation] = value;
        }
    }
}

module.exports = SerializingCommand;
