'use strict';

const moduleCache = require('../ModuleCache');
const Big = moduleCache.lookup('big.js');

const EdmTypeKind = require('../edm/EdmType').TypeKind;
const EdmPrimitiveTypeKind = require('../edm/EdmPrimitiveTypeKind');
const JsonContentTypeInfo = require('../format/JsonContentTypeInfo');
const SerializationError = require('../errors/SerializationError');

/**
 * Converter of JavaScript values to the values of OData EDM types. The values are converted according to the OData
 * ABNF Construction Rules.
 */
class ValueConverter {

    /**
     * @param {ValueValidator} valueValidator - validator, which should be used to validate the values before they are
     * converted.
     * @param {JsonContentTypeInfo} formatParams JSON serializing options
     */
    constructor(valueValidator, formatParams = new JsonContentTypeInfo()) {
        this._valueValidator = valueValidator;
        this._formatParams = formatParams;
    }

    /**
     * Converts value to OData format. The method converts values of EDM primitive or TypeDefinition types.
     *
     * @param {(EdmProperty|EdmTerm|EdmType)} typeInfo - object containing metadata (e.g., type information) about the
     * value to be converted; it can be an instance of EdmProperty, EdmTerm, or EdmType (including EdmTypeDefinition)
     * @param {*} value - value, which has to be converted
     *
     * @returns {(string|number|boolean)} converted value
     */
    convert(typeInfo, value) {
        const type = this._getPrimitiveType(typeInfo.getType ? typeInfo.getType() : typeInfo);
        switch (type) {
            case EdmPrimitiveTypeKind.Binary:
                if (!Buffer.isBuffer(value)) {
                    return this.convertBinary(Buffer.from(value, 'base64'), this._getMaxLength(typeInfo));
                }
                return this.convertBinary(value, this._getMaxLength(typeInfo));
            case EdmPrimitiveTypeKind.Boolean:
                return this.convertBoolean(value);
            case EdmPrimitiveTypeKind.Byte:
                return this.convertByte(value);
            case EdmPrimitiveTypeKind.SByte:
                return this.convertSByte(value);
            case EdmPrimitiveTypeKind.Date:
                return this.convertDate(value);
            case EdmPrimitiveTypeKind.DateTimeOffset:
                return this.convertDateTimeOffset(value, this._getPrecision(typeInfo) || 0);
            case EdmPrimitiveTypeKind.TimeOfDay:
                return this.convertTimeOfDay(value, this._getPrecision(typeInfo) || 0);
            case EdmPrimitiveTypeKind.Duration:
                return this.convertDuration(value, this._getPrecision(typeInfo) || 0);
            case EdmPrimitiveTypeKind.Decimal:
                return this.convertDecimal(value, this._getPrecision(typeInfo), this._getScale(typeInfo) || 0);
            case EdmPrimitiveTypeKind.Single:
                return this.convertSingle(value);
            case EdmPrimitiveTypeKind.Double:
                return this.convertDouble(value);
            case EdmPrimitiveTypeKind.Guid:
                return this.convertGuid(value);
            case EdmPrimitiveTypeKind.Int16:
                return this.convertInt16(value);
            case EdmPrimitiveTypeKind.Int32:
                return this.convertInt32(value);
            case EdmPrimitiveTypeKind.Int64:
                return this.convertInt64(value);
            case EdmPrimitiveTypeKind.String:
                return this.convertString(value, this._getMaxLength(typeInfo));
            default:
                if (type.getKind() === EdmTypeKind.ENUM) return this.convertEnum(type, value);
                throw new SerializationError(
                    `Properties of '${type.getFullQualifiedName().toString()}' type are not supported`);
        }
    }

    /**
     * Return the "real" primitive type.
     * If type is a type definition, then the underlying primitive type is returned.
     *
     * @param {EdmPrimitiveType|EdmEnumType|EdmTypeDefinition} type - EDM type
     * @returns {EdmPrimitiveType} primitive type
     * @private
     */
    _getPrimitiveType(type) {
        const typeKind = type.getKind();
        if (typeKind === EdmTypeKind.PRIMITIVE || typeKind === EdmTypeKind.ENUM) return type;
        if (typeKind === EdmTypeKind.DEFINITION) return type.getUnderlyingType();
        throw new SerializationError(`Conversion of properties of ${typeKind} type kind is not supported`);
    }

    /**
     * Return value of the MaxLength facet if specified.
     * If the specified type is a TypeDefinition, then take also the type definition's facet into account.
     *
     * @param {(EdmProperty|EdmTerm|EdmType)} typeInfo - object containing metadata (e.g., facets)
     *
     * @returns {?(number|string)} value of MaxLength facet
     * @private
     */
    _getMaxLength(typeInfo) {
        if (typeInfo.getMaxLength && typeInfo.getMaxLength() != null) return typeInfo.getMaxLength();
        const type = typeInfo.getType ? typeInfo.getType() : typeInfo;
        if (type.getKind() === EdmTypeKind.DEFINITION) return type.getMaxLength();
        return null;
    }

    /**
     * Returns value of the Precision facet if specified.
     * If the specified type is a TypeDefinition, then take also the type definition's facet into account.
     *
     * @param {(EdmProperty|EdmTerm|EdmType)} typeInfo - object containing metadata (e.g., facets)
     *
     * @returns {?number} value of Precision facet
     * @private
     */
    _getPrecision(typeInfo) {
        if (typeInfo.getPrecision && typeInfo.getPrecision() != null) return typeInfo.getPrecision();
        const type = typeInfo.getType ? typeInfo.getType() : typeInfo;
        if (type.getKind() === EdmTypeKind.DEFINITION) return type.getPrecision();
        return null;
    }

    /**
     * Returns value of the Scale if specified.
     * If the specified type is a TypeDefinition, then take also the type definition's facet into account.
     *
     * @param {(EdmProperty|EdmTerm|EdmType)} typeInfo - object containing metadata (e.g., facets)
     *
     * @returns {?(number|string)} value of Scale facet
     * @private
     */
    _getScale(typeInfo) {
        if (typeInfo.getScale && typeInfo.getScale() != null) return typeInfo.getScale();
        const type = typeInfo.getType ? typeInfo.getType() : typeInfo;
        if (type.getKind() === EdmTypeKind.DEFINITION) return type.getScale();
        return null;
    }

    /**
     * Converts value to the value of Edm.Binary type.
     *
     * @param {Buffer} value - value, which should be converted
     * @param {number} [maxLength] - value of MaxLength facet
     *
     * @returns {string} Base64 string
     */
    convertBinary(value, maxLength) {
        this._valueValidator.validateBinary(value, maxLength);
        return value.toString('base64');
    }

    /**
     * Converts value to the value of Edm.Boolean type.
     *
     * @param {boolean} value - value, which should be converted
     *
     * @returns {boolean} converted value
     */
    convertBoolean(value) {
        this._valueValidator.validateBoolean(value);
        return value;
    }

    /**
     * Converts value to the value of Edm.Byte type.
     *
     * @param {number} value - value, which should be converted
     *
     * @returns {number} converted value
     */
    convertByte(value) {
        this._valueValidator.validateByte(value);
        return value;
    }

    /**
     * Converts value to the value of Edm.SByte type.
     *
     * @param {number} value - value, which should be converted
     *
     * @returns {number} converted value
     */
    convertSByte(value) {
        this._valueValidator.validateSByte(value);
        return value;
    }

    /**
     * Converts value to the value of Edm.Int16 type.
     *
     * @param {number} value - value, which should be converted
     *
     * @returns {number} converted value
     */
    convertInt16(value) {
        this._valueValidator.validateInt16(value);
        return value;
    }

    /**
     * Converts value to the value of Edm.Int32 type.
     *
     * @param {number} value - value, which should be converted
     *
     * @returns {number} converted value
     */
    convertInt32(value) {
        this._valueValidator.validateInt32(value);
        return value;
    }

    /**
     * Converts value to the value of Edm.Int64 type.
     *
     * @param {number|string} value - value, which should be converted
     *
     * @returns {number|string} converted value. The method returns string value if IEEE754 compatible
     * output is requested in the formatParams parameter of the constructor of this class.
     */
    convertInt64(value) {
        this._valueValidator.validateInt64(value);

        const bigValue = new Big(value);

        if (this._formatParams.getIEEE754Setting()) {
            // serialize the value as string
            return bigValue.toFixed();
        }

        // because the value must be serialized as a number (integer in this case), check whether the value can be
        // correctly represented as an integer in javascript
        if (bigValue.lt(Number.MIN_SAFE_INTEGER) || bigValue.gt(Number.MAX_SAFE_INTEGER)) {
            throw new SerializationError(`The Edm.Int64 value ${value} cannot be correctly serialized as an integer. ` +
                'IEEE754Compatible=true format parameter can be specified to serialize the value as a string');
        }

        return Number.parseInt(bigValue.toFixed(), 10);
    }

    /**
     * Converts value to the value of Edm.String type.
     *
     * @param {string} value - value, which should be converted
     * @param {number} [maxLength] - value of MaxLength facet
     *
     * @returns {string} converted value
     */
    convertString(value, maxLength) {
        this._valueValidator.validateString(value, maxLength);
        return value;
    }

    /**
     * Converts value to the value of Edm.Date type.
     *
     * @param {string} date - value, which should be converted
     *
     * @returns {string} converted value
     */
    convertDate(date) {
        this._valueValidator.validateDate(date);
        return date;
    }

    /**
     * Converts value to the value of Edm.DateTimeOffset type.
     *
     * @param {string} date - value, which should be converted
     * @param {number|string} precision - value of Precision facet
     *
     * @returns {string} converted value
     */
    convertDateTimeOffset(date, precision) {
        this._valueValidator.validateDateTimeOffset(date, precision);
        return date;
    }

    /**
     * Converts value to the value of Edm.TimeOfDay type.
     *
     * @param {string} time - value, which should be converted
     * @param {number|string} precision - value of Precision facet
     *
     * @returns {string} converted value
     */
    convertTimeOfDay(time, precision) {
        this._valueValidator.validateTimeOfDay(time, precision);
        return time;
    }

    /**
     * Converts value to the value of Edm.Duration type.
     *
     * @param {string} duration - value, which should be converted
     * @param {number|string} precision - value of Precision facet
     *
     * @returns {string} converted value
     */
    convertDuration(duration, precision) {
        this._valueValidator.validateDuration(duration, precision);
        return duration;
    }

    /**
     * Converts value to the value of Edm.Decimal type.
     *
     * @param {number|string} value - value, which should be converted
     * @param {number|string} precision - value of Precision facet
     * @param {number|string} scale - value of Scale facet
     *
     * @returns {number|string} converted value. The method returns string value if IEEE754 compatible
     * output is requested in the formatParams parameter of the constructor of this class.
     */
    convertDecimal(value, precision, scale) {
        this._valueValidator.validateDecimal(value, precision, scale);

        const bigValue = new Big(value);

        if (this._formatParams.getIEEE754Setting()) {
            // Serialize the value as string.
            return this._formatParams.getExponentialDecimalsSetting() ? bigValue.toExponential() : bigValue.toFixed();
        }

        // If scale is not specified or is 0 then the value must be serialized as an integer.
        if (scale == null || scale === 0) {
            // The value has to be a safe integer in javascript, to prevent rounding problems.
            if (bigValue.lt(Number.MIN_SAFE_INTEGER) || bigValue.gt(Number.MAX_SAFE_INTEGER)) {
                throw new SerializationError(`The Edm.Decimal value ${value} cannot be correctly serialized as an ` +
                    'integer. IEEE754Compatible=true format parameter can be specified to serialize the ' +
                    'value as a string');
            }

            return Number.parseInt(bigValue.toFixed(0), 10);
        }

        const absBigValue = bigValue.abs();
        // Because the value must be serialized as a number,
        // check whether the value can be correctly represented as a number in javascript.
        if ((absBigValue.lt(Number.MIN_VALUE) && absBigValue.gt(0)) || absBigValue.gt(Number.MAX_VALUE)) {
            throw new SerializationError(`The Edm.Decimal value ${value} cannot be correctly serialized as a number. ` +
                'IEEE754Compatible=true format parameter can be specified to serialize the value as a ' +
                'string');
        }

        return Number.parseFloat(bigValue.toFixed());
    }

    /**
     * Converts value to the value of Edm.Single type.
     *
     * @param {number} value - value, which should be converted
     *
     * @returns {number} converted value
     */
    convertSingle(value) {
        const nanOrInfinity = this._getNaNOrInfinity(value);
        if (nanOrInfinity) return nanOrInfinity;

        this._valueValidator.validateSingle(value);
        return value;
    }

    /**
     * Converts value to the value of Edm.Double type.
     *
     * @param {number} value - value, which should be converted
     *
     * @returns {number} converted value
     */
    convertDouble(value) {
        const nanOrInfinity = this._getNaNOrInfinity(value);
        if (nanOrInfinity) {
            return nanOrInfinity;
        }

        this._valueValidator.validateDouble(value);
        return value;
    }

    /**
     * Returns 'NaN', 'INF' or '-INF' if the value is not a number or infinity.
     *
     * @param {*} value - value, which potentially can be NaN or infinity
     *
     * @returns {?string} 'NaN', 'INF' or '-INF' if the value is not a number or infinity; otherwise - null
     * @private
     */
    _getNaNOrInfinity(value) {
        if (Number.isNaN(value)) return 'NaN';
        if (value === Number.POSITIVE_INFINITY) return 'INF';
        if (value === Number.NEGATIVE_INFINITY) return '-INF';
        return null;
    }

    /**
     * Converts value to the value of Edm.Guid type.
     *
     * @param {string} guid - value, which should be converted
     *
     * @returns {string} converted value
     */
    convertGuid(guid) {
        this._valueValidator.validateGuid(guid);
        return guid;
    }

    /**
     * Converts enumeration-type value to OData-formatted string.
     * @param {EdmEnumType} type enumeration type
     * @param {number} value value to be converted
     * @returns {string} converted value
     */
    convertEnum(type, value) {
        // Validate that the value is a number and in the supported range.
        this.convert(type.getUnderlyingType(), value);

        let result = [];
        let remaining = value;
        const flags = type.isFlags();
        for (const [name, member] of type.getMembers()) {
            const memberValue = member.getValue();
            if (flags) {
                // Use bitwise AND operator to check whether all bits of the member value are set.
                if ((memberValue & remaining) === memberValue) {
                    result.push(name);
                    // Use bitwise XOR operator to remove the member-value bits from the remaining value.
                    remaining ^= memberValue;
                }
            } else {
                if (value === memberValue) return name;
            }
        }
        if (!flags || remaining !== 0) {
            throw new SerializationError(
                `Invalid value '${value}' for enumeration type '${type.getFullQualifiedName()}'`);
        }
        return result.join(',');
    }
}

module.exports = ValueConverter;
