'use strict';

// Please load the module cache at first;
// otherwise you raise the possibility for cycling dependencies.
require('../ModuleCache');

const BatchContext = require('../batch/BatchContext');
const BatchEndCommand = require('../invocation/batch/BatchEndCommand');
const CommandFactory = require('../invocation/CommandFactory');
const CommandExecutor = require('../invocation/CommandExecutor');

/**
 * Processes all requests to $batch. This includes multipart deserialization, request and atomicity group validation,
 * execution of batched requests and serialization of responses.
 */
class BatchHandler {

    /**
     * This method is called when a $batch request comes in.
     *
     * @param {OdataRequest} request - the OData request
     * @param {OdataResponse} response - the OData response
     * @param {Function} next - The callback function with signature next(error, resultData).
     */
    static handle(request, response, next) {
        const service = request.getService();
        const batchContext = new BatchContext(request, response, service);
        const data = request.getBody();
        batchContext.setBatchBoundary(data.boundary);
        batchContext.setSemantic(data.semantic);
        batchContext.setRequestList(data.requests);

        const commands = CommandFactory.createBatchCommands(batchContext);

        new CommandExecutor(request.getLogger()).execute(commands, null, null, err => {
            // at this point the batch processing should be finished and the responses from the batched requests are
            // collected inside the batchContext

            // emit the batch end event
            const endCommand = new BatchEndCommand(batchContext);
            return endCommand.execute(
                applicationError => applicationError ? next(applicationError) : next(err, batchContext),
                err); // emit batch end event
        });
    }
}

module.exports = BatchHandler;
