'use strict';

const validateThat = require('../validator/ParameterValidator').validateThat;
const EdmTypeKind = require('../edm/EdmType').TypeKind;
const ResourceKind = require('../uri/UriResource').ResourceKind;
const UriHelper = require('../uri/UriHelper');
const QueryOptions = require('../uri/UriInfo').QueryOptions;
const RepresentationKind = require('../format/RepresentationKind').Kinds;
const SerializationError = require('../errors/SerializationError');

/**
 * Context URL construction.
 */
class ContextURLFactory {
    /**
     * Creates context URL for the request URI represented by the uriInfo input parameter.
     *
     * @param {UriInfo} uriInfo information about the request URI
     * @param {?ExpandItem[]} expand expand items
     * @param {RepresentationKind.Kinds} representationKind the representation kind
     * @param {Map<UriResource,Object>} [providedKeyMap] the application-provided keys for each path segment
     *                                                   (see docs in context-url-building.md file)
     * @param {Edm} edm
     * @returns {string} Context URL
     */
    createContextURL(uriInfo, expand, representationKind, providedKeyMap = new Map(), edm) {
        validateThat('uriInfo', uriInfo).truthy().instanceOf(Object);

        const pathSegments = uriInfo.getPathSegments();

        if (pathSegments[0].getKind() === ResourceKind.SERVICE) return '$metadata';
        if (pathSegments[0].getKind() === ResourceKind.METADATA) return '';

        const contextUrlInfo = this._parseSegments(pathSegments, providedKeyMap, edm);

        const contextUrlPrefix = contextUrlInfo.hasReferencedSegment ? '/' : '../'.repeat(pathSegments.length - 1);

        const isCollection = pathSegments[pathSegments.length - 1].isCollection();
        const finalEdmType = uriInfo.getFinalEdmType();

        let url = contextUrlInfo.result;
        if (contextUrlInfo.isOnlyTyped && !url) {
            url = finalEdmType.getFullQualifiedName().toString();
            if (isCollection) url = 'Collection(' + url + ')';
        }

        const entityType = finalEdmType && finalEdmType.getKind() === EdmTypeKind.ENTITY ? finalEdmType : null;
        const isEntity = !contextUrlInfo.isOnlyTyped
            && (entityType && !isCollection || representationKind === RepresentationKind.ENTITY);

        const selectItems = uriInfo.getQueryOption(QueryOptions.SELECT);
        // Transient types introduced by Data Aggregation have a select list if they are aggregated.
        // In that case key properties are not required, even in expanded entities.
        const isReduced = finalEdmType && finalEdmType.isReduced && finalEdmType.isReduced();
        let select = this._buildSelect(selectItems, expand, entityType, !isReduced);
        if (!selectItems && isReduced) select = select.concat(Array.from(finalEdmType.getProperties().keys()));
        const selectString = select.length ? '(' + select.join(',') + ')' : '';

        return contextUrlPrefix + '$metadata#' + url + selectString + (isEntity ? '/$entity' : '');
    }

    /**
     * Parse the URI segments.
     *
     * @param {UriResource[]} pathSegments the path segments
     * @param {Map<UriResource,Object>} keyMap the application-provided keys for each path segment
     * @param {Edm} edm
     * @returns {{result: string, isOnlyTyped: boolean, hasReferencedSegment: boolean}} a result object
     * @private
     */
    _parseSegments(pathSegments, keyMap, edm) {
        const localNamespace = edm.getEntityContainer().getFullQualifiedName().namespace;

        let result = [];
        let isOnlyTyped = false;
        let hasReferencedSegment = false;
        let isFinal = false;

        // The iteration starts at the end and goes backwards until a final result has been obtained.
        for (let index = pathSegments.length - 1; index >= 0; index--) {
            const segment = pathSegments[index];

            if (this._isReferencedSegment(segment, localNamespace)) hasReferencedSegment = true;

            const edmType = segment.getEdmType();
            const providedKeys = keyMap.get(segment);

            const kind = segment.getKind();
            switch (kind) {
                case ResourceKind.ENTITY:
                    result.unshift(segment.getEntitySet().getName()
                        + (pathSegments.length > index + 1 ?
                            this._buildKeys(edmType, segment.getKeyPredicates(), providedKeys) :
                            ''));
                    break;
                case ResourceKind.ENTITY_COLLECTION:
                    result.unshift(segment.getEntitySet().getName());
                    break;
                case ResourceKind.SINGLETON:
                    result.unshift(segment.getSingleton().getName());
                    isOnlyTyped = true;  // hack that signals to the caller that '/$entity' must not be appended
                    break;

                case ResourceKind.NAVIGATION_TO_ONE:
                case ResourceKind.NAVIGATION_TO_MANY: {
                    const edmNavigationProperty = segment.getNavigationProperty();
                    const keys = result.length && !segment.isCollection() ?
                        this._buildKeys(edmType, segment.getKeyPredicates(), providedKeys) :
                        '';
                    if (edmNavigationProperty.containsTarget()) {
                        result.unshift(edmNavigationProperty.getName()
                            + (edmNavigationProperty.isCollection() ? keys : ''));
                    } else {
                        result.unshift(segment.getTarget().getName() + keys);
                        isFinal = true;
                    }
                    break;
                }

                case ResourceKind.REF:
                    result.unshift('$ref');
                    isOnlyTyped = true;  // hack that signals to the caller that '/$entity' must not be appended
                    break;
                case ResourceKind.REF_COLLECTION:
                    result.unshift('Collection($ref)');
                    isFinal = true;
                    break;

                case ResourceKind.PRIMITIVE_PROPERTY:
                case ResourceKind.PRIMITIVE_COLLECTION_PROPERTY:
                case ResourceKind.COMPLEX_PROPERTY:
                case ResourceKind.COMPLEX_COLLECTION_PROPERTY:
                    result.unshift(segment.getProperty().getName());
                    break;

                case ResourceKind.FUNCTION_IMPORT:
                case ResourceKind.ACTION_IMPORT:
                case ResourceKind.BOUND_FUNCTION:
                case ResourceKind.BOUND_ACTION:
                    if (segment.getTarget()) {
                        result.unshift(segment.getTarget().getName());
                        isFinal = true;
                    } else {
                        result = [];
                        isOnlyTyped = true;
                    }
                    break;

                case ResourceKind.TYPE_CAST:
                    result.unshift(edmType.getFullQualifiedName());
                    break;

                case ResourceKind.CROSSJOIN:
                    result.unshift('Collection(Edm.ComplexType)');
                    break;

                case ResourceKind.ALL:
                    if (result.length) isOnlyTyped = true;  // typecast segment after $all
                    result = isOnlyTyped ? [] : ['Collection(Edm.EntityType)'];
                    break;

                default:
                    throw new SerializationError('Unsupported segment type found in url path segments: ' + kind);
            }
            if (isOnlyTyped || isFinal) break;
        }
        return { result: result.join('/'), isOnlyTyped, hasReferencedSegment };
    }

    /**
     * Returns true if the provided segment is a referenced segment existing in a referenced service.
     *
     * @param {UriResource} segment the URI resource segment to check
     * @param {string} localNamespace the local namespace
     * @returns {boolean} true if the segment is referenced, false otherwise
     * @private
     */
    _isReferencedSegment(segment, localNamespace) {
        const entitySet = segment.getTarget() || segment.getEntitySet() || segment.getSingleton();
        return entitySet !== null && entitySet.getEntityType().getFullQualifiedName().namespace !== localNamespace;
    }

    /**
     * Builds the key parameter string from URI parameters and provided keys.
     * The result will be a string looking like "(PropertyInt16,PropertyString)".
     *
     * @param {EdmEntityType} edmType the edm entity type where the keys exist
     * @param {UriParameter[]} uriParameters the key predicates to build
     * @param {Object} [providedKeys] the application-provided keys (see also context-url-building.md)
     * @returns {string} the result string
     * @private
     */
    _buildKeys(edmType, uriParameters, providedKeys = {}) {
        let resultKeys = UriHelper.buildKeyPredicates(uriParameters);

        // Add missing keys from application-provided keys to the existing keys extracted from the URI.
        // A provided key is only added to the existing keys if this key does not exist already.
        const availableKeys = edmType.getKeyPropertyRefs();
        for (const name of Object.keys(providedKeys)) {
            if (!availableKeys.has(name)) {
                throw new SerializationError(
                    `Key property '${name}' does not exist in '${edmType.getFullQualifiedName()}'`);
            }
            if (!resultKeys.find(elem => elem.name === name)) {
                const propertyType = availableKeys.get(name).getProperty().getType();
                resultKeys.push({ name, value: providedKeys[name], type: propertyType });
            }
        }

        if (resultKeys.length && resultKeys.length < availableKeys.size) {
            throw new SerializationError("Missing key value(s) for '" + edmType.getFullQualifiedName() + "'");
        }

        return resultKeys.length > 0 ? UriHelper.buildKeyString(resultKeys) : '';
    }

    /**
     * Builds the context url select list.
     *
     * @param {?SelectItem[]} select select items
     * @param {?ExpandItem[]} expand expand items
     * @param {?EdmEntityType} type the type of the current entity or null
     * @param {boolean} isKeyRequired whether key properties are required for the select list
     * @returns {string[]} the built select list
     * @private
     */
    _buildSelect(select, expand, type, isKeyRequired) {
        let value = [];

        if (select) {
            let isAll = false;
            value = select.map(selectItem => {
                if (selectItem.isAllOperationsInSchema()) {
                    return selectItem.getAllOperationsInSchemaNamespace() + '.*';
                }
                if (selectItem.isAll()) {
                    isAll = true;
                    return '*';
                }
                return selectItem.getPathSegments()
                    .map(uriResource => uriResource.getPathSegmentIdentifier())
                    .join('/');
            });

            // If there is one '*' selected, the context URL contains only '*'.
            if (isAll) {
                value = ['*'];
            } else if (type && isKeyRequired) {
                for (const keyName of type.getKeyPropertyRefs().keys()) {
                    if (!value.includes(keyName)) value.push(keyName);
                }
            }
        }

        if (expand && expand.length) {
            const expandValue = this._buildExpand(expand, type, isKeyRequired);
            if (expandValue) value.push(expandValue);
        }

        return value;
    }

    /**
     * Builds the expand context URL part string. This includes nested select items and nested expands.
     *
     * @param {ExpandItem[]} expand the expand items to be processed
     * @param {EdmEntityType} type the type of the expanded entity
     * @param {boolean} isKeyRequired whether key properties are required for the select list
     * @returns {string} the expand context URL string
     * @private
     */
    _buildExpand(expand, type, isKeyRequired) {
        let result = [];
        for (const expandItem of expand) {
            const expandItemPathsegments = expandItem.getPathSegments();
            const finalResourceSegment = expandItemPathsegments[expandItemPathsegments.length - 1];
            // /$count on an expanded entity -> The navigation property shall not be part of the Context URI.
            if (finalResourceSegment && finalResourceSegment.getKind() === ResourceKind.COUNT) continue;

            const pathSegmentIdentifier = expandItemPathsegments.map(segment => segment.getPathSegmentIdentifier())
                .join('/');

            let nextExpandItems = expandItem.getOption(QueryOptions.EXPAND);

            const selectItems = expandItem.getOption(QueryOptions.SELECT);
            if (selectItems) {
                let plusSign = '';
                if (expandItem.getOption('$levels')) {
                    // The '+' only should be used if the expanded property has a $levels option.
                    // The recursion should end here also. Therefore setting possibly next expand
                    // item to null.
                    plusSign = '+';
                    nextExpandItems = null;
                }
                const nextSelect = this._buildSelect(selectItems, nextExpandItems,
                    finalResourceSegment.getEdmType(), isKeyRequired);
                const nextSelectBuild = nextSelect.length ? `(${nextSelect.join(',')})` : '';
                result.push(pathSegmentIdentifier + plusSign + nextSelectBuild);
            } else if (nextExpandItems) {
                const nestedExpand =
                    this._buildExpand(nextExpandItems, finalResourceSegment.getEdmType(), isKeyRequired)
                    || '';
                result.push(finalResourceSegment.getPathSegmentIdentifier() + '(' + nestedExpand + ')');
            } else if (pathSegmentIdentifier) {
                // Regarding to an internal discussion on the structure of the context url
                // the following decision was made:
                // $metadata#ESAllPrim     -> All Properties
                // $metadata#ESAllPrim(PrimProperty)  -> Only PrimProperty from $select
                // $metadata#ESAllPrim(NavPropertyETTwoPrimMany()) -> All Properties of ESAllPrim and
                //      NavPropertyETTwoPrimMany expanded with all properties
                // $metadata#ESAllPrim(PrimProperty,NavPropertyETTwoPrimMany()) -> PrimProperty of ESAllPrim and
                //      NavPropertyETTwoPrimMany expanded with all properties
                // See also https://issues.oasis-open.org/browse/ODATA-1156

                result.push(pathSegmentIdentifier + '(' + (expandItem.isAll() ? '*' : '') + ')');
            } else if (expandItem.isAll()) {
                for (const name of type.getNavigationProperties().keys()) result.push(name + '()');
            } else {
                result.push('');
            }
        }

        return result.join(',');
    }
}

module.exports = ContextURLFactory;
