'use strict';

const moduleCache = require('../ModuleCache');
const EdmTypeKind = require('../edm/EdmType').TypeKind;
const EdmPrimitiveTypeKind = require('../edm/EdmPrimitiveTypeKind');
const validateThat = require('../validator/ParameterValidator').validateThat;
const ValueConverter = require('../utils/ValueConverter');
const ValueValidator = require('../validator/ValueValidator');
const ExpressionKinds = require('../csdl/annotationExpression/CsdlAnnotationExpression').kinds;
const SerializationError = require('../errors/SerializationError');
const NotImplementedError = require('../errors/NotImplementedError');
const JsonContentTypeInfo = require('../format/JsonContentTypeInfo');

const EXTENDS = 'Extends';
const TARGET = 'Target';
const PATH = 'Path';
const NAVIGATION_PROPERTY_BINDING = 'NavigationPropertyBinding';
const UNDERLYING_TYPE = 'UnderlyingType';
const PROPERTY_REF = 'PropertyRef';
const KEY = 'Key';
const SCALE = 'Scale';
const PRECISION = 'Precision';
const MAX_LENGTH = 'MaxLength';
const DEFAULT_VALUE = 'DefaultValue';
const UNICODE = 'Unicode';
const PROPERTY = 'Property';
const PARTNER = 'Partner';
const NULLABLE = 'Nullable';
const NAVIGATION_PROPERTY = 'NavigationProperty';
const REFERENTIAL_CONSTRAINT = 'ReferentialConstraint';
const REFERENCED_PROPERTY = 'ReferencedProperty';
const HAS_STREAM = 'HasStream';
const BASE_TYPE = 'BaseType';
const COMPLEX_TYPE = 'ComplexType';
const RETURN_TYPE = 'ReturnType';
const TYPE = 'Type';
const COLLECTION = 'Collection';
const PARAMETER = 'Parameter';
const IS_COMPOSABLE = 'IsComposable';
const IS_BOUND = 'IsBound';
const ENTITY_TYPE = 'EntityType';
const SINGLETON = 'Singleton';
const ACTION = 'Action';
const ACTION_IMPORT = 'ActionImport';
const INCLUDE_IN_SERVICE_DOCUMENT = 'IncludeInServiceDocument';
const ENTITY_SET = 'EntitySet';
const FUNCTION = 'Function';
const FUNCTION_IMPORT = 'FunctionImport';
const NAME = 'Name';
const ENTITY_CONTAINER = 'EntityContainer';
const ALIAS = 'Alias';
const NAMESPACE = 'Namespace';
const ENUM_TYPE = 'EnumType';
const IS_FLAGS = 'IsFlags';
const MEMBER = 'Member';
const VALUE = 'Value';
const TYPE_DEFINITION = 'TypeDefinition';
const REFERENCE = 'Reference';
const INCLUDE = 'Include';
const INCLUDE_ANNOTATIONS = 'IncludeAnnotations';
const TERM_NAMESPACE = 'TermNamespace';
const TARGET_NAMESPACE = 'TargetNamespace';
const QUALIFIER = 'Qualifier';
const URI = 'Uri';
const SCHEMA = 'Schema';
const DATA_SERVICES = 'DataServices';
const ABSTRACT = 'Abstract';
const PREFIX_EDMX = 'edmx';

const EDMX = 'Edmx';
const NS_EDMX = 'http://docs.oasis-open.org/odata/ns/edmx';

const NS_EDM = 'http://docs.oasis-open.org/odata/ns/edm';
const ENTITY_SET_PATH = 'EntitySetPath';
const CONTAINS_TARGET = 'ContainsTarget';

const TERM = 'Term';
const BASE_TERM = 'BaseTerm';
const APPLIES_TO = 'AppliesTo';
const ANNOTATION = 'Annotation';
const ANNOTATIONS = 'Annotations';
const ANNOTATION_PATH = 'AnnotationPath';
const APPLY = 'Apply';
const CAST = 'Cast';
const IF = 'If';
const IS_OF = 'IsOf';
const LABELED_ELEMENT = 'LabeledElement';
const LABELED_ELEMENT_REFERENCE = 'LabeledElementReference';
const MODEL_ELEMENT_PATH = 'ModelElementPath';
const NULL = 'Null';
const NAVIGATION_PROPERTY_PATH = 'NavigationPropertyPath';
const PROPERTY_PATH = 'PropertyPath';
const NEG = 'Neg';
const NOT = 'Not';
const RECORD = 'Record';
const PROPERTY_VALUE = 'PropertyValue';
const URL_REF = 'UrlRef';

const CONSTANT_CONVERTERS = {
    'edm:Binary': 'convertBinary',
    'edm:Bool': 'convertBoolean',
    'edm:Date': 'convertDate',
    'edm:DateTimeOffset': 'convertDateTimeOffset',
    'edm:Decimal': 'convertDecimal',
    'edm:Duration': 'convertDuration',
    'edm:Float': 'convertDouble',
    'edm:Guid': 'convertGuid',
    'edm:Int': 'convertInt64',
    'edm:String': 'convertString',
    'edm:TimeOfDay': 'convertTimeOfDay'
};

const EXPRESSION_SERIALIZERS = {
    [ExpressionKinds.Collection]: '_serializeCollectionExpr',
    [ExpressionKinds.Path]: '_serializePathExpr',
    [ExpressionKinds.Arithmetic]: '_serializeArithmeticExpr',
    [ExpressionKinds.Binary]: '_serializeBinaryExpr',
    [ExpressionKinds.Negation]: '_serializeNegationExpr',
    [ExpressionKinds.Not]: '_serializeNotExpr',
    [ExpressionKinds.PropertyPath]: '_serializePropertyPathExpr',
    [ExpressionKinds.Constant]: '_serializeConstantExpr',
    [ExpressionKinds.AnnotationPath]: '_serializeAnnotationPathExpr',
    [ExpressionKinds.LabeledElement]: '_serializeLabeledElementExpr',
    [ExpressionKinds.LabeledElementReference]: '_serializeLabeledElementReferenceExpr',
    [ExpressionKinds.ModelElementPath]: '_serializeModelElementPathExpr',
    [ExpressionKinds.NavigationPropertyPath]: '_serializeNavigationPropertyPathExpr',
    [ExpressionKinds.Null]: '_serializeNullExpr',
    [ExpressionKinds.Apply]: '_serializeApplyExpr',
    [ExpressionKinds.If]: '_serializeIfExpr',
    [ExpressionKinds.Record]: '_serializeRecordExpr',
    [ExpressionKinds.PropertyValue]: '_serializePropertyValueExpr',
    [ExpressionKinds.UrlRef]: '_serializeUrlRefExpr',
    [ExpressionKinds.Cast]: '_serializeCastExpr',
    [ExpressionKinds.IsOf]: '_serializeIsOfExpr'
};

/**
 * XML serializer for EDM metadata.
 */
class MetadataXmlSerializer {

    /**
     * @param {Edm} edm - Edm instance, representing metadata of the service
     * @param {LoggerFacede} logger - Logger instance
     */
    constructor(edm, logger) {
        validateThat('edm', edm).truthy().instanceOf(Object);

        this._xmlbuilder = moduleCache.lookup('xmlbuilder');

        this._logger = logger;
        this._edm = edm;
        this._namespaceToAlias = new Map();

        // Create value converter with IEEE754 format parameter because there are no restrictions in XML
        // related to the value range of numbers. Therefore, the parameter is passed to prevent unnecessary
        // validations.
        this._valueConverter = new ValueConverter(new ValueValidator(),
            new JsonContentTypeInfo().addParameter(JsonContentTypeInfo.FormatParameter.IEEE754, 'true'));
    }

    /**
     * Serializes EDM metadata into XML string.
     * @returns {string} metadata XML
     */
    serialize() {
        let xmlStreamClosed = false;
        let edmxElement;
        try {
            edmxElement = this._createEdmxElement();
            this._xml = edmxElement;

            this._serializeReferences(edmxElement);
            this._serializeDataServices(edmxElement);

            // end the document, i.e. close any unclosed xml tags
            const result = edmxElement.end();
            xmlStreamClosed = true;
            return result;
        } catch (e) {
            // Close underlying stream -> Prevent memory leaks
            if (xmlStreamClosed !== true && edmxElement != null) {
                if (this._logger) {
                    this._logger.debug('Following xml could be created (until error): ' + edmxElement.toString());
                }
                edmxElement.end();
            }
            throw new SerializationError('An error occurred during serialization of metadata document', e);
        }
    }

    /**
     * Creates Edmx element.
     *
     * @returns {Object} object representation of the created XML element
     * @private
     */
    _createEdmxElement() {
        return this._xmlbuilder.create(PREFIX_EDMX + ':' + EDMX, { version: '1.0', encoding: 'UTF-8' })
            .attribute('xmlns', NS_EDM)
            .attribute('xmlns:' + PREFIX_EDMX, NS_EDMX)
            .attribute('Version', '4.0');
    }

    /**
     * Adds DataServices element
     *
     * @param {*} edmx
     * @private
     */
    _serializeDataServices(edmx) {
        const dataServicesElement = edmx.element(PREFIX_EDMX + ':' + DATA_SERVICES);

        // First find referenced external services and their namespaces
        const referencedServices = new Map();
        Array.from(this._edm.getReferences().values()).forEach(reference =>
            reference.getIncludes().forEach(include => referencedServices.set(include.getNamespace(), include))
        );

        for (const schema of this._edm.getSchemas()) {
            // Only adding those schema which are not referenced
            // Currently cross service referencing is done by reference the external service
            // inside the $Reference csdl property AND creating a corresponding second schema
            // namespace in the csdl model. The metadata xml should not serialize this
            // external model so it is filtered out.
            if (referencedServices.get(schema.getNamespace()) == null) {
                this._serializeSchema(dataServicesElement, schema);
            }
        }
    }

    /**
     * Serializes Schema
     *
     * @param {*} dataServicesElement
     * @param {*} schema
     * @private
     */
    _serializeSchema(dataServicesElement, schema) {
        try {
            const schemaElement = dataServicesElement.element(SCHEMA)
                .attribute(NAMESPACE, schema.getNamespace());

            if (schema.getAlias()) {
                schemaElement.attribute(ALIAS, schema.getAlias());
                this._namespaceToAlias.set(schema.getNamespace(), schema.getAlias());
            }

            // EnumTypes
            this._serializeEnumTypes(schemaElement, schema.getEnumTypes());

            // TypeDefinitions
            this._serializeTypeDefinitions(schemaElement, schema.getTypeDefinitions());

            // EntityTypes
            this._serializeEntityTypes(schemaElement, schema.getEntityTypes());

            // ComplexTypes
            this._serializeComplexTypes(schemaElement, schema.getComplexTypes());

            // Actions
            this._serializeActions(schemaElement, schema.getActions());

            // Functions
            this._serializeFunctions(schemaElement, schema.getFunctions());

            // Terms
            this._serializeTerms(schemaElement, schema.getTerms());

            // EntityContainer
            this._serializeEntityContainer(schemaElement, schema.getEntityContainer());

            // Annotations
            this._serializeExternalAnnotations(schemaElement, schema.getExternalAnnotations());
            this._serializeAnnotations(schemaElement, schema);
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Schema', e);
        }
    }

    /**
     * Serializes enumeration types.
     * @param {*} schemaElement
     * @param {*} enumTypes
     * @private
     */
    _serializeEnumTypes(schemaElement, enumTypes) {
        try {
            for (const enumType of enumTypes) {
                let element = schemaElement.element(ENUM_TYPE)
                    .attribute(NAME, enumType.getName())
                    .attribute(UNDERLYING_TYPE,
                        this._getAliasedFQN(enumType.getUnderlyingType().getFullQualifiedName()));

                if (enumType.isFlags()) element.attribute(IS_FLAGS, enumType.isFlags());

                for (const [name, member] of enumType.getMembers()) {
                    const memberElement = element.element(MEMBER)
                        .attribute(NAME, name)
                        .attribute(VALUE, member.getValue());

                    this._serializeAnnotations(memberElement, member);
                }

                this._serializeAnnotations(element, enumType);
            }
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Enumeration Type', e);
        }
    }

    /**
     * Serializes TypeDefinitions
     *
     * @param {*} schemaElement
     * @param {*} typeDefinitions
     * @private
     */
    _serializeTypeDefinitions(schemaElement, typeDefinitions) {
        try {
            for (const typeDef of typeDefinitions) {
                const typeDefElement = schemaElement.element(TYPE_DEFINITION)
                    .attribute(NAME, typeDef.getName())
                    .attribute(UNDERLYING_TYPE,
                        this._getAliasedFQN(typeDef.getUnderlyingType().getFullQualifiedName()));

                this._serializeFacets(typeDefElement, typeDef);

                this._serializeAnnotations(typeDefElement, typeDef);
            }
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Type Definition', e);
        }
    }

    /**
     * Serializes EntityContainer
     *
     * @param {*} schemaElement
     * @param {*} container
     * @private
     */
    _serializeEntityContainer(schemaElement, container) {
        if (!container) return;

        try {
            const containerElement = schemaElement.element(ENTITY_CONTAINER)
                .attribute(NAME, container.getName());

            const parentContainerNameFqn = container.getParentContainerName();
            if (parentContainerNameFqn) {
                const parentContainerName = this._getAliasedFQN(parentContainerNameFqn);
                containerElement.attribute(EXTENDS, parentContainerName);
            }

            // EntitySets
            this._serializeEntitySets(containerElement, container.getEntitySets());

            // ActionImports
            this._serializeActionImports(containerElement, container.getActionImports());

            // FunctionImports
            this._serializeFunctionImports(containerElement, container.getFunctionImports());

            // Singletons
            this._serializeSingletons(containerElement, container.getSingletons());

            this._serializeAnnotations(containerElement, container);
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Entity Container', e);
        }
    }

    /**
     * Serializes FunctionImports
     *
     * @param {*} containerElement
     * @param {*} functionImports
     * @private
     */
    _serializeFunctionImports(containerElement, functionImports) {
        try {
            for (const functionImport of functionImports) {
                const functionImportElement = containerElement.element(FUNCTION_IMPORT)
                    .attribute(NAME, functionImport.getName());

                const functionName = this._getAliasedFQN(functionImport.getFunctionFqn());
                functionImportElement.attribute(FUNCTION, functionName);

                const returnedEntitySet = functionImport.getReturnedEntitySet();
                if (returnedEntitySet) {
                    functionImportElement.attribute(ENTITY_SET,
                        this._getAliasedFQN(returnedEntitySet.getEntityContainer().getFullQualifiedName())
                        + '/'
                        + returnedEntitySet.getName());
                }

                // Default is false and we do not write the default
                if (functionImport.isIncludeInServiceDocument()) {
                    functionImportElement.attribute(INCLUDE_IN_SERVICE_DOCUMENT,
                        functionImport.isIncludeInServiceDocument());
                }

                this._serializeAnnotations(functionImportElement, functionImport);
            }
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Function Import', e);
        }
    }

    /**
     * Serializes ActionImports
     *
     * @param {*} containerElement
     * @param {*} actionImports
     * @private
     */
    _serializeActionImports(containerElement, actionImports) {
        try {
            for (const actionImport of actionImports) {
                const actionImportElement = containerElement.element(ACTION_IMPORT)
                    .attribute(NAME, actionImport.getName())
                    .attribute(ACTION, this._getAliasedFQN(actionImport.getUnboundAction().getFullQualifiedName()));

                let returnedEntitySet = actionImport.getReturnedEntitySet();
                if (returnedEntitySet) {
                    actionImportElement.attribute(ENTITY_SET,
                        this._getAliasedFQN(returnedEntitySet.getEntityContainer().getFullQualifiedName())
                        + '/'
                        + returnedEntitySet.getName());
                }

                this._serializeAnnotations(actionImportElement, actionImport);
            }
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Action Import', e);
        }
    }

    /**
     * Serializes Singletons
     *
     * @param {*} containerElement
     * @param {*} singletons
     * @private
     */
    _serializeSingletons(containerElement, singletons) {
        let last;
        try {
            for (const singleton of singletons) {
                last = singleton;
                const singletonElement = containerElement.element(SINGLETON)
                    .attribute(NAME, singleton.getName())
                    .attribute(TYPE, this._getAliasedFQN(singleton.getEntityType().getFullQualifiedName()));

                this._serializeNavigationPropertyBindings(singletonElement, singleton);

                this._serializeAnnotations(singletonElement, singleton);
            }
        } catch (e) {
            throw new SerializationError(`An error occurred during serialization of Singleton '${last.getName()}'`, e);
        }
    }

    /**
     * Serializes NavigationPropertyBindings
     *
     * @param {*} entitySetElement
     * @param {*} bindingTarget
     * @private
     */
    _serializeNavigationPropertyBindings(entitySetElement, bindingTarget) {
        if (!bindingTarget.getNavigationPropertyBindings()) return;

        try {
            for (const binding of bindingTarget.getNavigationPropertyBindings()) {
                entitySetElement.element(NAVIGATION_PROPERTY_BINDING)
                    .attribute(PATH, binding.getPath())
                    .attribute(TARGET, binding.getTarget());
            }
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Navigation Property Binding', e);
        }
    }

    /**
     * Serializes EntitySets
     *
     * @param {*} containerElement
     * @param {*} entitySets
     * @private
     */
    _serializeEntitySets(containerElement, entitySets) {
        try {
            for (const entitySet of entitySets) {
                const entitySetElement = containerElement.element(ENTITY_SET)
                    .attribute(NAME, entitySet.getName())
                    .attribute(ENTITY_TYPE, this._getAliasedFQN(entitySet.getEntityType().getFullQualifiedName()));

                if (!entitySet.isIncludeInServiceDocument()) {
                    entitySetElement.attribute(INCLUDE_IN_SERVICE_DOCUMENT, entitySet.isIncludeInServiceDocument());
                }

                this._serializeNavigationPropertyBindings(entitySetElement, entitySet);

                this._serializeAnnotations(entitySetElement, entitySet);
            }
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Entity Set', e);
        }
    }

    /**
     * Serializes Functions
     *
     * @param {*} schemaElement
     * @param {*} functions
     * @private
     */
    _serializeFunctions(schemaElement, functions) {
        try {
            for (const edmFunction of functions) {
                const functionElement = schemaElement.element(FUNCTION)
                    .attribute(NAME, edmFunction.getName());

                if (edmFunction.getEntitySetPath()) {
                    functionElement.attribute(ENTITY_SET_PATH, edmFunction.getEntitySetPath());
                }
                if (edmFunction.isBound()) {
                    functionElement.attribute(IS_BOUND, edmFunction.isBound());
                }

                if (edmFunction.isComposable()) {
                    functionElement.attribute(IS_COMPOSABLE, edmFunction.isComposable());
                }

                this._serializeOperationParameters(functionElement, edmFunction);

                this._serializeOperationReturnType(functionElement, edmFunction);

                this._serializeAnnotations(functionElement, edmFunction);
            }
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Function', e);
        }
    }

    /**
     * Serializes ReturnType
     *
     * @param {*} operationElement
     * @param {*} operation
     * @private
     */
    _serializeOperationReturnType(operationElement, operation) {
        const returnType = operation.getReturnType();

        if (!returnType) return;

        try {
            const returnTypeElement = operationElement.element(RETURN_TYPE)
                .attribute(TYPE,
                    this._getAliasedFQN(returnType.getType().getFullQualifiedName(), returnType.isCollection()));
            this._serializeFacets(returnTypeElement, returnType);

            this._serializeAnnotations(returnTypeElement, returnType);
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Return Type', e);
        }
    }

    /**
     * Serializes Parameters
     *
     * @param {*} operationElement
     * @param {*} operation
     * @private
     */
    _serializeOperationParameters(operationElement, operation) {
        try {
            for (const [parameterName, parameter] of operation.getParameters()) {
                const parameterElement = operationElement.element(PARAMETER)
                    .attribute(NAME, parameterName)
                    .attribute(TYPE,
                        this._getAliasedFQN(parameter.getType().getFullQualifiedName(), parameter.isCollection()));

                this._serializeFacets(parameterElement, parameter);

                this._serializeAnnotations(parameterElement, parameter);
            }
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Parameter', e);
        }
    }

    /**
     * Serializes Actions
     *
     * @param {*} schemaElement
     * @param {*} actions
     * @private
     */
    _serializeActions(schemaElement, actions) {
        try {
            for (const action of actions) {
                const actionElement = schemaElement.element(ACTION)
                    .attribute(NAME, action.getName());

                if (action.getEntitySetPath()) {
                    actionElement.attribute(ENTITY_SET_PATH, action.getEntitySetPath());
                }
                if (action.isBound()) {
                    actionElement.attribute(IS_BOUND, action.isBound());
                }

                this._serializeOperationParameters(actionElement, action);

                this._serializeOperationReturnType(actionElement, action);

                this._serializeAnnotations(actionElement, action);
            }
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Action', e);
        }
    }

    /**
     * Serializes facets
     *
     * @param {*} facetableElement
     * @param {*} facetable
     * @private
     */
    _serializeFacets(facetableElement, facetable) {
        // not all the EDM elements support Nullable facet,
        // therefore first check whether the facetable has isNullable function
        if (facetable.isNullable && !facetable.isNullable()) {
            facetableElement.attribute(NULLABLE, facetable.isNullable());
        }
        if (facetable.getMaxLength() != null) {
            facetableElement.attribute(MAX_LENGTH, facetable.getMaxLength());
        }
        if (facetable.getPrecision() != null) {
            if (facetable.getPrecision() !== 0
                || facetable.getType && facetable.getType() === EdmPrimitiveTypeKind.Decimal
                || facetable.getUnderlyingType && facetable.getUnderlyingType() === EdmPrimitiveTypeKind.Decimal) {
                facetableElement.attribute(PRECISION, facetable.getPrecision());
            }
        }
        if (facetable.getScale() != null && facetable.getScale() !== 0) {
            facetableElement.attribute(SCALE, facetable.getScale());
        }
    }

    /**
     * Serializes ComplexTypes
     *
     * @param {*} schemaElement
     * @param {*} complexTypes
     * @private
     */
    _serializeComplexTypes(schemaElement, complexTypes) {
        try {
            for (const complexType of complexTypes) {
                const complexTypeElement = schemaElement.element(COMPLEX_TYPE)
                    .attribute(NAME, complexType.getName());

                if (complexType.getBaseType()) {
                    complexTypeElement.attribute(BASE_TYPE,
                        this._getAliasedFQN(complexType.getBaseType().getFullQualifiedName()));
                }

                if (complexType.isAbstract()) {
                    complexTypeElement.attribute(ABSTRACT, true);
                }

                this._serializeProperties(complexTypeElement, complexType);

                this._serializeNavigationProperties(complexTypeElement, complexType);

                this._serializeAnnotations(complexTypeElement, complexType);
            }
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Complex Type', e);
        }
    }

    /**
     * Serializes Entity Types
     *
     * @param {*} schemaElement
     * @param {*} entityTypes
     * @private
     */
    _serializeEntityTypes(schemaElement, entityTypes) {
        try {
            for (const entityType of entityTypes) {
                const entityTypeElement = schemaElement.element(ENTITY_TYPE)
                    .attribute(NAME, entityType.getName());

                if (entityType.hasStream()) {
                    entityTypeElement.attribute(HAS_STREAM, entityType.hasStream());
                }

                if (entityType.getBaseType()) {
                    entityTypeElement.attribute(
                        BASE_TYPE,
                        this._getAliasedFQN(entityType.getBaseType().getFullQualifiedName()));
                }

                if (entityType.isAbstract()) {
                    entityTypeElement.attribute(ABSTRACT, true);
                }

                this._serializeKey(entityTypeElement, entityType);

                this._serializeProperties(entityTypeElement, entityType);

                this._serializeNavigationProperties(entityTypeElement, entityType);

                this._serializeAnnotations(entityTypeElement, entityType);
            }
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Entity Type', e);
        }
    }

    /**
     * Serializes Navigation properties
     *
     * @param {*} typeElement
     * @param {*} type
     * @private
     */
    _serializeNavigationProperties(typeElement, type) {
        try {
            for (const [navigationPropertyName, navigationProperty] of type.getOwnNavigationProperties()) {
                const navPropertyElement = typeElement.element(NAVIGATION_PROPERTY)
                    .attribute(NAME, navigationPropertyName)
                    .attribute(TYPE,
                        this._getAliasedFQN(
                            navigationProperty.getEntityType().getFullQualifiedName(),
                            navigationProperty.isCollection()));

                if (!navigationProperty.isNullable()) {
                    navPropertyElement.attribute(NULLABLE, navigationProperty.isNullable());
                }

                const partner = navigationProperty.getPartner();
                if (partner) {
                    navPropertyElement.attribute(PARTNER, partner.getName());
                }

                if (navigationProperty.containsTarget()) {
                    navPropertyElement.attribute(CONTAINS_TARGET, navigationProperty.containsTarget());
                }

                const refConstraints = navigationProperty.getReferentialConstraints();
                if (refConstraints) {
                    this._serializeReferentialConstraints(navPropertyElement, refConstraints);
                }

                this._serializeAnnotations(navPropertyElement, navigationProperty);
            }
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Navigation Property', e);
        }
    }

    /**
     * Serializes referential constraints for the NavigationProperty element.
     *
     * @param {*} navPropertyElement
     * @param {*} refConstraints
     * @private
     */
    _serializeReferentialConstraints(navPropertyElement, refConstraints) {
        try {
            for (const refConstraint of refConstraints.values()) {
                const refConstraintElement = navPropertyElement.element(REFERENTIAL_CONSTRAINT)
                    .attribute(PROPERTY, refConstraint.getPropertyName())
                    .attribute(REFERENCED_PROPERTY, refConstraint.getReferencedPropertyName());

                this._serializeAnnotations(refConstraintElement, refConstraint);
            }
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Referential Constraint', e);
        }
    }

    /**
     * Serializes Properties
     *
     * @param {*} typeElement
     * @param {*} type
     * @private
     */
    _serializeProperties(typeElement, type) {
        try {
            for (const [propertyName, property] of type.getOwnProperties()) {
                const propertyElement = typeElement.element(PROPERTY)
                    .attribute(NAME, propertyName)
                    .attribute(TYPE,
                        this._getAliasedFQN(property.getType().getFullQualifiedName(), property.isCollection()));

                // Facets
                this._serializeFacets(propertyElement, property);
                if (!property.isUnicode()) {
                    propertyElement.attribute(UNICODE, property.isUnicode());
                }
                if (property.getDefaultValue()) {
                    propertyElement.attribute(DEFAULT_VALUE, property.getDefaultValue());
                }

                this._serializeAnnotations(propertyElement, property);
            }
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Property', e);
        }
    }

    /**
     * Serializes Entity Type key
     *
     * @param {*} entityTypeElement
     * @param {*} entityType
     * @private
     */
    _serializeKey(entityTypeElement, entityType) {
        try {
            const keyPropertyRefs = entityType.getKeyPropertyRefs();
            if (!keyPropertyRefs || keyPropertyRefs.size === 0) return;

            // Resolve Base Type key as it is shown in derived type
            const baseType = entityType.getBaseType();
            if (baseType && baseType.getKeyPropertyRefs() && (baseType.getKeyPropertyRefs().size !== 0)) {
                return;
            }

            const keyElement = entityTypeElement.element(KEY);
            for (const keyRef of keyPropertyRefs.values()) {
                const propertyRefElement = keyElement.element(PROPERTY_REF)
                    .attribute(NAME, keyRef.getName());

                if (keyRef.getAlias()) {
                    propertyRefElement.attribute(ALIAS, keyRef.getAlias());
                }
            }
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Entity Type Key', e);
        }
    }

    /**
     * Returns string, representing aliased full qualified name for the specified FullQualifiedName instance
     *
     * @param {FullQualifiedName} fqn - FullQualifiedName instance
     * @param {boolean} isCollection - indicates, whether the type is used for a collection elements
     * @returns {string} aliased full qualified name
     *
     * @private
     */
    _getAliasedFQN(fqn, isCollection) {
        const typeName =
            (this._namespaceToAlias.has(fqn.namespace) ? this._namespaceToAlias.get(fqn.namespace) : fqn.namespace)
            + '.' + fqn.name;
        return isCollection ? COLLECTION + '(' + typeName + ')' : typeName;
    }

    /**
     * Serializes References
     *
     * @param {*} edmx
     * @private
     */
    _serializeReferences(edmx) {
        try {
            for (const reference of this._edm.getReferences().values()) {
                const referenceElement = edmx.element(PREFIX_EDMX + ':' + REFERENCE)
                    .attribute(URI, reference.getUri());

                this._serializeIncludes(referenceElement, reference.getIncludes());
                this._serializeIncludeAnnotations(referenceElement, reference.getIncludeAnnotations());

                this._serializeAnnotations(referenceElement, reference);
            }
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Reference', e);
        }
    }

    /**
     * Serializes Include elements
     *
     * @param {*} referenceElement
     * @param {*} includes
     *
     * @private
     */
    _serializeIncludes(referenceElement, includes) {
        try {
            for (const include of includes) {
                const includeElement = referenceElement.element(PREFIX_EDMX + ':' + INCLUDE)
                    .attribute(NAMESPACE, include.getNamespace());

                if (include.getAlias()) {
                    this._namespaceToAlias.set(include.getNamespace(), include.getAlias());
                    // Reference Aliases are ignored for now since they are not V2 compatible
                    includeElement.attribute(ALIAS, include.getAlias());
                }
            }
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Include element', e);
        }
    }

    /**
     * Serializes IncludeAnnotation elements
     *
     * @param {*} referenceElement
     * @param {*} includeAnnotations
     * @private
     */
    _serializeIncludeAnnotations(referenceElement, includeAnnotations) {
        try {
            for (const includeAnnotation of includeAnnotations) {
                const includeAnnotationsElement = referenceElement.element(PREFIX_EDMX + ':' + INCLUDE_ANNOTATIONS)
                    .attribute(TERM_NAMESPACE, includeAnnotation.getTermNamespace());

                if (includeAnnotation.getQualifier()) {
                    includeAnnotationsElement.attribute(QUALIFIER, includeAnnotation.getQualifier());
                }
                if (includeAnnotation.getTargetNamespace()) {
                    includeAnnotationsElement.attribute(TARGET_NAMESPACE, includeAnnotation.getTargetNamespace());
                }
            }
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of IncludeAnnotations element', e);
        }
    }

    /**
     * Serializes Term elements.
     *
     * @param {*} schemaElement
     * @param {Array} terms
     * @private
     */
    _serializeTerms(schemaElement, terms) {
        try {
            for (const term of terms) {

                if (term.getType() == null) {
                    throw new SerializationError(`Type of '${term.getName()}' is not defined`);
                }

                const termElement = schemaElement.element(TERM)
                    .attribute(NAME, term.getName())
                    .attribute(TYPE, this._getAliasedFQN(term.getType().getFullQualifiedName(), term.isCollection()));

                if (term.getBaseTerm()) {
                    termElement.attribute(BASE_TERM, this._getAliasedFQN(term.getBaseTerm().getFullQualifiedName()));
                }

                const appliesTo = term.getAppliesTo();
                if (appliesTo && appliesTo.length > 0) {
                    termElement.attribute(APPLIES_TO, appliesTo.join(' '));
                }

                this._serializeFacets(termElement, term);

                if (term.getDefaultValue()) {
                    const defaultValue = this._convertDefaultValue(term);
                    termElement.attribute(DEFAULT_VALUE, defaultValue);
                }

                this._serializeAnnotations(termElement, term);
            }
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Term', e);
        }
    }

    /**
     * Converts default value to the OData-specific format.
     *
     * @param {EdmProperty | EdmTerm} valueContainer - EDM object, which contains the default value.
     * @returns {*} converted default value
     * @private
     */
    _convertDefaultValue(valueContainer) {
        const typeKind = valueContainer.getType().getKind();

        switch (typeKind) {
            case EdmTypeKind.PRIMITIVE:
            case EdmTypeKind.DEFINITION:
                return this._valueConverter.convert(valueContainer, valueContainer.getDefaultValue());
            case EdmTypeKind.ENUM:
                return this._convertEnumValue(
                    this._getAliasedFQN(valueContainer.getType().getFullQualifiedName()),
                    valueContainer.getDefaultValue());
            default:
                throw new SerializationError(
                    `Serialization of default values of ${typeKind} type kind is not supported`);
        }
    }

    /**
     * Converts a value of an enumeration type to the OData-specific format for XML output.
     * @param {string} typeName
     * @param {string} value
     * @returns {string} converted value
     * @private
     */
    _convertEnumValue(typeName, value) {
        if (!typeName) throw new SerializationError(`No type provided for enum value '${value}'`);
        return value.split(',').map(name => typeName + '/' + name).join(' ');
    }

    /**
     * Serializes Annotations elements.
     *
     * @param {Object} schemaElement - XML element for the EDM Schema
     * @param {EdmAnnotations[]} externalAnnotations - values for Annotations elements
     * @private
     */
    _serializeExternalAnnotations(schemaElement, externalAnnotations) {
        if (!externalAnnotations) return;

        try {
            for (const annotations of externalAnnotations) {
                const annotationsElement = schemaElement.element(ANNOTATIONS)
                    .attribute(TARGET, annotations.getTarget());

                const qualifier = annotations.getQualifier();
                if (qualifier) {
                    annotationsElement.attribute(QUALIFIER, qualifier);
                }

                this._serializeAnnotations(annotationsElement, annotations);
            }
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Annotations element', e);
        }
    }

    /**
     * Serializes annotations for an EDM element.
     *
     * @param {Object} annotatableElement - XML element for the EDM element, for which the annotations have to be
     * serialized
     * @param {Object} annotatable - EDM object, containing the annotations, e.g. EdmProperty
     * @private
     */
    _serializeAnnotations(annotatableElement, annotatable) {
        const annotations = annotatable.getAnnotations();

        if (!annotations) return;

        try {
            for (const annotation of annotations) {
                const annotationElement = annotatableElement.element(ANNOTATION)
                    .attribute(TERM, this._getAliasedFQN(annotation.getTermFullQualifiedName()));

                if (annotation.getQualifier()) {
                    annotationElement.attribute(QUALIFIER, annotation.getQualifier());
                }

                this._serializeAnnotations(annotationElement, annotation);

                this._serializeExpression(annotationElement, annotation.getExpression(),
                    annotation.getTerm() ? annotation.getTerm().getType() : null);
            }
        } catch (e) {
            let reason = '';
            if (annotatable.getTarget) {
                reason = ` with target '${annotatable.getTarget()}'`;
            }
            throw new SerializationError('An error occurred during serialization of annotation' + reason, e);
        }
    }

    /**
     * Dispatcher method for serialization of annotation expressions.
     *
     * @param {Object} parentElement - XML element, to which the annotations have to be added
     * @param {Object} expression - instance of an EDM annotation expression, e.g. EdmApplyExpression
     * @param {?EdmType} annotatedType the type of the element (term, property, ...) that is annotated
     * @private
     */
    _serializeExpression(parentElement, expression, annotatedType) {
        if (!expression) return;

        const exprSerializer = EXPRESSION_SERIALIZERS[expression.getKind()];
        if (!exprSerializer) {
            throw new NotImplementedError(`'${expression.getKind()}' annotation expressions are not supported`);
        }

        this[exprSerializer](parentElement, expression, annotatedType);
    }

    _serializeConstantExpr(parentElement, constantExpr, annotatedType) {
        try {
            const exprType = constantExpr.getTypeName();
            const exprValue = exprType === 'edm:EnumMember' ?
                // The XML-serialized enumeration-type value needs the full-qualified type name.
                // This can be found in the annotated type. If that is not available
                // (e.g., because it is in a referenced schema), an '@odata.type' annotation
                // as specified in OData Version 4.01 CS02 is used (and required in that case).
                this._convertEnumValue(
                    annotatedType ?
                        this._getAliasedFQN(annotatedType.getFullQualifiedName()) :
                        constantExpr.getAnnotations()
                            .find(annotation => annotation.getTermFullQualifiedName().toString() === 'odata.type')
                            .getExpression().getValue().substr(1),
                    constantExpr.getValue()) :
                this._convertConstantExprValue(exprType, constantExpr.getValue());

            // expression name is the type name without 'edm:' prefix, i.e. starting with the 4th character
            const exprName = exprType.substring(4);

            parentElement.element(exprName)
                .text(exprValue);
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of constant annotation expression', e);
        }
    }

    _convertConstantExprValue(typeName, value) {
        const convertMethod = CONSTANT_CONVERTERS[typeName];
        if (!convertMethod) {
            throw new SerializationError(`Serialization of constant expressions of ${typeName} type is not supported`);
        }

        return this._valueConverter[convertMethod](value);
    }

    _serializeAnnotationPathExpr(parentElement, expression) {
        parentElement.element(ANNOTATION_PATH)
            .text(expression.getAnnotationPath());
    }

    _serializeApplyExpr(parentElement, applyExpr, annotatedType) {
        try {
            const applyElement = parentElement.element(APPLY)
                .attribute(FUNCTION, this._getAliasedFQN(applyExpr.getFunctionName()));

            for (const parameterExpr of applyExpr.getParameters()) {
                this._serializeExpression(applyElement, parameterExpr, annotatedType);
            }

            this._serializeAnnotations(applyElement, applyExpr);
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Apply annotation expression', e);
        }
    }

    _serializeCastExpr(parentElement, castExpr, annotatedType) {
        try {
            const castElement = parentElement.element(CAST)
                .attribute(TYPE,
                    this._getAliasedFQN(castExpr.getType().getFullQualifiedName(), castExpr.isCollection()));

            this._serializeFacets(castElement, castExpr);
            this._serializeExpression(castElement, castExpr.getExpression(), annotatedType);

            this._serializeAnnotations(castElement, castExpr);
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Cast annotation expression', e);
        }
    }

    _serializeCollectionExpr(parentElement, collectionExpr, annotatedType) {
        try {
            const collectionElement = parentElement.element(COLLECTION);

            for (const expression of collectionExpr.getExpressions()) {
                this._serializeExpression(collectionElement, expression, annotatedType);
            }
        } catch (e) {
            throw new SerializationError(
                'An error occurred during serialization of Collection annotation expression', e);
        }
    }

    _serializeIfExpr(parentElement, ifExpr, annotatedType) {
        try {
            const ifElement = parentElement.element(IF);

            this._serializeExpression(ifElement, ifExpr.getCondition(), annotatedType);
            this._serializeExpression(ifElement, ifExpr.getIfTrue(), annotatedType);
            this._serializeExpression(ifElement, ifExpr.getIfFalse(), annotatedType);

            this._serializeAnnotations(ifElement, ifExpr);
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of If annotation expression', e);
        }
    }

    _serializeArithmeticExpr(parentElement, arithmeticExpr, annotatedType) {
        try {
            const exprElement = parentElement.element(arithmeticExpr.getOperator());

            this._serializeExpression(exprElement, arithmeticExpr.getLeft(), annotatedType);
            this._serializeExpression(exprElement, arithmeticExpr.getRight(), annotatedType);

            this._serializeAnnotations(exprElement, arithmeticExpr);
        } catch (e) {
            throw new SerializationError(
                'An error occurred during serialization of arithmetic annotation expression', e);
        }
    }

    _serializeBinaryExpr(parentElement, binaryExpr, annotatedType) {
        try {
            const exprElement = parentElement.element(binaryExpr.getOperator());

            this._serializeExpression(exprElement, binaryExpr.getLeft(), annotatedType);
            this._serializeExpression(exprElement, binaryExpr.getRight(), annotatedType);

            this._serializeAnnotations(exprElement, binaryExpr);
        } catch (e) {
            throw new SerializationError(
                'An error occurred during serialization of binary logical / comparison annotation expression', e);
        }
    }

    _serializeIsOfExpr(parentElement, isOfExpr, annotatedType) {
        try {
            const isOfElement = parentElement.element(IS_OF)
                .attribute(TYPE,
                    this._getAliasedFQN(isOfExpr.getType().getFullQualifiedName(), isOfExpr.isCollection()));
            this._serializeFacets(isOfElement, isOfExpr);

            this._serializeExpression(isOfElement, isOfExpr.getExpression(), annotatedType);

            this._serializeAnnotations(isOfElement, isOfExpr);
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of IsOf annotation expression', e);
        }
    }

    _serializeLabeledElementExpr(parentElement, labeledElementExpr, annotatedType) {
        try {
            const labeledElementElement = parentElement.element(LABELED_ELEMENT)
                .attribute(NAME, labeledElementExpr.getName());
            this._serializeExpression(labeledElementElement, labeledElementExpr.getExpression(), annotatedType);

            this._serializeAnnotations(labeledElementElement, labeledElementExpr);
        } catch (e) {
            throw new SerializationError(
                'An error occurred during serialization of LabeledElement annotation expression', e);
        }
    }

    _serializeLabeledElementReferenceExpr(parentElement, labeledElemRefExpr) {
        try {
            parentElement.element(LABELED_ELEMENT_REFERENCE)
                .text(this._getAliasedFQN(labeledElemRefExpr.getName()));
        } catch (e) {
            throw new SerializationError(
                'An error occurred during serialization of LabeledElementReference annotation expression', e);
        }
    }

    _serializeModelElementPathExpr(parentElement, modelElementPathExpr) {
        try {
            parentElement.element(MODEL_ELEMENT_PATH)
                .text(modelElementPathExpr.getModelElementPath());
        } catch (e) {
            throw new SerializationError(
                'An error occurred during serialization of ModelElementPath annotation expression', e);
        }
    }

    _serializeNullExpr(parentElement, nullExpr) {
        try {
            const nullElement = parentElement.element(NULL);
            this._serializeAnnotations(nullElement, nullExpr);
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Null annotation expression', e);
        }
    }

    _serializeNavigationPropertyPathExpr(parentElement, navPropPathExpr) {
        try {
            parentElement.element(NAVIGATION_PROPERTY_PATH)
                .text(navPropPathExpr.getNavigationPropertyPath());
        } catch (e) {
            throw new SerializationError(
                'An error occurred during serialization of NavigationPropertyPath annotation expression', e);
        }
    }

    _serializePathExpr(parentElement, pathExpr) {
        try {
            parentElement.element(PATH)
                .text(pathExpr.getPath());
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Path annotation expression', e);
        }
    }

    _serializePropertyPathExpr(parentElement, propertyPathExpr) {
        try {
            parentElement.element(PROPERTY_PATH)
                .text(propertyPathExpr.getPropertyPath());
        } catch (e) {
            throw new SerializationError(
                'An error occurred during serialization of PropertyPath annotation expression', e);
        }
    }

    _serializeNegationExpr(parentElement, negationExpr, annotatedType) {
        try {
            const negationElement = parentElement.element(NEG);
            this._serializeExpression(negationElement, negationExpr.getExpression(), annotatedType);

            this._serializeAnnotations(negationElement, negationExpr);
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Negation annotation expression', e);
        }
    }

    _serializeNotExpr(parentElement, notExpr, annotatedType) {
        try {
            const notElement = parentElement.element(NOT);
            this._serializeExpression(notElement, notExpr.getExpression(), annotatedType);

            this._serializeAnnotations(notElement, notExpr);
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Not annotation expression', e);
        }
    }

    _serializeRecordExpr(parentElement, recordExpr, annotatedType) {
        try {
            const recordElement = parentElement.element(RECORD);

            const recordTypeFQN = recordExpr.getTypeFQN();
            if (recordTypeFQN) {
                recordElement.attribute(TYPE, this._getAliasedFQN(recordTypeFQN));
            }

            for (const propValueExpr of recordExpr.getPropertyValues()) {
                let type = null;
                if (annotatedType && annotatedType.getProperty) {
                    const property = annotatedType.getProperty(propValueExpr.getProperty());
                    if (property && property.getType != null) type = property.getType();
                    if (property && property.getEntityType != null) type = property.getEntityType();
                }
                this._serializePropertyValueExpr(recordElement, propValueExpr, type);
            }

            this._serializeAnnotations(recordElement, recordExpr);
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of Record annotation expression', e);
        }
    }

    _serializePropertyValueExpr(recordElement, propValueExpr, annotatedType) {
        try {
            const propValueElement = recordElement.element(PROPERTY_VALUE)
                .attribute(PROPERTY, propValueExpr.getProperty());

            this._serializeExpression(propValueElement, propValueExpr.getExpression(), annotatedType);

            this._serializeAnnotations(propValueElement, propValueExpr);
        } catch (e) {
            throw new SerializationError(
                'An error occurred during serialization of PropertyValue annotation expression', e);
        }
    }

    _serializeUrlRefExpr(parentElement, urlRefExpr, annotatedType) {
        try {
            const urlRefElement = parentElement.element(URL_REF);
            this._serializeExpression(urlRefElement, urlRefExpr.getExpression(), annotatedType);

            this._serializeAnnotations(urlRefElement, urlRefExpr);
        } catch (e) {
            throw new SerializationError('An error occurred during serialization of UrlRef annotation expression', e);
        }
    }
}

module.exports = MetadataXmlSerializer;
