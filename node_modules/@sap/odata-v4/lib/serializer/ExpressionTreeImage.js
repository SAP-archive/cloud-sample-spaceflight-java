'use strict';

const moduleCache = require('../ModuleCache');
const ExpressionKind = require('../uri/Expression').ExpressionKind;

const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
const SVG_PREFIX = 'svg:';

const X_UNIT = 100;
const Y_UNIT = 55;
const X_BOX = 85;
const Y_BOX = 35;
const Y_OFF = 8;
const FONT_SIZE = 13;
const CHAR_WIDTH = 9;

const COLOR_ROOT = 'rgb(220,220,220)';  // 'goldenrod'
const COLOR_ALIAS = 'rgb(180,180,180)';  // 'sienna'
const COLOR_BINARY = 'rgb(160,160,160)';  // cornflowerblue'
const COLOR_LITERAL = 'rgb(60,60,60)';  // 'green'
const COLOR_MEMBER = 'rgb(80,80,80)';  // 'purple'
const COLOR_METHOD = 'rgb(100,100,100)';  // 'firebrick'
const COLOR_TYPE_LITERAL = 'rgb(120,120,120)';  // 'darkturquoise'
const COLOR_UNARY = 'rgb(140,140,140)';  // 'slateblue'
const COLOR_DEFAULT = 'gray';

/**
 * SVG image of an expression tree.
 */
class ExpressionTreeImage {

    constructor() {
        this.xmlbuilder = moduleCache.lookup('xmlbuilder');
    }

    /**
     * Create a graphical tree representation of an expression as an SVG image.
     * @param {Expression} expression
     * @param {string} title
     * @returns {string} the graphical representation of the expression tree as an SVG image
     */
    toImage(expression, title = 'root') {
        if (!expression) return null;

        const depth = this._getDepth(expression);
        const width = this._getWidth(expression);
        const offset = this._getOffset(expression);

        let xml = this.xmlbuilder.create(SVG_PREFIX + 'svg')
            .attribute('xmlns:' + SVG_PREFIX.substr(0, SVG_PREFIX.length - 1), SVG_NAMESPACE)
            .attribute('version', '1.1')
            .attribute('width', width * X_UNIT)
            .attribute('height', depth * Y_UNIT + Y_BOX)
            .attribute('viewBox', '0 0 ' + width * X_UNIT + ' ' + (depth * Y_UNIT + Y_BOX))
            .attribute('preserveAspectRatio', 'xMinYMin');
        let gNode = xml.element(SVG_PREFIX + 'g')
            .attribute('font-family', 'Liberation Sans,Arial,Helvetica,sans-serif')
            .attribute('text-anchor', 'middle');
        gNode.element(SVG_PREFIX + 'ellipse')
            .attribute('cx', offset * X_UNIT + (X_UNIT >> 1))
            .attribute('cy', (Y_UNIT - Y_OFF) >> 1)
            .attribute('rx', X_BOX >> 1)
            .attribute('ry', (Y_UNIT - Y_OFF) >> 1)
            .attribute('stroke', 'black')
            .attribute('stroke-width', '0.5')
            .attribute('fill', COLOR_ROOT);
        this._writeText(gNode,
            offset * X_UNIT + (X_UNIT >> 1),
            (Y_UNIT - Y_OFF + FONT_SIZE * 14 / 10) >> 1,
            FONT_SIZE * 14 / 10,
            title);
        this._writeExpression(gNode, expression, offset * X_UNIT + (X_UNIT >> 1), 1);

        return xml.end({ pretty: true, indent: '  ', newline: '\n' });
    }

    /**
     * Determine the depth required by an expression.
     * @param {Expression|UriResource} expression
     * @returns {number} number of Y_UNITs required by the expression
     * @private
     */
    _getDepth(expression) {
        let depth = 0;
        switch (expression.getKind()) {
            case ExpressionKind.UNARY:
                depth = this._getDepth(expression.getOperand());
                break;

            case ExpressionKind.BINARY:
                depth = Math.max(this._getDepth(expression.getLeftOperand()),
                    this._getDepth(expression.getRightOperand()));
                break;

            case ExpressionKind.METHOD:
                depth = expression.getParameters().reduce((m, p) => Math.max(m, this._getDepth(p)), 0);
                break;

            case ExpressionKind.MEMBER:
                depth = expression.getPathSegments().reduce((s, p) => s + this._getDepth(p), 0);
                break;

            case ExpressionKind.ALIAS:
                depth = this._getDepth(expression.getExpression());
                break;

            default:
        }
        return depth + 1;
    }

    /**
     * Determine the width required by an expression.
     * @param {Expression} expression
     * @returns {number} number of X_UNITs required by the expression
     * @private
     */
    _getWidth(expression) {
        let width = 0;
        switch (expression.getKind()) {
            case ExpressionKind.UNARY:
                width = this._getWidth(expression.getOperand());
                break;

            case ExpressionKind.BINARY:
                width = this._getWidth(expression.getLeftOperand())
                    + this._getWidth(expression.getRightOperand())
                    + 1;
                break;

            case ExpressionKind.METHOD:
                width = expression.getParameters().reduce((s, p) => s + this._getWidth(p), 0);
                break;

            case ExpressionKind.MEMBER:
                width = expression.getPathSegments().reduce(
                    (m, p) => Math.max(m, this._getResourceWidth(p)), 0);
                break;

            case ExpressionKind.ALIAS:
                width = this._getWidth(expression.getExpression());
                break;

            case ExpressionKind.LITERAL:
                width = (expression.getText() || 'null').length * CHAR_WIDTH / X_UNIT;
                break;

            default:
        }
        return Math.ceil(expression.getType() === undefined ?
            width :
            Math.max(width,
                (expression.getType() === null ? 'null' : expression.getType().getFullQualifiedName().toString())
                    .length * CHAR_WIDTH * 8 / 10 / X_UNIT));
    }

    /**
     * Determine the width required by a resource's name and type name.
     * @param {UriResource} resource
     * @returns {number} number of X_UNITs required by the resource
     * @private
     */
    _getResourceWidth(resource) {
        const width = resource.getPathSegmentIdentifier().length * CHAR_WIDTH / X_UNIT;
        return Math.ceil(Math.max(width,
            (resource.getEdmType() === null ? 'null' : resource.getEdmType().getFullQualifiedName().toString()).length
                * CHAR_WIDTH * 8 / 10 / X_UNIT));
    }

    /**
     * Determine the offset required for an expression.
     * @param {Expression} expression
     * @returns {number} number of X_UNITs required by the expression
     * @private
     */
    _getOffset(expression) {
        switch (expression.getKind()) {
            case ExpressionKind.UNARY:
                return this._getOffset(expression.getOperand());

            case ExpressionKind.BINARY:
                return this._getWidth(expression.getLeftOperand());

            case ExpressionKind.METHOD:
                if (expression.getParameters().length === 0) return 0;
                return expression.getParameters().length > 1 ?
                    (this._getWidth(expression.getParameters()[0])
                    + (this._getWidth(expression.getParameters()[1]) - 1) / 2) :
                    (this._getWidth(expression.getParameters()[0]) - 1) / 2;

            default:
                return (this._getWidth(expression) - 1) / 2;
        }
    }

    /**
     * Write an expression.
     * @param {xmlbuilder} xml
     * @param {Expression|UriResource} expression
     * @param {number} position horizontal position as number of X_UNITs
     * @param {number} row vertical position as number of Y_UNITs
     * @private
     */
    _writeExpression(xml, expression, position, row) {
        let offset = 0;
        let type = null;
        let text = '';
        let kindText = '';
        let color = COLOR_DEFAULT;
        switch (expression.getKind()) {
            case ExpressionKind.UNARY:
                this._writeContinuationLine(xml, position, row);
                this._writeExpression(xml, expression.getOperand(), position, row + 1);
                type = expression.getType();
                text = expression.getOperator();
                kindText = 'Unary';
                color = COLOR_UNARY;
                break;

            case ExpressionKind.BINARY:
                this._writeContinuationLine(xml, position, row);
                offset = (this._getWidth(expression.getLeftOperand())
                    - this._getOffset(expression.getLeftOperand())) * X_UNIT;
                this._writeExpression(xml, expression.getLeftOperand(), position - offset, row + 1);
                this._writeLine(xml,
                    position - offset, (row + 1) * Y_UNIT - Y_OFF,
                    position, (row + 1) * Y_UNIT - Y_OFF);
                offset = (this._getOffset(expression.getRightOperand()) + 1) * X_UNIT;
                this._writeExpression(xml, expression.getRightOperand(), position + offset, row + 1);
                this._writeLine(xml,
                    position, (row + 1) * Y_UNIT - Y_OFF,
                    position + offset, (row + 1) * Y_UNIT - Y_OFF);
                type = expression.getType();
                text = expression.getOperator();
                kindText = 'Binary';
                color = COLOR_BINARY;
                break;

            case ExpressionKind.METHOD: {
                const count = expression.getParameters().length;
                offset = count > 1 ?
                    (this._getWidth(expression.getParameters()[0])
                    - this._getOffset(expression.getParameters()[0])
                    + this._getOffset(expression.getParameters()[1])) * X_UNIT : 0;
                if (count > 0) {
                    this._writeContinuationLine(xml, position, row);
                    this._writeExpression(xml, expression.getParameters()[0], position - offset, row + 1);
                }
                const lineY2 = (row + 1) * Y_UNIT - Y_OFF;
                if (offset > 0) this._writeLine(xml, position, row * Y_UNIT + Y_BOX, position - offset, lineY2);
                if (count > 1) this._writeExpression(xml, expression.getParameters()[1], position, row + 1);
                if (count > 2) {
                    offset = (this._getWidth(expression.getParameters()[1])
                        - this._getOffset(expression.getParameters()[1])
                        + this._getOffset(expression.getParameters()[2])) * X_UNIT;
                    this._writeExpression(xml, expression.getParameters()[2], position + offset, row + 1);
                    this._writeLine(xml, position, row * Y_UNIT + Y_BOX, position + offset, lineY2);
                }
                type = expression.getType();
                text = expression.getMethod();
                kindText = 'Method';
                color = COLOR_METHOD;
                break;
            }

            case ExpressionKind.MEMBER: {
                let depth = expression.getPathSegments().length - 1;
                for (const resource of expression.getPathSegments()) {
                    this._writeContinuationLine(xml, position, row + depth);
                    this._writeExpression(xml, resource, position, row + depth + 1);
                    depth--;
                }
                type = expression.getType();
                kindText = 'Member';
                color = COLOR_MEMBER;
                break;
            }

            case ExpressionKind.LITERAL:
                type = expression.getType();
                text = expression.getText() || 'null';
                kindText = 'Literal';
                color = COLOR_LITERAL;
                break;

            case ExpressionKind.TYPE_LITERAL:
                type = expression.getType();
                kindText = 'Type';
                color = COLOR_TYPE_LITERAL;
                break;

            case ExpressionKind.ALIAS:
                this._writeContinuationLine(xml, position, row);
                this._writeExpression(xml, expression.getExpression(), position, row + 1);
                type = expression.getType();
                text = expression.getAlias();
                kindText = 'Alias';
                color = COLOR_ALIAS;
                break;

            default:
                type = expression.getEdmType();
                text = expression.getPathSegmentIdentifier();
                kindText = expression.getKind();
                color = COLOR_DEFAULT;
                break;
        }

        this._writeLine(xml, position, row * Y_UNIT, position, row * Y_UNIT - Y_OFF);
        let typeText = type === null ? 'null' : '';
        if (type) typeText = type.getFullQualifiedName().toString();
        const width = Math.ceil(Math.max(X_BOX, typeText.length * CHAR_WIDTH * 8 / 10, text.length * CHAR_WIDTH));
        xml.element(SVG_PREFIX + 'rect')
            .attribute('x', position - (width >> 1))
            .attribute('y', row * Y_UNIT)
            .attribute('width', width)
            .attribute('height', Y_BOX)
            .attribute('stroke', 'black')
            .attribute('stroke-width', '0.5')
            .attribute('fill', color);
        let gNode = xml.element(SVG_PREFIX + 'g').attribute('stroke', 'white').attribute('fill', 'white');
        this._writeText(gNode, position, row * Y_UNIT + (Y_BOX >> 1), FONT_SIZE, text);
        this._writeText(gNode, position, row * Y_UNIT + (Y_BOX >> 1) + FONT_SIZE, FONT_SIZE * 8 / 10, typeText);
        let textNode = xml.element(SVG_PREFIX + 'g').attribute('text-anchor', 'start');
        this._writeText(textNode, position - (width >> 1), row * Y_UNIT, FONT_SIZE * 6 / 10, kindText);
    }

    /**
     * Write a continuation line.
     * @param {xmlbuilder} xml
     * @param {number} position horizontal position as number of X_UNITs
     * @param {number} row vertical position as number of Y_UNITs
     * @private
     */
    _writeContinuationLine(xml, position, row) {
        this._writeLine(xml, position, row * Y_UNIT + Y_BOX, position, (row + 1) * Y_UNIT - Y_OFF);
    }

    /**
     * Write text.
     * @param {xmlbuilder} xml
     * @param {number} x horizontal position as coordinate
     * @param {number} y vertical position as coordinate
     * @param {number} size text size in coordinate-system units
     * @param {string} text
     * @private
     */
    _writeText(xml, x, y, size, text) {
        xml.element(SVG_PREFIX + 'text')
            .attribute('x', x)
            .attribute('y', y)
            .attribute('font-size', size)
            .text(text);
    }

    /**
     * Write a line.
     * @param {xmlbuilder} xml
     * @param {number} x1 horizontal start position as coordinate
     * @param {number} y1 vertical start position as coordinate
     * @param {number} x2 horizontal end position as coordinate
     * @param {number} y2 vertical end position as coordinate
     * @private
     */
    _writeLine(xml, x1, y1, x2, y2) {
        xml.element(SVG_PREFIX + 'line')
            .attribute('x1', x1)
            .attribute('y1', y1)
            .attribute('x2', x2)
            .attribute('y2', y2)
            .attribute('stroke', 'black')
            .attribute('stroke-width', '0.5');
    }
}

module.exports = ExpressionTreeImage;
