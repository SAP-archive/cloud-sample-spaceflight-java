'use strict';

const fs = require('fs');
const validateThat = require('../validator/ParameterValidator').validateThat;
const DebugJsonSerializer = require('./DebugJsonSerializer');
const ExpressionTreeImage = require('./ExpressionTreeImage');
const QueryOptions = require('../uri/UriInfo').QueryOptions;

const STACKTRACE_SECTION_REGEXP = new RegExp('\\s+<!-- begin stacktrace -->(?:.|\\n)+<!-- end stacktrace -->');
const PROFILE_SECTION_REGEXP = new RegExp('\\s+<!-- begin profile -->(?:.|\\n)+<!-- end profile -->');
const STACKTRACE_FRAME_REGEXP = new RegExp('(.+?)\\s*\\(((?:/|[A-Za-z]:\\\\|\\\\\\\\).+):(\\d+):\\d+\\)');

class DebugHtmlSerializer {

    /**
     * Creates an instance of the debug view html serializer.
     *
     * @param {Object} context - The OData context
     * @param {string} payload - The response body. It is the result of the previous serializer,
     *  referring either to data (e.g. metadata, service, entity collection, .. etc.)
     *  for successful request, or to an error (any).
     * @param {Error} error If this error parameter is provided the serializer creates
     *  a stacktrace into the output. Otherwise there will be no error stacktrace available
     */
    constructor(context, payload, error) {
        validateThat('context', context).truthy().typeOf('object');

        this._error = error;
        this._context = context;
        this._payload = payload;
    }

    /**
     * Serializes the debug view and returns an HTML representation of the debug view.
     *
     * @returns {string} - HTML representation of the debug view
     */
    serialize() {
        const view = this._buildView();

        const template = fs.readFileSync(__dirname + '/debugview.html', 'utf8');

        // The replacements below use a function instead of a string to avoid special interpretation of "$".
        let result = template
            .replace('{{title}}', () => 'DEBUG - ' + view.request.uri)
            .replace('{{body}}', () => view.body)
            .replace('{{request.uri}}', () => view.request.uri)
            .replace('{{request.method}}', view.request.method)
            .replace('{{request.headers}}', () => view.request.headers)
            .replace('{{request.body}}', () => view.request.body)
            .replace('{{response.headers}}', () => view.response.headers)
            .replace('{{response.dataType}}', view.response.dataType)
            .replace('{{response.status.code}}', view.response.status.code)
            .replace('{{response.status.info}}', view.response.status.info)
            .replace('{{server.environment}}', () => view.server.environment)
            .replace('{{server.stacktrace}}', () => view.server.stacktrace)
            .replace('{{server.version}}', view.server.version)
            .replace('{{context.uriInfo.kind}}', view.context.uriInfo.kind)
            .replace('{{context.uriInfo.pathSegments}}', () => view.context.uriInfo.pathSegments)
            .replace('{{context.uriInfo.queryOptions}}', () => view.context.uriInfo.queryOptions)
            .replace('{{log}}', () => view.log)
            .replace('{{profile}}', () => view.profile);

        if (this._context.getRequest() && this._context.getRequest().getUriInfo()) {
            const uriInfo = this._context.getRequest().getUriInfo();
            const addImage = (html, queryOption) => {
                if (!uriInfo.getQueryOption(queryOption)) return html;
                const image = new ExpressionTreeImage().toImage(uriInfo.getQueryOption(queryOption), queryOption)
                    // Remove XML declaration and XML namespace prefix.
                    .substring('<?xml version="1.0"?>'.length).replace(/svg:|:svg/g, '');
                return html.replace(new RegExp('</div>\\n\\n\\s*<div class="header" id="sec5">'),
                    '        <p>' + image + '</p>\n    $&');
            };
            result = addImage(result, QueryOptions.SEARCH);
            result = addImage(result, QueryOptions.FILTER);
        }

        if (!view.server.stacktrace) result = result.replace(STACKTRACE_SECTION_REGEXP, '');
        if (!view.profile) result = result.replace(PROFILE_SECTION_REGEXP, '');

        return result;
    }

    /**
     * Build the internal view object. This object should have all properties needed for the debug view.
     *
     * @returns {Object} The view object
     * @private
     */
    _buildView() {
        const jsonDebugString = new DebugJsonSerializer(this._context, this._payload, this._error)
            .serialize();

        const jsonDebug = JSON.parse(jsonDebugString);

        const view = {
            title: 'DEBUG - ' + this._escapeHtmlSpecialChars(this._context.getRequest().getOdataPath()),
            request: {
                // We escape some outputs because it can potential contain html values.
                headers: this._convertObjectToHtmlTableRows(jsonDebug.request.headers),
                uri: this._escapeHtmlSpecialChars(jsonDebug.request.uri),
                method: jsonDebug.request.method,
                body: jsonDebug.request.body
            },
            response: {
                headers: this._convertObjectToHtmlTableRows(jsonDebug.response.headers),
                status: jsonDebug.response.status
            },
            context: {
                uriInfo: 'null'
            },
            server: {
                version: jsonDebug.server.version,
                environment: this._convertObjectToHtmlTableRows(jsonDebug.server.environment) + '\n'
                    + this._convertObjectToHtmlTableRows(jsonDebug.server.environment.node) + '\n'
                    + this._convertObjectToHtmlTableRows(jsonDebug.server.environment.process)
            },
            log: '<ul>\n'
                + jsonDebug.log.map(logString => '<li>' + this._escapeHtmlSpecialChars(logString) + '</li>\n').join('')
                + '</ul>'
        };

        if (jsonDebug.context.uriInfo) {
            view.context.uriInfo = {
                pathSegments: JSON.stringify(jsonDebug.context.uriInfo.pathSegments, null, 3),
                kind: jsonDebug.context.uriInfo.kind,
                queryOptions:
                    this._escapeHtmlSpecialChars(JSON.stringify(jsonDebug.context.uriInfo.queryOptions, null, 3))
            };
        }

        if (view.request.body instanceof Object) view.request.body = JSON.stringify(view.request.body, null, 3);
        view.request.body = this._escapeHtmlSpecialChars(view.request.body);

        view.body = jsonDebug.response.body;
        if (view.body instanceof Object) view.body = JSON.stringify(view.body, null, 3);
        view.body = this._escapeHtmlSpecialChars(view.body);

        if (jsonDebug.server.stacktrace) {
            view.server.stacktrace = jsonDebug.server.stacktrace.map(stackElement =>
                stackElement.split('\n').map(frame => {
                    const match = STACKTRACE_FRAME_REGEXP.exec(frame);
                    if (!match) return this._escapeHtmlSpecialChars(frame);
                    try {
                        return this._createHtmlSourceCodeExtract(match[1], match[2], Number(match[3]));
                    } catch (error) {
                        return this._escapeHtmlSpecialChars(frame);
                    }
                }).join('<br>\n')
            ).join('\n<hr>\n');
        }

        if (jsonDebug.profile) {
            view.profile = this._createRuntimeTree('', jsonDebug.profile, '', true);
        }

        return view;
    }

    /**
     * Converts an object to an HTML table row structure.
     * If the input is '{a: 'b', b: 'c'}' output will be
     * '<tr><td class="name">a</td><td class="value">b</td><tr>\n<tr><td class="name">b</td><td class="value">c</td><tr>'
     *
     * @param {Object} target The object to convert
     * @returns {string} The resulting HTML table rows
     * @private
     */
    _convertObjectToHtmlTableRows(target) {
        return Object.keys(target).filter(key => typeof target[key] === 'string').map(key =>
            '<tr><td class="name">' + this._escapeHtmlSpecialChars(key)
            + '</td><td class="value">' + this._escapeHtmlSpecialChars(target[key])
            + '</td></tr>').join('\n');
    }

    /**
     * Escapes HTML characters in the provided string.
     * Escape is done via replacing:
     *      '&' --> '&amp;'
     *      '<' --> '&lt;'
     *      '>' --> '&gt;'
     * Result will be a new string with HTML characters escaped.
     *
     * @param {?string} input The string to escape HTML charaters in.
     * @returns {?string} The escaped string with HTML characters escaped.
     * @private
     */
    _escapeHtmlSpecialChars(input) {
        if (typeof input === 'string') {
            return input
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
        }
        return input;
    }

    /**
     * Create a source-code extract with a highlighted line as HTML.
     * @param {string} introduction introductory text
     * @param {string} filename
     * @param {number} line highlighted line
     * @returns {string} the resulting HTML extract
     * @throws {Error} if the file does not exist
     * @private
     */
    _createHtmlSourceCodeExtract(introduction, filename, line) {
        const source = fs.readFileSync(filename, 'utf8').split('\n');
        return this._escapeHtmlSpecialChars(introduction + ' in ' + filename)
            + '\n<div class="code">\n'
            + source.slice(Math.max(line - 10, 0), Math.min(line + 4, source.length))
                .map((sourceCodeLine, index) =>
                    (index === (line > 10 ? 10 : line) - 1 ? '<span class="error">' : '')
                    + '   '.substr(Math.log10((line > 10 ? line - 10 : 0) + index + 1))
                    + String((line > 10 ? line - 10 : 0) + index + 1) + '  '
                    + this._escapeHtmlSpecialChars(sourceCodeLine)
                    + (index === (line > 10 ? 10 : line) - 1 ? '</span>' : ''))
                .join('\n')
            + '\n</div>';
    }

    /**
     * Create an HTML representation of a runtime-information (sub-)tree.
     * @param {string} name
     * @param {Object} node
     * @param {string} draw
     * @param {boolean} isLast
     * @returns {string} the resulting HTML representation
     * @private
     */
    _createRuntimeTree(name, node, draw, isLast) {
        const elementNames =
            ['$Milliseconds', 'Memory usage on start (MB)', 'Memory usage on stop (MB)', 'CPU usage in milliseconds'];
        const elements = elementNames.slice(1)
            .filter(elementName => node[elementName])
            .map(elementName => elementName + ': '
                + Object.keys(node[elementName]).map(subName => subName + ' ' + node[elementName][subName]).join(', '))
            .join('\n');

        let result = '';
        if (!name) result += '<ol class="tree">\n';
        result += '<li>\n' + draw + (isLast ? '&#x2514;' : '&#x251C;') + '&#x2500;&nbsp;'
            + this._escapeHtmlSpecialChars(name || 'Request processing')
            + '<span class="' + (node.$Milliseconds ? 'numeric' : 'null')
            + '" alt=\'' + this._escapeHtmlSpecialChars(elements) + '\'>'
            + (node.$Milliseconds ? Math.round(node.$Milliseconds * 1000) + '&nbsp;&micro;s' : 'unfinished')
            + '</span>\n';
        const childNames = Object.keys(node).filter(childName => !elementNames.includes(childName));
        if (childNames.length) {
            result += '<ol class="tree">\n';
            for (const childName of childNames) {
                result += this._createRuntimeTree(
                    childName,
                    node[childName],
                    draw + (isLast ? '&nbsp;' : '&#x2502;') + '&nbsp;&nbsp;',
                    childNames.indexOf(childName) === childNames.length - 1);
            }
            result += '</ol>\n';
        }
        result += '</li>\n';
        if (!name) result += '</ol>';
        return result;
    }
}

module.exports = DebugHtmlSerializer;
