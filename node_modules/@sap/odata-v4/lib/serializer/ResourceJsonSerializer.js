'use strict';

const validateThat = require('../validator/ParameterValidator').validateThat;
const UriHelper = require('../uri/UriHelper');
const ValueConverter = require('../utils/ValueConverter');
const ValueValidator = require('../validator/ValueValidator');
const JsonContentTypeInfo = require('../format/JsonContentTypeInfo');
const EdmTypeKind = require('../edm/EdmType').TypeKind;
const EdmPrimitiveTypeKind = require('../edm/EdmPrimitiveTypeKind');
const EdmProperty = require('../edm/EdmProperty');
const SerializationError = require('../errors/SerializationError');
const QueryOptions = require('../uri/UriInfo').QueryOptions;
const ResourceKind = require('../uri/UriResource').ResourceKind;
const JsonAnnotations = require('../format/JsonFormat').Annotations;
const MetaProperties = require('../format/JsonFormat').MetaProperties;
const Annotations = require('../format/JsonFormat').Annotations;

/**
 * JSON serializer for OData resources such as entity, entity collection, complex property, etc.
 *
 * More information about the usage of the serializer as well as some examples can be found in the JSDoc for the
 * corresponding methods as well as in the ResourceJsonSerialization.md file, located in the lib/serializer folder.
 */
class ResourceJsonSerializer {

    /**
     * @param {JsonContentTypeInfo} formatParams JSON serializing options
     */
    constructor(formatParams = new JsonContentTypeInfo()) {
        validateThat('formatParams', formatParams).truthy().instanceOf(Object);

        this._valueValidator = new ValueValidator();
        this._valueConverter = new ValueConverter(this._valueValidator, formatParams);
    }

    /**
     * Serializes entity to OData JSON string.
     *
     * @param {EdmEntityType|EdmEntitySet} entityTypeOrSet - entity type or entity set of the entity
     * @param {Object} data - entity data, represented as a plain object with property-value pairs. The names and
     * the number of the properties must correspond to the ones in the entity type. Property names must be specified as
     * strings. Property values must correspond to the EDM types of the corresponding entity type properties. Value for
     * a complex property must be specified as an object. Value for a collection property must be specified as an array.
     * @param {SelectItem[]} selectItems - select items from $select
     * @param {ExpandItem[]} expandItems - expand items from $expand
     * @param {boolean} eTagRequired true if an ETag is required
     * @returns {string} entity, serialized in OData JSON format
     */
    serializeEntity(entityTypeOrSet, data, selectItems, expandItems, eTagRequired) {
        validateThat('entityTypeOrSet', entityTypeOrSet).truthy().instanceOf(Object);
        validateThat('data', data).truthy().typeOf('object');

        const value = data.value;

        try {
            const serializedAnnotations = this._serializeAnnotations([MetaProperties.CONTEXT], value,
                MetaProperties.CONTEXT, MetaProperties.METADATA_ETAG);

            const selectedPaths = this._getSelectedPaths(selectItems);
            const serializedEntity = this._serializeEntity(entityTypeOrSet, value, selectedPaths, expandItems,
                eTagRequired, true);

            return JSON.stringify(Object.assign({}, serializedAnnotations, serializedEntity));
        } catch (error) {
            throw new SerializationError('An error occurred during serialization of the entity.', error);
        }
    }

    /**
     * Serializes entity collection to OData JSON string.
     *
     * @param {EdmEntityType|EdmEntitySet} entityTypeOrSet - entity type or entity set for the entities in the entity
     * collection
     * @param {Array} data - entity collection data, represented by an array of objects. The structure of the objects
     * in the array must correspond to the one, required by the serializeEntity() method.
     * @param {SelectItem[]} selectItems - select items from $select
     * @param {ExpandItem[]} expandItems - expand items from $expand
     * @param {boolean} eTagRequired true if an ETag is required
     * @returns {string} entity collection, serialized in OData JSON format
     */
    serializeEntityCollection(entityTypeOrSet, data, selectItems, expandItems, eTagRequired) {
        validateThat('entityTypeOrSet', entityTypeOrSet).truthy().instanceOf(Object);
        validateThat('data', data).truthy().typeOf('object');
        validateThat('data.value', data.value).truthy().array();

        const value = data.value;

        try {
            const selectedPaths = this._getSelectedPaths(selectItems);

            let serializedEntityCollection = this._serializeAnnotations([MetaProperties.CONTEXT], data,
                MetaProperties.CONTEXT, MetaProperties.METADATA_ETAG, MetaProperties.COUNT);
            serializedEntityCollection.value = this._serializeCollectionEntities(
                entityTypeOrSet, value, selectedPaths, expandItems,
                eTagRequired, entityTypeOrSet.isReduced === undefined);
            serializedEntityCollection = Object.assign(serializedEntityCollection,
                this._serializeAnnotations([], data, MetaProperties.NEXT_LINK));

            return JSON.stringify(serializedEntityCollection);
        } catch (error) {
            throw new SerializationError('An error occurred during serialization of the entity collection', error);
        }
    }

    /**
     * Serialize a primitive-type value to an OData JSON string.
     * @param {(EdmPrimitiveType|EdmProperty)} typeOrProperty EDM primitive type
     * @param {boolean} eTagRequired true if an ETag is required
     * @param {?(Object|string|number|boolean)} data the value
     * @param {boolean} eTagRequired true if an ETag is required
     * @returns {string} serialized representation in OData JSON format
     */
    serializePrimitive(typeOrProperty, data, eTagRequired) {
        validateThat('typeOrProperty', typeOrProperty).truthy().instanceOf(Object);
        validateThat('data', data).truthy();

        const value = data.value;

        try {
            let serializedAnnotations = this._serializeAnnotations([MetaProperties.CONTEXT], data,
                MetaProperties.CONTEXT, MetaProperties.METADATA_ETAG);
            if (eTagRequired) {
                serializedAnnotations = Object.assign(serializedAnnotations,
                    this._serializeAnnotations([MetaProperties.ETAG], data, MetaProperties.ETAG));
            }

            serializedAnnotations.value = value === null || value === undefined ?
                this._serializeNullValue(typeOrProperty) :
                this._valueConverter.convert(typeOrProperty, value);

            return JSON.stringify(serializedAnnotations);
        } catch (error) {
            throw new SerializationError('An error occurred during serialization of the primitive value', error);
        }
    }

    /**
     * Serialize a primitive-type collection value to an OData JSON string.
     * @param {(EdmPrimitiveType|EdmProperty)} typeOrProperty EDM primitive type
     *                                                        or EDM property with possible additional restrictions
     * @param {?Array} data the collection value as Array
     * @param {boolean} eTagRequired true if an ETag is required
     * @returns {string} serialized representation in OData JSON format
     */
    serializePrimitiveCollection(typeOrProperty, data, eTagRequired) {
        validateThat('typeOrProperty', typeOrProperty).truthy().instanceOf(Object);
        validateThat('data', data).truthy().typeOf('object');

        const value = data.value;

        try {
            let result = this._serializeAnnotations([MetaProperties.CONTEXT], data,
                MetaProperties.CONTEXT, MetaProperties.METADATA_ETAG, MetaProperties.COUNT);
            if (eTagRequired) {
                result = Object.assign(result,
                    this._serializeAnnotations([MetaProperties.ETAG], data, MetaProperties.ETAG));
            }

            result.value = [];
            if (value === null || value === undefined) return JSON.stringify(result);
            validateThat('data.value', data.value).array();
            result.value = value.map(valueItem => {
                if (valueItem === undefined) throw new SerializationError('Missing primitive value');
                return valueItem == null ?
                    this._serializeNullValue(typeOrProperty) :
                    this._valueConverter.convert(typeOrProperty, valueItem);
            });
            return JSON.stringify(Object.assign(
                result, this._serializeAnnotations([], data, MetaProperties.NEXT_LINK)
            ));
        } catch (error) {
            throw new SerializationError(
                'An error occurred during serialization of the primitive collection value', error);
        }
    }

    /**
     * Serialize a complex-type value to an OData JSON string.
     * @param {(EdmComplexType|EdmProperty)} typeOrProperty EDM complex type
     *                                                      or EDM property with possible additional restrictions
     * @param {?Object} data the value
     * @param {SelectItem[]} selectItems select items from $select
     * @param {ExpandItem[]} expandItems expand items from $expand
     * @param {boolean} eTagRequired true if an ETag is required
     * @returns {string} serialized representation in OData JSON format
     */
    serializeComplex(typeOrProperty, data, selectItems, expandItems, eTagRequired) {
        validateThat('typeOrProperty', typeOrProperty).truthy().instanceOf(Object);
        validateThat('data', data).truthy();

        const value = data.value;

        try {
            let result = this._serializeAnnotations([MetaProperties.CONTEXT], value || data,
                MetaProperties.CONTEXT, MetaProperties.METADATA_ETAG);
            if (eTagRequired) {
                result = Object.assign(result,
                    this._serializeAnnotations([MetaProperties.ETAG], value || data, MetaProperties.ETAG));
            }

            if (value === null || value === undefined) {
                this._serializeNullValue(typeOrProperty);
                return JSON.stringify(result);
            }

            const type = typeOrProperty.getType ? typeOrProperty.getType() : typeOrProperty;
            Object.assign(result,
                this._serializeStructuralProperties(type, null, value, this._getSelectedPaths(selectItems), true),
                this._serializeNavigationProperties(type, null, value, expandItems, true));
            return JSON.stringify(result);
        } catch (error) {
            throw new SerializationError('An error occurred during serialization of the complex value', error);
        }
    }

    /**
     * Serialize a complex-type collection value to an OData JSON string.
     * @param {(EdmComplexType|EdmProperty)} typeOrProperty EDM complex type
     *                                                      or EDM property with possible additional restrictions
     * @param {?Array} data the collection value as Array
     * @param {SelectItem[]} selectItems select items from $select
     * @param {ExpandItem[]} expandItems expand items from $expand
     * @param {boolean} eTagRequired true if an ETag is required
     * @returns {string} serialized representation in OData JSON format
     */
    serializeComplexCollection(typeOrProperty, data, selectItems, expandItems, eTagRequired) {
        validateThat('typeOrProperty', typeOrProperty).truthy().instanceOf(Object);
        validateThat('data', data).truthy();

        const value = data.value;

        try {
            let result = this._serializeAnnotations([MetaProperties.CONTEXT], data,
                MetaProperties.CONTEXT, MetaProperties.METADATA_ETAG, MetaProperties.COUNT);
            if (eTagRequired) {
                result = Object.assign(result,
                    this._serializeAnnotations([MetaProperties.ETAG], value || data, MetaProperties.ETAG));
            }

            result.value = [];
            if (value === null || value === undefined) return JSON.stringify(result);
            validateThat('data.value', value).array();
            const type = typeOrProperty.getType ? typeOrProperty.getType() : typeOrProperty;
            const selectedPaths = this._getSelectedPaths(selectItems);
            result.value = value.map(valueItem => {
                if (valueItem === undefined) throw new SerializationError('Missing complex value');
                return valueItem == null ?
                    this._serializeNullValue(typeOrProperty) :
                    Object.assign({},
                        this._serializeStructuralProperties(type, null, valueItem, selectedPaths, true),
                        this._serializeNavigationProperties(type, null, valueItem, expandItems, true));
            });

            return JSON.stringify(Object.assign(
                result, this._serializeAnnotations([], data, MetaProperties.NEXT_LINK)
            ));
        } catch (error) {
            throw new SerializationError('An error occurred during serialization of the complex collection value',
                error);
        }
    }

    /**
     * Serializes entity collection references.
     * @param {UriResource[]} pathSegments path segments of the URI of the entity
     * @param {?Array} data the collection value as Array
     * @returns {string} serialized representation in OData JSON format
     */
    serializeReferenceCollection(pathSegments, data) {
        validateThat('pathSegments', pathSegments).truthy().instanceOf(Object);
        validateThat('data', data).truthy().typeOf('object');

        const value = data.value;

        try {
            const serializedAnnotations = this._serializeAnnotations([MetaProperties.CONTEXT], data,
                MetaProperties.CONTEXT, MetaProperties.METADATA_ETAG, MetaProperties.COUNT);

            const serializedReferences = value.map(entity => this._serializeEntityReference(pathSegments, entity));
            const serializedReferenceCollection = Object.assign(
                serializedAnnotations, { value: serializedReferences },
                this._serializeAnnotations([], data, MetaProperties.NEXT_LINK)
            );

            return JSON.stringify(serializedReferenceCollection);
        } catch (error) {
            throw new SerializationError('An error occurred during serialization of the reference collection', error);
        }
    }

    /**
     * Serializes entity reference.
     * @param {UriResource[]} pathSegments path segments of the URI of the entity
     * @param {Object} data - the collection value as Array
     * @returns {string} serialized representation in OData JSON format
     */
    serializeReference(pathSegments, data) {
        validateThat('pathSegments', pathSegments).truthy().instanceOf(Object);
        validateThat('data', data).truthy().typeOf('object');

        const value = data.value;

        try {
            const serializedAnnotations = this._serializeAnnotations([MetaProperties.CONTEXT], value || data,
                MetaProperties.CONTEXT, MetaProperties.METADATA_ETAG);

            return JSON.stringify(
                Object.assign(serializedAnnotations, this._serializeEntityReference(pathSegments, value)));
        } catch (error) {
            throw new SerializationError('An error occurred during serialization of the reference', error);
        }
    }

    /**
     * Serializes entity reference.
     * @param {UriResource[]} pathSegments path segments of the URI of the entity
     * @param {Object} entity - the entity the reference will be serialized for
     * @returns {Object} serialized entity reference with correct annotations
     * @private
     */
    _serializeEntityReference(pathSegments, entity) {
        const entityType = pathSegments[pathSegments.length - 1].getEdmType()
            || (pathSegments.length > 1 ? pathSegments[pathSegments.length - 2].getEdmType() : null);
        return {
            [JsonAnnotations.ID]:
                UriHelper.buildCanonicalUrl(pathSegments, UriHelper.buildEntityKeys(entityType, entity))
        };
    }

    /**
     * Serializes entity collections.
     *
     * @param {EdmEntityType|EdmEntitySet} entityTypeOrSet - entity type for the entities
     * @param {Array} entities - entities, which have to be serialized
     * @param {string[][]} selectedPaths - selected properties' paths from $select
     * @param {ExpandItem[]} expandItems - expand items from $expand
     * @param {boolean} eTagRequired true if an ETag is required
     * @paran {boolean} isKeyRequired whether all key properties have to be serialized
     * @returns {Array} objects representing the serialized entities
     * @private
     */
    _serializeCollectionEntities(entityTypeOrSet, entities, selectedPaths, expandItems, eTagRequired, isKeyRequired) {
        return entities.map((currentEntity, index) => {
            try {
                return this._serializeEntity(entityTypeOrSet, currentEntity, selectedPaths, expandItems,
                    eTagRequired, isKeyRequired);
            } catch (error) {
                const entityType = entityTypeOrSet.getEntityType ? entityTypeOrSet.getEntityType() : entityTypeOrSet;
                const errorMsg =
                    this._getErrorMsgForCollectionEntity(currentEntity, entityType.getKeyPropertyRefs().keys(), index);
                throw new SerializationError(errorMsg, error);
            }
        });
    }

    /**
     * Serializes entity to OData JSON string.
     *
     * @param {EdmEntitySet|EdmEntityType} entityTypeOrSet - entity set or entity type of the entity
     * @param {Object} data - entity data, represented as a plain object with property-value pairs. The names and
     * the number of the properties must correspond to the ones in the entity type. Property names must be specified as
     * strings. Property values must correspond to the EDM types of the corresponding entity type properties.
     * @param {string[][]} selectedPaths - selected properties' paths from $select
     * @param {ExpandItem[]} expandItems - expand items from $expand
     * @param {boolean} eTagRequired - true, if an ETag is required
     * @paran {boolean} isKeyRequired whether all key properties have to be serialized
     * @returns {Object} plain object, representing the serialized entity
     * @private
     */
    _serializeEntity(entityTypeOrSet, data, selectedPaths, expandItems, eTagRequired, isKeyRequired) {
        const entityType = entityTypeOrSet.getEntityType ? entityTypeOrSet.getEntityType() : entityTypeOrSet;
        const entitySet = entityTypeOrSet.getEntityType ? entityTypeOrSet : null;

        const serializedAnnotations = entitySet && entitySet.isConcurrent() || eTagRequired ?
            this._serializeAnnotations([MetaProperties.ETAG], data, MetaProperties.ETAG) :
            {};

        const serializedStructProps = this._serializeStructuralProperties(entityType, entitySet, data, selectedPaths,
            isKeyRequired);
        const serializedNavProps = this._serializeNavigationProperties(entityType, entitySet, data, expandItems,
            isKeyRequired);

        // Add annotation '"@odata.id": null' for an entity of a transient type if some properties have been
        // aggregated away or if not all of the base type's properties have been serialized.
        let type = entityType;
        while (type.isReduced) type = type.getBaseType();
        let addition = entityType.isReduced
            && (entityType.isReduced()
                || Array.from(type.getProperties().keys()).some(name => serializedStructProps[name] === undefined)) ?
            { [JsonAnnotations.ID]: null } :
            {};

        return Object.assign(addition, serializedAnnotations, serializedStructProps, serializedNavProps);
    }

    /**
     * Serializes entity annotations.
     * @param {string[]} requiredAnnotations
     * @param {Object} sourceData
     * @param {string[]} metaProperties
     * @returns {Object} object containing the serialized annotations
     * @private
     */
    _serializeAnnotations(requiredAnnotations, sourceData, ...metaProperties) {
        let result = {};
        if (sourceData == null) return sourceData;

        for (const metaProperty of metaProperties) {
            if (requiredAnnotations.includes(metaProperty)) {
                this._assertAnnotationExist(metaProperty, sourceData);
            }
            const annotation = MetaProperties.getAnnotation(metaProperty);
            result[annotation] = this._validateAnnotationValue(annotation, sourceData[metaProperty]);
        }

        return result;
    }

    /**
     * Asserts that an annotation exists
     *
     * @param {string} annotation The annotation
     * @param {Object} sourceData The data object on which the annotation should exist
     * @returns {boolean} True if annotation exists
     * @private
     */
    _assertAnnotationExist(annotation, sourceData) {
        if (sourceData && sourceData[annotation] != null) return true;
        throw new SerializationError(`Missing Annotation '${annotation}' in ${JSON.stringify(sourceData)}`);
    }

    /**
     * Validates and converts an OData annotation value.
     * Validates @odata.etag and @odata.count annotation and returns the validated/converted value.
     * If the annotation is not an OData defined annotation the value is returned 'as is'.
     *
     * @param {string} annotation The annotation
     * @param {*} value The value of the annotation
     * @returns {*} The value of the annotation or the converted one if it is an OData annotation
     * @throws {SerializationError} In case there is an error with converting the annotation value
     * @private
     */
    _validateAnnotationValue(annotation, value) {
        if (value === undefined) return value;
        if (annotation === Annotations.COUNT) {
            // @odata.count
            try {
                return this._valueConverter.convertInt64(value);
            } catch (error) {
                throw new SerializationError(
                    `An error occurred during serialization of '${annotation}' annotation.`, error
                );
            }
        } else if (annotation === Annotations.ETAG || annotation === Annotations.METADATA_ETAG) {
            // @odata.etag or @odata.metadataEtag
            try {
                this._valueValidator.validateEtagValue(value);
                return `W/"${value}"`;
            } catch (error) {
                throw new SerializationError(
                    `An error occurred during serialization of '${annotation}' annotation.`, error
                );
            }
        } else if (annotation === Annotations.CONTEXT || annotation === Annotations.NEXT_LINK) {
            if (typeof value === 'string') return value;
            throw new SerializationError(`The annotation '${annotation}' has the wrong value '${value}'.`);
        } else if (annotation.startsWith('@odata.')) {
            throw new SerializationError(`Unsupported OData annotation '${annotation}'`);
        } else {
            // TODO: Validate and convert foreign annotations.
            return value;
        }
    }

    /**
     * Get selected paths from select items.
     * @param {SelectItem[]} selectItems - select items from $select
     * @returns {string[][]} selected properties' paths from $select
     * @private
     */
    _getSelectedPaths(selectItems) {
        return selectItems && selectItems.length > 0 && !selectItems.some(item => item.isAll()) ?
            selectItems.map(item => item.getPathSegments().map(segment => segment.getPathSegmentIdentifier())) :
            [];
    }

    /**
     * Reduce selected paths to those paths following a specified complex-property name.
     * @param {string[][]} paths - selected properties' paths
     * @param {string} name - property name
     * @returns {string[][]} properties' paths following the specified complex-property name
     * @private
     */
    _reduceSelectedPaths(paths, name) {
        // If the complex property is selected without following sub-components,
        // return an empty paths array to signal that all sub-components are selected.
        if (paths.some(path => path[0] === name && path.length === 1)) return [];
        // Return all paths starting with the name of the complex property, but not including its name itself.
        return paths
            .filter(path => path[0] === name && path.length > 1)
            .map(path => path.slice(1));
    }

    /**
     * Serializes structural properties of a structured type.
     *
     * @param {(EdmEntityType|EdmComplexType)} type - EDM type for the specified data
     * @param {?EdmEntitySet} entitySet - EDM set for the specified data
     * @param {?EdmEntitySet} set - EDM set for the specified data
     * @param {Object} data - entity data, represented as a plain object with property-value pairs.
     * @param {string[][]} selectedPaths - selected properties' paths from $select
     * @paran {boolean} isKeyRequired whether all key properties have to be serialized
     *
     * @returns {Object} JSON object containing the serialized structural properties of the entity
     * @private
     */
    _serializeStructuralProperties(type, entitySet, data, selectedPaths, isKeyRequired) {
        if (!(typeof data === 'object')) {
            throw new SerializationError('Value of a structured property must be an object');
        }
        if (Array.isArray(data)) {
            throw new SerializationError('The returned value has to be a plain JSON object, but received Array');
        }

        const serializedStructuralProps = this._getAssertAdditionalProperties(data, type, selectedPaths);

        for (const [propertyName, property] of type.getProperties()) {
            if (selectedPaths.length === 0
                || selectedPaths.find(path => path[0] === propertyName)
                || type.getKind() === EdmTypeKind.ENTITY && type.getKeyPropertyRef(propertyName) && isKeyRequired) {
                const propertyType = property.getType();
                const isComplex = propertyType.getKind() === EdmTypeKind.COMPLEX;
                const propertyValue = data[propertyName];
                // Don't serialize optional property if the value is absent.
                if ((propertyValue === null || propertyValue === undefined)
                    && type.getOptionalProperty && type.getOptionalProperty(propertyName)) {
                    continue;
                }
                // Add the type annotation to a dynamic property.
                if (!isComplex
                    && ![EdmPrimitiveTypeKind.Boolean, EdmPrimitiveTypeKind.Double, EdmPrimitiveTypeKind.String]
                        .includes(propertyType)
                    && !(property instanceof EdmProperty)) {
                    serializedStructuralProps[propertyName + JsonAnnotations.TYPE] =
                        '#' + propertyType.getFullQualifiedName().name;
                }
                // Serialize the value.
                const paths = isComplex ? this._reduceSelectedPaths(selectedPaths, propertyName) : [];
                serializedStructuralProps[propertyName] = this._serializeProperty(property, propertyValue, paths);
            }
        }
        return serializedStructuralProps;
    }

    /**
     * Serialize navigation properties.
     * @param {(EdmEntityType|EdmComplexType)} type - EDM type for the specified data
     * @param {?EdmEntitySet} entitySet - EDM set for the specified data
     * @param {*} data the data
     * @param {ExpandItem[]} expandItems - expand items from $expand
     * @paran {boolean} isKeyRequired whether all key properties have to be serialized
     * @returns {Object}
     * @private
     */
    _serializeNavigationProperties(type, entitySet, data, expandItems, isKeyRequired) {
        if (!(typeof data === 'object')) {
            throw new SerializationError('Value of entity data must be an object');
        }

        let serializedNavProps = {};
        if (!expandItems || expandItems.length === 0) return serializedNavProps;

        const allExpandItem = expandItems.find(item => item.isAll());

        for (const [navPropertyName, navProperty] of type.getNavigationProperties()) {
            const expandItem = allExpandItem || expandItems.find(expItem =>
                // There are no path segments if isAll(), so we check that first.
                // As a bonus, this find ends at the first '*' expand item and guarantees
                // that expandItem is never null.
                expItem.isAll() || expItem.getPathSegments()[0].getNavigationProperty().getName() === navPropertyName);

            if (expandItem) {
                const expandedEntityType = navProperty.getEntityType();
                const expandedEntitySet = entitySet ? entitySet.getRelatedBindingTarget(navPropertyName) : null;
                const navPropertyValue = data[navPropertyName];
                const optionsSelectedPaths = this._getSelectedPaths(expandItem.getOption(QueryOptions.SELECT));
                const optionsExpandItems = expandItem.getOption(QueryOptions.EXPAND);
                const expandItemPathSegments = expandItem.getPathSegments();

                if (expandItemPathSegments.length > 0
                    && expandItemPathSegments[expandItemPathSegments.length - 1].getKind() === ResourceKind.COUNT) {

                    if (data[navPropertyName + MetaProperties.COUNT] == null) {
                        throw new SerializationError(`Missing Metaproperty ${navPropertyName + MetaProperties.COUNT}`);
                    }

                    const countValue = this._valueConverter.convertInt64(data[navPropertyName + MetaProperties.COUNT]);
                    if (countValue < 0) {
                        throw new SerializationError(
                            `The value of ${navPropertyName + MetaProperties.COUNT} must be a non-negative number`);
                    }

                    serializedNavProps[navPropertyName + Annotations.COUNT] = countValue;

                } else if (navPropertyValue === null || navPropertyValue === undefined) {
                    serializedNavProps[navPropertyName] = navProperty.isCollection() ?
                        [] :
                        this._serializeNullValue(navProperty);
                } else if (Array.isArray(navPropertyValue) && navProperty.isCollection()) {
                    serializedNavProps[navPropertyName] = this._serializeCollectionEntities(
                        expandedEntitySet || expandedEntityType,
                        navPropertyValue,
                        optionsSelectedPaths,
                        optionsExpandItems,
                        undefined,  // eTagRequired is determined from expandedEntitySet
                        isKeyRequired
                    );
                } else if (!Array.isArray(navPropertyValue) && !navProperty.isCollection()) {
                    serializedNavProps[navPropertyName] = this._serializeEntity(
                        expandedEntitySet || expandedEntityType,
                        navPropertyValue,
                        optionsSelectedPaths,
                        optionsExpandItems,
                        undefined,  // eTagRequired is determined from expandedEntitySet
                        isKeyRequired
                    );
                } else {
                    throw new SerializationError(
                        'The provided data does not fit the type of the navigation property: ' + navPropertyName);
                }
            }
        }
        return serializedNavProps;
    }

    /**
     * Checks whether the entity contains properties, which belong neither to the structural nor to the navigation
     * properties of the specified type. Returns any additional annotations.
     *
     * @param {Object} data - entity data, represented as a plain object with property-value pairs.
     * @param {EdmEntityType|EdmComplexType} type - EDM type for the specified entity data
     * @param {string[][]} selectedPaths - selected properties' paths from $select
     * @throws {SerializationError} - Thrown if there is any unexpected property
     * @returns {Object} An object with all additional expected properties found
     * @private
     */
    _getAssertAdditionalProperties(data, type, selectedPaths) {
        const structProps = type.getProperties();
        const navProps = type.getNavigationProperties();

        const entityProps = Object.keys(data);
        const extraProperties = {};

        for (let entityProp of entityProps) {
            const [star, identifier, annotation] = this._getPropertyNameAndAnnotation(entityProp);

            if (identifier && !structProps.has(identifier) && !navProps.has(identifier)) {
                throw new SerializationError(`The entity contains '${entityProp}' property, which does not belong` +
                    ` neither to the structural nor to the navigation properties of the '${type.getName()}' type`);
            }

            if (annotation && !navProps.has(identifier)) {
                let newPropertyName = entityProp;
                if (star) newPropertyName = newPropertyName.replace('*', '');
                if (newPropertyName.startsWith('@odata.')) continue;
                if (!identifier
                    || selectedPaths.length === 0
                    || selectedPaths.find(path => path[0] === identifier)
                    || type.getKind() === EdmTypeKind.ENTITY && type.getKeyPropertyRef(identifier)) {
                    extraProperties[newPropertyName] = this._validateAnnotationValue(annotation, data[entityProp]);
                }
            }
        }

        return extraProperties;
    }

    /**
     * Serializes EDM property.
     *
     * @param {EdmProperty} property - EDM property, which has to be serialized
     * @param {*} propertyValue - property value
     * @param {string[][]} selectedPaths - selected properties' paths from $select
     *
     * @returns {*} serialized property value
     * @private
     */
    _serializeProperty(property, propertyValue, selectedPaths) {
        try {
            if (property.isCollection()) {
                return this._serializeCollectionProperty(property, propertyValue, selectedPaths);
            }
            if (propertyValue === null || propertyValue === undefined) return this._serializeNullValue(property);
            return this._serializePropertyValue(property, propertyValue, selectedPaths);
        } catch (error) {
            throw new SerializationError(`Serialization of the '${property.getName()}' property failed.`, error);
        }
    }

    /**
     * Serializes null value for the EDM type or (navigation) property.
     * @param {(EdmPrimitiveType|EdmProperty|EdmNavigationProperty)} typeOrProperty EDM primitive type or EDM (navigation) property
     * @returns {null} null value, if nullable
     * @throws {SerializationError} if the property is not nullable
     * @private
     */
    _serializeNullValue(typeOrProperty) {
        const nullable = typeOrProperty.isNullable ? typeOrProperty.isNullable() : true;
        if (nullable === undefined || nullable) return null;
        throw new SerializationError(`Not nullable value for '${typeOrProperty.getName()}' must not be null`);
    }

    /**
     * Serializes EDM collection property.
     *
     * @param {EdmProperty} property - EDM property, which has to be serialized
     * @param {?Array} propertyValues - array of property values
     * @param {string[][]} selectedPaths - selected properties' paths from $select
     *
     * @returns {Array} serialized property values
     * @private
     */
    _serializeCollectionProperty(property, propertyValues, selectedPaths) {
        if (propertyValues === null || propertyValues === undefined) return [];
        if (!Array.isArray(propertyValues)) {
            throw new SerializationError(`Value of collection property '${property.getName()}' must be an array`);
        }

        return propertyValues.map(
            propertyValue => this._serializePropertyValue(property, propertyValue, selectedPaths));
    }

    /**
     * Serializes a single value of an EDM property.
     *
     * @param {EdmProperty} property - EDM property for which the value has to be serialized
     * @param {*} propertyValue - property value which has to be serialized
     * @param {string[][]} selectedPaths - selected properties' paths from $select
     *
     * @returns {*} serialized property value
     * @private
     */
    _serializePropertyValue(property, propertyValue, selectedPaths) {
        // This is used to serialize null elements inside a collection.
        if (propertyValue === undefined) {
            throw new SerializationError(`Missing value for property '${property.getName()}'`);
        }
        if (propertyValue === null) return this._serializeNullValue(property);

        switch (property.getType().getKind()) {
            case EdmTypeKind.PRIMITIVE:
            case EdmTypeKind.ENUM:
            case EdmTypeKind.DEFINITION:
                return this._valueConverter.convert(property, propertyValue);
            case EdmTypeKind.COMPLEX:
                return this._serializeStructuralProperties(property.getType(), null, propertyValue, selectedPaths);
            default:
                throw new SerializationError(
                    `Serialization of properties of ${property.getType().getKind()} type kind is not supported`);
        }
    }

    /**
     * Returns error message, which will be used for the error, thrown during the serialization of an entity in scope of
     * the entity collection.
     *
     * @param {Object} entity - entity data
     * @param {string[]} keyNames - names of all the key properties of the entity's entity type
     * @param {number} entityIndex - index of the entity in the entity collection
     *
     * @returns {string} error message
     * @private
     */
    _getErrorMsgForCollectionEntity(entity, keyNames, entityIndex) {
        const keyValues = this._getEntityKeyValues(entity, keyNames);

        // if key/value pairs can be determined, return the error message containing key(s) info
        if (keyValues) {
            return `An error occurred during serialization of the entity with the following key(s): ${keyValues}`;
        }

        // if key/value pairs cannot be determined, return the error message, containing the index of the entity in the
        // entity collection
        return `An error occurred during serialization of the entity at index #${entityIndex} in the entity collection`;
    }

    /**
     * Returns string, containing values for the key properties in the specified entity.
     *
     * @param {Object} entity - entity data
     * @param {Array} keyNames - names of the key properties in the entity's entity type
     *
     * @returns {?string} string in the format <key_property_name1>: <value1>, <key_property_name2>: <value2> or
     * null, if one of the key values is undefined
     * @private
     */
    _getEntityKeyValues(entity, keyNames) {
        let keyValues = [];

        for (const keyName of keyNames) {
            const keyValue = entity[keyName];

            if (keyValue === null || keyValue === undefined) {
                // return null to indicate that key values cannot be determined
                return null;
            }

            keyValues.push(`${keyName}: ${keyValue}`);
        }

        return keyValues.join(', ');
    }
    /**
     * Returns the name and possibly existing annotation. If the property name starts with an '@' like '@odata.etag'
     * the name of the property is '@odata.etag' while the annotation does not exist. If the name is
     * 'Property@any.annotation' than the name would be 'Property' and the annotation would be '@any.annotation'.
     *
     * @param {string} propertyName - The property name
     * @returns {string[]} - An array of strings with [star, name, annotation]
     */
    _getPropertyNameAndAnnotation(propertyName) {
        let result = [];
        let index = 0;
        if (propertyName.charAt(index) === '*') {
            result.push('*');
            index++;
        } else {
            result.push(undefined);
        }
        let currentValue = '';
        while (index < propertyName.length) {
            const char = propertyName.charAt(index);
            if (char === '@') {
                result.push(currentValue === '' ? undefined : currentValue);
                currentValue = '';
            }
            if (char === '*') {
                index++;
                continue;
            }
            currentValue += char;
            index++;
        }
        result.push(currentValue);

        return result;
    }
}

module.exports = ResourceJsonSerializer;
