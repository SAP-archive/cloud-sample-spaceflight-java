'use strict';

const ErrorSerializer = require('./ErrorSerializer');

/**
 * The ErrorXmlSerializer serializes an error to an OData error in XML format.
 *
 * @extends ErrorSerializer
 */
class ErrorXmlSerializer extends ErrorSerializer {

    /**
     * Creates an instance of ErrorXmlSerializer.
     *
     * @param {Error} error The error to serialize.
     * @throws {IllegalArgumentError} Thrown if provided error is undefined or does not have the correct structure
     */
    constructor(error) {
        super(error);
    }

    /**
     * Serializes the provided error to an OData error in XML format.
     *
     * @returns {string} an OData error XML string
     */
    serialize() {
        let result = '<?xml version="1.0" encoding="UTF-8"?>'
            + '<error xmlns="http://docs.oasis-open.org/odata/ns/metadata">'
            + '<code>' + this._escapeXmlChars(this._error.code || 'null') + '</code>'
            + '<message>' + this._escapeXmlChars(this._error.message) + '</message>';
        if (this._error.target) result += '<target>' + this._escapeXmlChars(this._error.target) + '</target>';
        if (this._error.details && this._error.details.length) {
            result += '<details>';
            for (const detail of this._error.details) {
                result += '<detail>'
                    + '<code>' + this._escapeXmlChars(detail.code || 'null') + '</code>'
                    + '<message>' + this._escapeXmlChars(detail.message) + '</message>';
                if (detail.target) result += '<target>' + this._escapeXmlChars(detail.target) + '</target>';
                result += this._serializeAnnnotations(detail)
                    + '</detail>';
            }
            result += '</details>';
        }
        result += this._serializeAnnnotations(this._error)
            + '</error>';
        return result;
    }

    /**
     * Serializes the annotations of an element.
     * @param {string} element the annnotated element
     * @returns {string} the serialized annotation
     * @private
     */
    _serializeAnnnotations(element) {
        let result = '';
        for (const name of Object.keys(element).filter(n => n.startsWith('@'))) {
            const value = element[name];
            if (value !== null && typeof value === 'object') {
                throw new Error('Only primitive annotation values are supported in error XML serialization');
            }
            // "If the type of the annotation value being specified is anything other than
            // Edm.String the metadata:annotation element MUST contain a metadata:type
            // attribute to specify the appropriate type of the annotation value."
            // TODO: Determine the type for string- or number-valued annotation values
            //       that are not of type 'Edm.String' or 'Edm.Decimal', respectively.
            let type;
            if (typeof value === 'boolean') type = 'Edm.Boolean';
            if (typeof value === 'number') type = 'Edm.Decimal';
            let valueLiteral = value === null ? '' : String(value);
            if (!type) valueLiteral = this._escapeXmlChars(valueLiteral);
            result += '<annotation term="' + name.substr(1) + '"'
                + (value === null ? ' null="true"' : '') + (type ? ' type="' + type + '"' : '') + '>'
                + valueLiteral + '</annotation>';
        }
        return result;
    }

    /**
     * Escapes XML characters &,",',<,> with corresponding escapes sequences.
     * @param {string} input the original string
     * @returns {string} the modified string
     * @private
     */
    _escapeXmlChars(input) {
        return input.replace(/&/g, '&amp;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&apos;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
    }
}

module.exports = ErrorXmlSerializer;
