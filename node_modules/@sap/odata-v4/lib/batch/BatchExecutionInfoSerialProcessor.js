'use strict';

/**
 * The BatchExecutionInfoSerialProcessor executes a chain of batch commands and handles possible errors.
 * The error handling respects the $batch error specifications.
 *
 * 11.7.2 Batch Request Body
 * The body of a batch request is made up of a series of individual requests and change sets, each represented as a
 * distinct MIME part (i.e. separated by the boundary defined in the Content-Type header).
 * The service MUST process the requests within a batch request sequentially. Processing stops on the first
 * error unless the odata.continue-on-error preference is specified.
 */
class BatchExecutionInfoSerialProcessor {

    /**
     * Creates an instance of BatchExecutionInfoSerialProcessor
     *
     * @param {BatchContext} batchContext
     */
    constructor(batchContext) {

        /**
         * Batch context
         * @type {BatchContext}
         * @private
         */
        this._batchContext = batchContext;

        /**
         * List of commands to be executed
         * @type {Command[]}
         * @private
         */
        this._executionCommands = batchContext.getExecutionInfo();
    }

    /**
     * Process the commands contained in the batch request.
     *
     * @param {Command~Next} next
     */
    process(next) {
        this._execute(0, err => next(err));
    }

    /**
     * Executes the command referenced by its index recursively. The execution is asynchronous.
     *
     * @param {number} index The current command index to execute
     * @param {Function} callback called when chain ends or an error occurs
     * @private
     */
    _execute(index, callback) {
        const currentCommand = this._executionCommands[index];

        if (!currentCommand) {
            // Finished
            return callback();
        }

        const next = (err) => {
            if (err) {
                // Error occurred in batch processing itself but NOT while executing a batched request
                return callback(err);
            }

            if (this._batchContext.getFailedRequestsOfBatchRequest().length > 0) {
                if (!this._batchContext.isContinueOnError()) {
                    // just stop execution
                    return callback();
                }
                // Continue execution -> Preference continue-on-error was applied
                this._batchContext.getResponse().getPreferencesApplied().setOdataContinueOnErrorApplied(true);
            }

            if (this._batchContext.getFailedAtomicityGroups().size > 0) {
                if (!this._batchContext.isContinueOnError()) {
                    // just stop execution
                    return callback();
                }
                // Continue execution -> Preference continue-on-error was applied
                this._batchContext.getResponse().getPreferencesApplied().setOdataContinueOnErrorApplied(true);
            }

            return process.nextTick(() => this._execute(index + 1, callback));
        };

        try {
            return currentCommand.execute(next);
        } catch (innerError) {
            // Error occurred in batch processing itself  but NOT while executing a batched request
            return callback(innerError);
        }
    }
}

module.exports = BatchExecutionInfoSerialProcessor;
