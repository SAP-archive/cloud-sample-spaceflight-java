'use strict';

const AtomicityGroupStartCommand = require('../invocation/batch/AtomicityGroupStartCommand');
const AtomicityGroupEndCommand = require('../invocation/batch/AtomicityGroupEndCommand');

/**
 * The AtomicityGroupExecutor executes a chain of batch commands and handles possible errors.
 * The error handling respects the $batch error specifications. It ensures that the AtomicityGroupEndHandler is
 * called in any case to allow the application to do a proper cleanup.
 *
 * 11.7.2 Batch Request Body
 * The body of a batch request is made up of a series of individual requests and change sets, each represented as a
 * distinct MIME part (i.e. separated by the boundary defined in the Content-Type header).
 * The service MUST process the requests within a batch request sequentially. Processing stops on the first
 * error unless the odata.continue-on-error preference is specified.
 */
class AtomicityGroupExecutor {

    /**
     * Creates an instance of AtomicityGroupExecutor
     * @param {BatchContext} batchContext
     * @param {BatchedRequestExecutionCommand[]} atomicityGroupCommands
     * @param {string} atomicityGroupId
     */
    constructor(batchContext, atomicityGroupCommands, atomicityGroupId) {

        /**
         * Batch context
         * @type {BatchContext}
         * @private
         */
        this._batchContext = batchContext;

        /**
         * Atomicity group id
         * @type {string}
         * @private
         */
        this._atomicityGroupId = atomicityGroupId;

        /**
         * Command list to be processed
         * @type {Command[]}
         * @private
         */
        this._executionCommands = [new AtomicityGroupStartCommand(batchContext, atomicityGroupId)]
            .concat(atomicityGroupCommands);
    }

    /**
     * Process the commands contained in the atomicity group
     *
     * @param {Command~Next} next
     */
    process(next) {
        this._execute(0, (err) => {
            // end command handler MUST always be called
            const atomGroupEndCommand = new AtomicityGroupEndCommand(this._batchContext, this._atomicityGroupId, err);
            // An error in the application's exit handler is considered as an internal batch processing error and
            // the batch processing MUST be stopped, hence forward the error.
            return atomGroupEndCommand.execute((error, repeat) => {
                if (repeat) {
                    // clean up
                    this._batchContext.getLogger().info('Re-executing atomicity group ' + this._atomicityGroupId);
                    this._batchContext.removeAtomicityGroup(this._atomicityGroupId);
                    return this.process(next);
                }

                return next(error);
            });
        });
    }

    /**
     * Executes the command referenced by its index recursively. The execution is asynchronous.
     *
     * @param {number} index The current command index to execute
     * @param {Function} callback called when chain ends or an error occurs
     * @private
     */
    _execute(index, callback) {
        const currentCommand = this._executionCommands[index];

        if (!currentCommand) {
            // Finished
            return callback();
        }

        try {
            return currentCommand.execute((err) => {
                // in case of frameworks errors forward that error
                if (err) {
                    // stop execution of commands with error
                    return callback(err);
                }

                // in case a batched request could not be executed the command chain is STOPPED except there is
                // odata.continue-on-error set as prefer header
                if (!this._batchContext.isAtomicityGroupExecuted(this._atomicityGroupId) &&
                    !this._batchContext.isContinueOnError()) {
                    // just stop execution
                    return callback();
                }

                // Execute the next command.
                return process.nextTick(() => this._execute(index + 1, callback));
            });
        } catch (internalError) {
            // Error occurred in batch processing itself but NOT while executing a batched request.
            return callback(internalError);
        }
    }
}

module.exports = AtomicityGroupExecutor;
