'use strict';

const BatchContext = require('./BatchContext');
const BatchErrorInfo = require('./BatchErrorInfo');
const OdataResponseInBatch = require('../core/OdataResponseInBatch');
const PlainHttpResponse = require('../core/PlainHttpResponse');
const HeaderNames = require('../http/HttpHeader').HeaderNames;
const HttpStatusCode = require('../http/HttpStatusCode');
const HttpStatusCodes = HttpStatusCode.StatusCodes;
const HttpStatusCodesText = HttpStatusCode.Texts;

const reg = /\$\w*/g;

/**
 * Start the execution of a Request contained within request to $batch.
 */
class BatchedRequestExecutor {

    /**
     * Constructor
     * @param {BatchContext} batchContext Batch context
     * @param {OdataRequestInBatch} request Batched request
     */
    constructor(batchContext, request) {

        /**
         * Batch context
         * @type {BatchContext}
         * @private
         */
        this._batchContext = batchContext;

        /**
         * Request to be executed
         * @type {OdataRequestInBatch}
         * @private
         */
        this._request = request;
    }

    /**
     * Returns true if all dependencies are full filled
     *
     * @returns {boolean}
     */
    dependenciesExecuted() {
        const dependencies = this._request.getDependsOnList();
        for (let value of dependencies) {
            if (!this._batchContext.isIdExecuted(value)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Executes a batched request with forwarding the requests http data to the process method of the service
     * @param {Command~Next} next Callback
     */
    execute(next) {
        const oDataRequestID = this._request.getOdataRequestId();
        const service = this._batchContext.getService();

        const plainHttpRequest = this._request.getIncomingRequest();
        const plainHttpResponse = new PlainHttpResponse();
        const odataResponseInBatch = new OdataResponseInBatch(plainHttpResponse, null, oDataRequestID);

        const atomicityGroupId = this._request.getAtomicityGroupId();

        // transfer information to nested ODataRequest via PlaintHttpRequest
        plainHttpRequest.setOdataRequestId(oDataRequestID);
        plainHttpRequest.setBatchInfo({ context: this._batchContext });

        if (atomicityGroupId) {
            plainHttpRequest.setAtomicityGroupId(atomicityGroupId);
            odataResponseInBatch.setAtomicityGroupId(atomicityGroupId);
        }
        this._batchContext.addResponseInBatch(odataResponseInBatch);

        // all dependencies must be full filled
        if (this._batchContext.getSemantic() === BatchContext.SEMANTIC.JSON) {
            if (!this.dependenciesExecuted()) {
                plainHttpResponse.statusCode = HttpStatusCodes.FAILED_DEPENDENCY;
                plainHttpResponse.statusMessage = HttpStatusCodesText[HttpStatusCodes.FAILED_DEPENDENCY];
                return next();
            }
        }

        this.insertContentIdsIntoRequestUrl();

        return service.process(plainHttpRequest, plainHttpResponse)
            .then((/* ignore result, read status code */) => {
                const statusCode = plainHttpResponse.statusCode;
                if (statusCode >= 400 && statusCode < 600) {
                    const errorInfo = new BatchErrorInfo(oDataRequestID, this._request, odataResponseInBatch);
                    this._batchContext.markRequestAsFailed(errorInfo);
                    return next();
                }

                // store location header
                const locationHeader = plainHttpResponse.getHeader(HeaderNames.LOCATION);
                if (locationHeader) {
                    this._batchContext.addLocation(atomicityGroupId, oDataRequestID, locationHeader);
                }

                this._batchContext.markIdAsExecuted(oDataRequestID);
                return next();
            })
            .catch((error) => {
                return next(error);
            });
    }

    /**
     * Apply content Id referencing
     */
    insertContentIdsIntoRequestUrl() {
        let url = this._request.getIncomingRequest().url;
        const atomicityGroup = this._request.getAtomicityGroupId();

        if (!url.includes('$')) {
            return;
        }

        let ids = this._extractIds(url);

        for (const id of ids) {
            const replacement = this._batchContext.getLocation(atomicityGroup, id.substr(1));
            if (replacement) {
                url = url.replace(id, replacement);
            }
        }

        this._request.rewriteUrl(url);
    }

    /**
     * Extract ids with the reqex pattern $(w*) from the input
     *
     * @returns {Array<string>} Array of extracted id names
     */
    _extractIds(input) {
        let ids = [];

        let myArray;
        myArray = reg.exec(input);
        while (myArray !== null) {
            ids.push(myArray[0]);
            myArray = reg.exec(input); // search next
        }

        return ids;
    }
}

module.exports = BatchedRequestExecutor;
