'use strict';

const url = require('url');
const RequestContract = require('./RequestContract');
const UriHelper = require('../uri/UriHelper');
const HttpStatusCodes = require('../http/HttpStatusCode').StatusCodes;
const HttpMethods = require('../http/HttpMethod').Methods;
const HeaderNames = require('../http/HttpHeader').HeaderNames;
const Preferences = require('../http/Preferences');
const ResourceKind = require('../uri/UriResource').ResourceKind;
const EdmTypeKind = require('../edm/EdmType').TypeKind;

const ConditionalRequestValidator = require('../validator/ConditionalRequestValidator');
const StateMachine = require('../utils/StateMachine');

/**
 * Request object wrapper to carry original request information.
 * @hideconstructor
 */
class OdataRequest {

    /**
     * Creates an instance of OdataRequest. The constructor also splits the url into service,
     * odata and query parts.
     *
     * @param {Object} inRequest  A request object with {method, url, headers, payload}
     * @param {Function} serviceResolutionFn - Function to resolve the service name in the request URL.
     *  It must return an object with the 'base' and 'path' parts of the input URL.
     */
    constructor(inRequest, serviceResolutionFn) {

        this._inRequest = inRequest;
        this._serviceResolutionFn = serviceResolutionFn;

        /**
         * OData request id, usually same as _odataRequestId but in case of batch processing this contains the request id
         * from the deserialized odata batch payload
         * @type {null}
         * @private
         */
        this._odataRequestId = this._inRequest.getOdataRequestId ? this._inRequest.getOdataRequestId() : null;
        this._atomicityGroupId = this._inRequest.getAtomicityGroupId ? this._inRequest.getAtomicityGroupId() : null;
        this._url = url.parse(this._inRequest.url);

        this._parsedUrlResult = null;
        this._rawBaseUri = null;
        this._rawODataPath = null;
        this._queryOptions = null;
        this._uriInfo = null;

        /**
         * @type {RequestContract}
         * @private
         */
        this._contract = new RequestContract();

        this._body = null;
        this._preferences = null;
        this._service = null;
        this._loggerFacade = null;
        this._validateEtagHasBeenCalled = false;
        this._isConditional = null;
        this._etagValidationOutCome = HttpStatusCodes.OK;
        this._concurrentSegment = null;
        this._getConcurrentResourceHasBeenCalled = false;
        this._applicationData = null;

        // Transfer batch information to the batched OdataRequest.
        this._batchInfo = this._inRequest.getBatchInfo ? this._inRequest.getBatchInfo() : null;

        this._deepInsertExpand = [];
    }

    /**
     * Set an ExpandItem array. This is the root node of an expand tree reflecting a deep insert.
     *
     * @param {ExpandItem[]} expand The expand item to set
     * @returns {OdataRequest} This instance of odata request
     * @package
     */
    setDeepInsertExpand(expand) {
        this._deepInsertExpand = expand;
        return this;
    }

    /**
     * Returns an ExpandItem which is the root of an expand item tree reflecting a deep insert payload.
     * If there is no expand item tree existing returns an empty array;
     *
     * @returns {ExpandItem[]} The root expand item derived from a deep insert payload.
     *                         Can be empty if there is no expand item available.
     */
    getDeepInsertExpand() {
        return this._deepInsertExpand;
    }

    /**
     * Return  OData request id
     *
     * @returns {?string}
     */
    getOdataRequestId() {
        return this._odataRequestId;
    }

    /**
     * Return atomicity group id
     *
     * @returns {?string}
     */
    getAtomicityGroupId() {
        return this._atomicityGroupId;
    }


    /**
     * Returns the current logger instance.
     *
     * @returns {LoggerFacade} The current logger facade
     */
    getLogger() {
        return this._loggerFacade;
    }

    /**
     * Sets the current logger instance.
     *
     * @param {Object} logger The current logger
     * @returns {OdataRequest} This odata request instance
     * @package
     */
    setLogger(logger) {
        this._loggerFacade = logger;
        return this;
    }

    /**
     * Resolve the current original url by the provided base path configuration.
     * The configured base path will be used to shorten the original url to
     * create the odata url parsing entry.
     *
     * @private
     * @returns {OdataRequest} The current odata request instance
     */
    _resolveServiceBasePath() {
        if (this._parsedUrlResult == null) {
            this._parsedUrlResult = this._serviceResolutionFn(this._url);
            this._rawBaseUri = this._parsedUrlResult.base;
            this._rawODataPath = this._parsedUrlResult.pathname;
        }
        return this;
    }

    /**
     * Returns the url path segments of the request url that belong to odata.
     *
     * @returns {string} undecoded OData path segments, e.g., "/Employees"
     */
    getOdataPath() {
        return this._resolveServiceBasePath()._rawODataPath;
    }

    /**
     * Returns the request method.
     *
     * @returns {string} The request method like GET, PUT, POST ...
     */
    getMethod() {
        return this._inRequest.method;
    }

    /**
     * Returns the header value for a given name.
     *
     * @returns {string} The header value or undefined, if not found
     */
    getHeader(name) {
        return this._inRequest.headers[name];
    }

    /**
     * Returns all available headers.
     *
     * @returns {Object} All headers with header:headerValue
     */
    getHeaders() {
        return this._inRequest.headers;
    }

    /**
     * Returns the parsed url object parsed with node.js url module.
     *
     * @returns {Object} The parsed url object.
     */
    getUrlObject() {
        return this._url;
    }


    /**
     * Returns the current query options. Structure of the object is defined as follows
     * Example:
     *  url: http://server:port/service/?foo=bar1&foo=bar2&bar=foo
     *  result:
     *  {
     *   foo: ['bar1', 'bar2'],
     *   bar: 'foo'
     *  }
     *
     * @returns {Object|*} The parsed query options object.
     */
    getQueryOptions() {
        this._resolveServiceBasePath();
        if (this._queryOptions === null) {
            this._queryOptions = UriHelper.parseQueryString(this._parsedUrlResult.search);
        }

        return this._queryOptions;
    }

    /**
     * Sets the uri info object. This is done while processing the request.
     *
     * @param {UriInfo} uriInfo The uri info
     * @returns {OdataRequest} this request object
     * @package
     */
    setUriInfo(uriInfo) {
        this._uriInfo = uriInfo;
        return this;
    }

    /**
     * Returns the uri info object.
     * This object is the result of the uri parsing and will be set
     * while processing the request but before reaching the application handlers.
     *
     * @returns {UriInfo} The uri info object.
     */
    getUriInfo() {
        return this._uriInfo;
    }

    /**
     * Returns the current request contract.
     *
     * @returns {RequestContract} The current request contract
     */
    getContract() {
        return this._contract;
    }

    /**
     * Sets the request body. The body is set though the parsing of the payload.
     *
     * @param {*} body The request body
     * @returns {OdataRequest} This instance
     * @package
     */
    setBody(body) {
        this._body = body;
        return this;
    }

    /**
     * Returns the request body created by application. This is the parsed result of the request payload
     *
     * @param {*} body The request body
     * @returns {*} This body
     */
    getBody() {
        return this._body;
    }

    /**
     * Sets the parsed preferences
     *
     * @param {Preferences} preferences
     * @returns {OdataRequest} this request object
     * @package
     */
    setPreferences(preferences) {
        this._preferences = preferences;
        return this;
    }

    /**
     * Returns the preferences parsed from the request header
     *
     * @returns {Preferences}
     */
    getPreferences() {
        if (!this._preferences) this._preferences = new Preferences();
        return this._preferences;
    }

    /**
     * Returns the original incoming node request message.
     *
     * @returns {IncomingMessage} the original incoming request
     */
    getIncomingRequest() {
        return this._inRequest;
    }

    /**
     * Set the used service instance
     *
     * @param {Service} service
     * @returns {OdataRequest} this request object
     * @package
     */
    setService(service) {
        this._service = service;
        return this;
    }

    /**
     * Return the used service instance
     *
     * @returns {Service}
     */
    getService() {
        return this._service;
    }

    /**
     * Returns true if this request is a conditional request.
     * A request is conditional if at least one of the following supported headers are present: If-Match, If-None-Match.
     *
     * @returns {boolean} True if this request is conditional, else false
     */
    isConditional() {
        if (this._isConditional === null) {
            this._isConditional = this.getHeader(HeaderNames.IF_MATCH.toLowerCase()) != null
                || this.getHeader(HeaderNames.IF_NONE_MATCH.toLowerCase()) != null;
        }
        return this._isConditional;
    }

    /**
     * Validates a provided resource etag value against the conditional etag header values of
     * If-Match and If-None-Match.
     *
     * @param {string} etag The etag value of the resource
     * @returns {HttpStatusCodes.OK | HttpStatusCodes.NOT_MODIFIED} OK, if validation was ok,
     *      NOT_MODIFIED if etag values are matching indecating that the resource was not modified
     * @throws {PreconditionFailedError} Thrown if the validations failed
     * @throws {NotImplementedError} Thrown in case of an unsupported upsert scenario
     */
    validateEtag(etag) {
        const logger = this._loggerFacade;
        logger.path('Entering OdataRequest.validateEtag()...');
        logger.debug('Provided etag to validate: ', etag);

        this._validateEtagHasBeenCalled = true;

        // Currently the statemachine works synchron. This allows throwing a synchron error
        this._stateMachine = new StateMachine(ConditionalRequestValidator.createStateMachineContext(logger), logger)
            .on('error', (error) => { throw error; });

        new ConditionalRequestValidator(this._stateMachine).startWith(ConditionalRequestValidator.STATES.VALIDATE)
            .validate({
                ifMatch: this.getHeader(HeaderNames.IF_MATCH.toLowerCase()),
                ifNoneMatch: this.getHeader(HeaderNames.IF_NONE_MATCH.toLowerCase()),
                kind: this.getUriInfo().getLastSegment().getKind(),
                method: this.getMethod()
            }, etag);

        const STATES = ConditionalRequestValidator.STATES;
        const history = this._stateMachine.getHistory().map(elem => elem.name);
        logger.debug('Conditional request processing state history (after etag validation): ',
            this._stateMachine.getHistory());

        // last state should be final therefore we use the penultimate state
        if (history[history.length - 2] === STATES.NOT_MODIFIED) {
            this._etagValidationOutCome = HttpStatusCodes.NOT_MODIFIED;
        }

        return this._etagValidationOutCome;
    }

    /**
     * Returns the concurrent UriResource segment if the resource addressed by this URI is concurrent.
     *
     * @returns {?UriResource} the concurrent UriResource segment, if this resource is concurrent, else null
     */
    getConcurrentResource() {
        if (this._getConcurrentResourceHasBeenCalled) {
            return this._concurrentSegment;
        }
        const lastSegment = this.getUriInfo().getLastSegment();
        let segment = null;

        if ((lastSegment.getKind() === ResourceKind.METADATA
            || lastSegment.getKind() === ResourceKind.SERVICE)) {
            this._getConcurrentResourceHasBeenCalled = true;
            this._concurrentSegment = lastSegment;
            return lastSegment;
        }

        if (this.getMethod() !== HttpMethods.GET
            && (lastSegment.getKind() === ResourceKind.REF || lastSegment.getKind() === ResourceKind.REF_COLLECTION)) {
            segment = this.getUriInfo().getLastSegment(-2);
        } else {
            segment = this.getUriInfo().getPathSegments().reduceRight(
                (result, tempSegment) =>
                    !result
                    && !tempSegment.getAction()
                    && tempSegment.getEdmType() && tempSegment.getEdmType().getKind() === EdmTypeKind.ENTITY
                    && !(tempSegment.getNavigationProperty() && tempSegment.getNavigationProperty().containsTarget()) ?
                        tempSegment : result,
                null);
        }
        if (segment && !(segment.getEntitySet() && segment.getEntitySet().isConcurrent()
            || segment.getSingleton() && segment.getSingleton().isConcurrent()
            || segment.getTarget() && segment.getTarget().isConcurrent())) {
            segment = null;
        }
        this._getConcurrentResourceHasBeenCalled = true;
        this._concurrentSegment = segment;
        return segment;
    }

    /**
     * Return the outcome of the etag validation process. This can be one of the following outcomes:
     *  - HttpStatusCode.OK = Validation was ok
     *  - HttpStatusCode.NOT_MODIFIED = Validation was ok and outcome is "resource is not modified"
     * Default is HttpStatusCode.OK.
     *
     * @returns {HttpStatusCode.StatusCodes.OK | HttpStatusCode.StatusCodes.NOT_MODIFIED} The status code
     * @package
     */
    getETAGValidationStatus() {
        return this._etagValidationOutCome;
    }

    /**
     * Return true if the etag validation has been called.
     * @returns {boolean} True if the etag validation has been called, else false
     * @package
     */
    validateEtagHasBeenCalled() {
        return this._validateEtagHasBeenCalled;
    }

    /**
     * Get custom application data associated with this request
     *
     * @returns {Object} data
     */
    getApplicationData() {
        return this._applicationData;
    }

    /**
     * Set custom application data
     * @param {Object} data
     * @returns {OdataRequest} this request object
     */
    setApplicationData(data) {
        this._applicationData = data;
        return this;
    }

    /**
     * Get custom application data associated with the batch request containing this request.
     * @returns {Object} data
     */
    getBatchApplicationData() {
        return this._batchInfo ? this._batchInfo.context.getRequest().getApplicationData() : null;
    }
}

module.exports = OdataRequest;
