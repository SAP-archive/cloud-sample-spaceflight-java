const {IllegalFunctionArgumentError} = require('@sap/cds-sql').errors

class SqliteStatement {
  /**
   * Create an SqliteStatement object.
   *
   * @param {Object} statement - Statement object obtained from the sqlite3 library.
   * @param {Object} db - Database object obtained from the sqlite3 library.
   */
  constructor (statement, db) {
    this._stmt = statement
    this._db = db
  }

  /**
   * Execute prepared statement.
   *
   * Values are provided as an array.
   * In order to insert multiple rows with a single execute
   * values have to be provided as arrays of values composed in an outer array.
   *
   * Method returns a result object.
   * In case of SELECT the result object contains a result-set.
   * In other cases the result is an empty array - DIFFERENT TO HANA!
   *
   * @example
   * single insert: execute([1, 'a'])
   * multiple insert: execute([[1, 'a'], [2, 'b']])
   *
   * @param {Array} values - Values to be set in the prepared SQL statement.
   * @returns {Promise} Promise, that resolves with result object (array) if successful or rejects with error if not.
   */
  execute (values) {
    // Sqlite cannot handle if values is not an Array
    if (!Array.isArray(values)) {
      // end invalid prepared statement
      this._stmt.finalize()
      return Promise.reject(new IllegalFunctionArgumentError('values'))
    }

    return new Promise((resolve, reject) => {
      this._db.serialize(() => {
        if (Array.isArray(values[0])) {
          this._handleMultiInsert(values, resolve, reject)
        } else {
          this._handleSingleInsert(values, resolve, reject)
        }
      })
    })
  }

  _handleSingleInsert (values, resolve, reject) {
    this._stmt.all(values, (err, result) => {
      this._stmt.finalize()

      if (err) {
        // statement must be finalized also in case of error
        return reject(err)
      }

      resolve(result)
    })
  }

  _handleMultiInsert (values, resolve, reject) {
    const listPromise = []

    values.forEach((val) => {
      listPromise.push(new Promise((resolve, reject) => {
        this._stmt.all(val, (err) => {
          if (err) {
            return reject(err)
          }

          resolve()
        })
      }))
    })

    // IN THIS CASE NO SELECT IS EXPECTED.
    // RESOLVE WITH [] TO BE CONSISTENT WITH THE SINGLE CASE.
    Promise.all(listPromise)
      .then(() => {
        this._stmt.finalize()
        resolve([])
      })
      .catch((err) => {
        this._stmt.finalize() // statement must be finalized also in case of error
        reject(err)
      })
  }
}

module.exports = SqliteStatement
